<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<title>CASINO ROYALE</title>
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='80' font-size='80'>🎰</text></svg>" type="image/svg+xml">
<script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.20.0/matter.min.js"></script>
<style>
@import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Inter:wght@300;400;600;700&display=swap');
*{margin:0;padding:0;box-sizing:border-box;-webkit-tap-highlight-color:transparent;}
button,select,input,[onclick]{touch-action:manipulation;cursor:pointer;}
:root{
  --bg:#0a0a1a;--surface:#111128;--surface2:#1a1a3e;--border:#2a2a5e;
  --gold:#ffd700;--neon:#00f0ff;--neon2:#ff00e5;--green:#00ff88;--red:#ff3355;
  --text:#e8e8ff;--text2:#8888aa;
}
html,body{height:100%;height:100dvh;overflow:hidden;overflow-x:hidden;background:var(--bg);color:var(--text);font-family:'Inter',sans-serif;width:100%;max-width:100vw;}
.catalog-card {
  width: 140px;
  height: 160px;
  background: var(--surface2);
  border-radius: 16px;
  border: 2px solid var(--border);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  font-family: 'Orbitron', sans-serif;
  font-size: 18px;
  font-weight: 700;
  color: var(--text2);
  cursor: pointer;
  transition: all .2s;
  box-shadow: 0 4px 24px rgba(0,240,255,.08);
  gap: 8px;
}
.catalog-card .icon {
  font-size: 48px;
  margin-bottom: 8px;
}
.catalog-card:hover {
  border-color: var(--neon);
  color: var(--neon);
  background: var(--surface);
  transform: translateY(-6px) scale(1.04);
  box-shadow: 0 8px 32px rgba(0,240,255,.15);
}

/* Top Nav */
#topNav{position:fixed;top:0;left:0;right:0;height:50px;background:linear-gradient(180deg,#15153a,#0d0d25);
  border-bottom:1px solid var(--border);display:flex;align-items:center;padding:0 10px;z-index:1000;gap:2px;}
#topNav .logo{font-family:'Orbitron';font-weight:900;font-size:16px;
  background:linear-gradient(135deg,var(--gold),var(--neon));-webkit-background-clip:text;background-clip:text;-webkit-text-fill-color:transparent;margin-right:6px;white-space:nowrap;flex-shrink:0;cursor:pointer;}
.nav-cat{position:relative;flex-shrink:0;}
.nav-cat-btn{padding:6px 10px;border:none;border-radius:6px;cursor:pointer;font-size:11px;font-weight:700;
  background:transparent;color:var(--text2);transition:all .2s;font-family:'Inter',sans-serif;white-space:nowrap;display:flex;align-items:center;gap:4px;}
.nav-cat-btn:hover,.nav-cat.open .nav-cat-btn{background:var(--surface2);color:var(--text);}
.nav-cat-btn .cat-icon{font-size:13px;}
.nav-cat-btn .cat-arrow{font-size:8px;opacity:.5;transition:transform .2s;}
.nav-cat.open .cat-arrow{transform:rotate(180deg);}
.nav-cat-btn.has-active{color:var(--neon);}
.nav-dropdown{display:none;position:absolute;top:100%;left:0;min-width:160px;background:linear-gradient(180deg,#1a1a40,#111130);
  border:1px solid var(--border);border-radius:8px;padding:4px;z-index:1001;box-shadow:0 8px 32px rgba(0,0,0,.6);margin-top:4px;}
.nav-cat.open .nav-dropdown{display:block;}
.nav-btn{padding:6px 10px;border:none;border-radius:6px;cursor:pointer;font-size:11px;font-weight:600;
  background:transparent;color:var(--text2);transition:all .15s;font-family:'Inter',sans-serif;white-space:nowrap;display:block;width:100%;text-align:left;}
.nav-btn:hover{background:var(--surface2);color:var(--text);}
.nav-btn.active{background:linear-gradient(135deg,#1a1a5e,#2a1a4e);color:var(--neon);
  box-shadow:0 0 15px rgba(0,240,255,.15);border:1px solid rgba(0,240,255,.3);}
.nav-btn .icon{font-size:13px;margin-right:5px;}
.nav-btn-inline{padding:6px 10px;border:none;border-radius:6px;cursor:pointer;font-size:11px;font-weight:600;
  background:transparent;color:var(--text2);transition:all .15s;font-family:'Inter',sans-serif;white-space:nowrap;flex-shrink:0;}
.nav-btn-inline:hover{background:var(--surface2);color:var(--text);}
.nav-btn-inline.active{background:linear-gradient(135deg,#1a1a5e,#2a1a4e);color:var(--neon);
  box-shadow:0 0 15px rgba(0,240,255,.15);border:1px solid rgba(0,240,255,.3);}
.nav-btn-inline .icon{font-size:13px;margin-right:3px;}
.nav-label{display:inline;}
/* Games Menu */
.games-category{background:var(--surface);border:1px solid var(--border);border-radius:12px;padding:16px;overflow:hidden;}
.games-category-title{font-family:'Orbitron';font-size:14px;font-weight:900;color:var(--neon);letter-spacing:1px;margin-bottom:12px;display:flex;align-items:center;gap:8px;}
.games-category-title .icon{font-size:20px;}
.games-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(100px,1fr));gap:8px;}
.game-btn{padding:12px;border:1px solid var(--border);border-radius:8px;background:var(--bg);color:var(--text2);cursor:pointer;font-size:11px;font-weight:700;font-family:'Orbitron';transition:all .2s;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:6px;white-space:nowrap;text-align:center;}
.game-btn .game-icon{font-size:24px;}
.game-btn:hover{border-color:var(--neon);background:var(--surface);color:var(--text);box-shadow:0 0 12px rgba(0,240,255,.2);transform:translateY(-2px);}
.game-btn:active{transform:scale(0.98);}

#balanceDisplay{margin-left:auto;display:flex;align-items:center;gap:8px;flex-shrink:0;}
#balanceDisplay .bal{font-family:'Orbitron';font-size:16px;color:var(--gold);text-shadow:0 0 10px rgba(255,215,0,.4);}
#balanceDisplay .add-btn{padding:5px 10px;border:none;border-radius:6px;cursor:pointer;
  background:linear-gradient(135deg,#1a5a1a,#0a3a0a);color:var(--green);font-weight:700;font-size:12px;
  border:1px solid rgba(0,255,136,.3);transition:all .2s;font-family:'Inter',sans-serif;}
#balanceDisplay .add-btn:hover{background:linear-gradient(135deg,#2a7a2a,#1a5a1a);box-shadow:0 0 15px rgba(0,255,136,.2);}
/* How-to-play info boxes */
.htp-box{background:linear-gradient(135deg,rgba(0,240,255,.05),rgba(255,0,229,.03));border:1px solid rgba(0,240,255,.15);
  border-radius:10px;padding:0;margin:6px 0;max-width:420px;overflow:hidden;font-size:12px;line-height:1.5;transition:all .3s;}
.htp-toggle{display:flex;align-items:center;gap:6px;padding:8px 12px;cursor:pointer;color:var(--neon);font-weight:600;font-size:11px;
  font-family:'Orbitron';letter-spacing:1px;background:transparent;border:none;width:100%;text-align:left;}
.htp-toggle:hover{background:rgba(0,240,255,.05);}
.htp-toggle .htp-arrow{transition:transform .2s;font-size:10px;}
.htp-box.open .htp-arrow{transform:rotate(90deg);}
.htp-content{display:none;padding:0 12px 10px 12px;color:var(--text2);}
.htp-box.open .htp-content{display:block;}
.htp-content ul{margin:4px 0 4px 16px;padding:0;}
.htp-content li{margin:2px 0;}
.htp-content strong{color:var(--text);}

/* Game Panels */
.game-panel{position:fixed;top:50px;left:0;right:0;bottom:0;display:none;overflow-y:auto;overflow-x:hidden;-webkit-overflow-scrolling:touch;padding:16px;padding-bottom:calc(16px + env(safe-area-inset-bottom,0px));}
.game-panel.active{display:flex;flex-direction:column;align-items:center;gap:12px;}

/* Shared Controls */
.bet-controls{display:flex;align-items:center;gap:10px;padding:12px 16px;background:var(--surface);
  border-radius:12px;border:1px solid var(--border);}
.bet-input{width:120px;padding:8px 12px;border-radius:8px;border:1px solid var(--border);
  background:var(--bg);color:var(--gold);font-family:'Orbitron';font-size:14px;text-align:right;outline:none;}
.bet-input:focus{border-color:var(--neon);box-shadow:0 0 10px rgba(0,240,255,.2);}
.bet-btn{padding:8px 14px;border:none;border-radius:6px;cursor:pointer;font-weight:700;font-size:12px;
  transition:all .15s;font-family:'Inter',sans-serif;}
.bet-half{background:#2a2a5e;color:var(--text);}
.bet-double{background:#2a2a5e;color:var(--text);}
.bet-half:hover,.bet-double:hover{background:#3a3a7e;}
.action-btn{padding:12px 32px;border:none;border-radius:10px;cursor:pointer;font-weight:700;font-size:15px;
  font-family:'Orbitron';transition:all .2s;text-transform:uppercase;letter-spacing:1px;}
.action-btn.primary{background:linear-gradient(135deg,#00cc66,#009944);color:#fff;
  box-shadow:0 4px 20px rgba(0,204,102,.3);}
.action-btn.primary:hover{transform:translateY(-2px);box-shadow:0 6px 25px rgba(0,204,102,.4);}
.action-btn.primary:active{transform:translateY(0);}
.action-btn:disabled{opacity:.4;cursor:not-allowed;transform:none!important;}
.action-btn.danger{background:linear-gradient(135deg,#cc3355,#991133);color:#fff;
  box-shadow:0 4px 20px rgba(204,51,85,.3);}

/* ============ SLOTS ============ */
#slotsPanel{flex-direction:column;align-items:center;justify-content:center;gap:24px;
  background:radial-gradient(ellipse at center,#15153a 0%,#0a0a1a 70%);}
.slots-machine{position:relative;background:linear-gradient(180deg,#1a1a4e,#111138);
  border-radius:20px;border:2px solid var(--border);padding:30px;
  box-shadow:0 0 60px rgba(0,240,255,.08),inset 0 0 60px rgba(0,0,0,.5);}
.slots-header{text-align:center;font-family:'Orbitron';font-size:28px;font-weight:900;
  background:linear-gradient(135deg,var(--gold),#ff8800);-webkit-background-clip:text;background-clip:text;-webkit-text-fill-color:transparent;
  margin-bottom:20px;text-shadow:0 0 20px rgba(255,215,0,.3);}
.reels-container{display:flex;gap:8px;justify-content:center;margin-bottom:20px;position:relative;}
.reel-window{width:100px;height:280px;overflow:hidden;border-radius:12px;
  background:#08081a;border:2px solid var(--border);position:relative;}
.reel-window::before,.reel-window::after{content:'';position:absolute;left:0;right:0;height:40%;z-index:2;pointer-events:none;}
.reel-window::before{top:0;background:linear-gradient(180deg,rgba(8,8,26,.95),transparent);}
.reel-window::after{bottom:0;background:linear-gradient(0deg,rgba(8,8,26,.95),transparent);}
.reel-strip{display:flex;flex-direction:column;transition:transform .5s cubic-bezier(.2,.8,.3,1);}
.reel-symbol{width:100px;height:93px;display:flex;align-items:center;justify-content:center;font-size:48px;}
.payline-indicator{position:absolute;left:-8px;right:-8px;top:50%;transform:translateY(-50%);
  height:3px;background:var(--gold);box-shadow:0 0 10px var(--gold);z-index:3;border-radius:2px;}
.slots-info{text-align:center;color:var(--text2);font-size:13px;margin-top:8px;}

/* ============ CRASH ============ */
#crashPanel{flex-direction:column;align-items:center;justify-content:center;gap:20px;
  background:radial-gradient(ellipse at bottom,#0a1a2a 0%,#0a0a1a 70%);}
.crash-container{position:relative;width:min(700px,90vw);height:min(400px,50vh);
  background:var(--surface);border-radius:16px;border:1px solid var(--border);overflow:hidden;}
.crash-canvas{width:100%;height:100%;}
.crash-multiplier{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);
  font-family:'Orbitron';font-weight:900;font-size:72px;color:#fff;text-shadow:0 0 40px rgba(0,240,255,.5);
  pointer-events:none;transition:color .3s;}
.crash-multiplier.crashed{color:var(--red);text-shadow:0 0 40px rgba(255,51,85,.5);animation:crashShake .3s ease;}
.crash-status{font-family:'Orbitron';font-size:14px;color:var(--text2);text-align:center;}
@keyframes crashShake{0%,100%{transform:translate(-50%,-50%)}25%{transform:translate(-48%,-52%)}75%{transform:translate(-52%,-48%)}}

/* ============ ROULETTE ============ */
#roulettePanel{flex-direction:column;align-items:center;justify-content:center;gap:20px;
  background:radial-gradient(ellipse at center,#1a0a1a 0%,#0a0a1a 70%);}
.roulette-wrapper{position:relative;}
.roulette-canvas{border-radius:50%;box-shadow:0 0 60px rgba(255,0,229,.15),0 0 120px rgba(255,0,229,.05);}
.roulette-pointer{position:absolute;top:-18px;left:50%;transform:translateX(-50%);
  width:0;height:0;border-left:14px solid transparent;border-right:14px solid transparent;
  border-top:24px solid var(--gold);filter:drop-shadow(0 0 8px rgba(255,215,0,.6));z-index:5;}
.roulette-result{font-family:'Orbitron';font-size:24px;font-weight:700;text-align:center;min-height:36px;}
.roulette-bets{display:flex;gap:8px;flex-wrap:wrap;justify-content:center;max-width:500px;}
.roul-bet-btn{padding:10px 20px;border:2px solid var(--border);border-radius:8px;cursor:pointer;
  font-weight:700;font-size:14px;transition:all .2s;background:var(--surface);color:var(--text);font-family:'Inter',sans-serif;}
.roul-bet-btn:hover{border-color:var(--neon);box-shadow:0 0 15px rgba(0,240,255,.15);}
.roul-bet-btn.selected{border-color:var(--neon);background:rgba(0,240,255,.1);color:var(--neon);}
.roul-bet-btn.red-btn{border-color:#cc3333;}
.roul-bet-btn.red-btn.selected{background:rgba(204,51,51,.2);color:#ff5555;border-color:#ff5555;}
.roul-bet-btn.black-btn{border-color:#444;}
.roul-bet-btn.black-btn.selected{background:rgba(255,255,255,.1);color:#fff;border-color:#888;}
.roul-bet-btn.green-btn{border-color:#00aa44;}
.roul-bet-btn.green-btn.selected{background:rgba(0,170,68,.2);color:var(--green);border-color:var(--green);}

/* ============ CASES ============ */
#casesPanel{flex-direction:column;align-items:flex-start;justify-content:flex-start;gap:14px;
  background:radial-gradient(ellipse at top,#1a1a0a 0%,#0a0a1a 70%);overflow-y:auto;padding:70px 16px 20px!important;}
.case-selector{display:flex;gap:10px;flex-wrap:wrap;justify-content:center;max-height:320px;overflow-y:auto;
  padding:8px 4px;border:1px solid var(--border);border-radius:12px;background:rgba(0,0,0,.3);width:100%;
  scrollbar-width:thin;scrollbar-color:var(--neon) transparent;}
.case-selector::-webkit-scrollbar{width:6px;}
.case-selector::-webkit-scrollbar-thumb{background:var(--neon);border-radius:3px;}
.case-selector::after{content:'↕ Scroll for more cases';display:block;width:100%;text-align:center;
  font-size:10px;color:var(--text2);padding:4px 0;flex-shrink:0;}
.case-card{width:120px;padding:12px 8px;border-radius:12px;border:2px solid var(--border);
  background:var(--surface);cursor:pointer;text-align:center;transition:all .2s;}
.case-card:hover{transform:translateY(-4px);border-color:var(--gold);}
.case-card.selected{border-color:var(--gold);box-shadow:0 0 20px rgba(255,215,0,.2);}
.case-card .case-icon{font-size:32px;margin-bottom:4px;}
.case-card .case-name{font-weight:700;font-size:12px;margin-bottom:2px;}
.case-card .case-price{color:var(--gold);font-family:'Orbitron';font-size:11px;}
.case-opener{position:relative;width:min(700px,92vw);height:120px;background:var(--surface);
  border-radius:12px;border:1px solid var(--border);overflow:hidden;}
.case-strip{display:flex;position:absolute;top:0;height:100%;transition:transform 4s cubic-bezier(.08,.82,.17,1);}
.case-item{width:120px;height:120px;display:flex;flex-direction:column;align-items:center;justify-content:center;
  flex-shrink:0;border-right:1px solid var(--border);font-size:11px;font-weight:700;gap:2px;position:relative;}
.case-item .item-icon{font-size:36px;}
.case-item .item-rarity{position:absolute;bottom:0;left:0;right:0;height:3px;}
.case-pointer{position:absolute;top:0;bottom:0;left:50%;transform:translateX(-50%);
  width:3px;background:var(--gold);box-shadow:0 0 10px var(--gold);z-index:5;}
.case-won{font-family:'Orbitron';font-size:18px;font-weight:700;text-align:center;min-height:32px;}
.case-won-detail{font-size:11px;color:var(--text2);text-align:center;}

/* Case enhancements */
.case-opener{position:relative;width:min(700px,92vw);height:120px;background:var(--surface);
  border-radius:12px;border:1px solid var(--border);overflow:hidden;transition:border-color 0.5s,box-shadow 0.5s;}
.case-opener.rare-reveal{border-color:#8847ff;box-shadow:0 0 30px rgba(136,71,255,.4);}
.case-opener.legendary-reveal{border-color:#ffd700;box-shadow:0 0 40px rgba(255,215,0,.5),0 0 80px rgba(255,215,0,.2);animation:legendaryPulse 0.5s ease 3;}
@keyframes legendaryPulse{0%,100%{box-shadow:0 0 40px rgba(255,215,0,.5)}50%{box-shadow:0 0 60px rgba(255,215,0,.8),0 0 120px rgba(255,215,0,.3)}}
.case-item.highlighted{animation:itemHighlight 0.5s ease;z-index:2;}
@keyframes itemHighlight{0%{transform:scale(1)}50%{transform:scale(1.08)}100%{transform:scale(1)}}
.case-recent-item{flex-shrink:0;padding:4px 8px;border-radius:6px;background:var(--surface);border:1px solid var(--border);
  font-size:10px;display:flex;align-items:center;gap:4px;white-space:nowrap;animation:recentSlide 0.3s ease;}
@keyframes recentSlide{from{opacity:0;transform:translateX(-10px)}to{opacity:1;transform:translateX(0)}}

/* Item Rarity Colors */
.rarity-consumer{color:#b0c3d9!important;}
.rarity-industrial{color:#5e98d9!important;}
.rarity-milspec{color:#4b69ff!important;}
.rarity-restricted{color:#8847ff!important;}
.rarity-classified{color:#d32ce6!important;}
.rarity-covert{color:#eb4b4b!important;}
.rarity-legendary{color:#ffd700!important;}

/* ============ INVENTORY OVERLAY ============ */
#inventoryOverlay{position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,.85);
  z-index:2000;display:none;flex-direction:column;align-items:center;padding:20px;overflow-y:auto;}
#inventoryOverlay.show{display:flex;}
.inv-header{display:flex;align-items:center;justify-content:space-between;width:100%;max-width:900px;
  margin-bottom:16px;}
.inv-title{font-family:'Orbitron';font-size:22px;font-weight:900;
  background:linear-gradient(135deg,var(--gold),var(--neon));-webkit-background-clip:text;-webkit-text-fill-color:transparent;}
.inv-close{padding:8px 20px;border:1px solid var(--border);border-radius:8px;background:var(--surface);
  color:var(--text);cursor:pointer;font-weight:700;font-size:14px;transition:all .2s;}
.inv-close:hover{border-color:var(--red);color:var(--red);}
.inv-tabs{display:flex;gap:8px;margin-bottom:16px;}
.inv-tab{padding:8px 18px;border:1px solid var(--border);border-radius:8px;background:var(--surface);
  color:var(--text2);cursor:pointer;font-weight:600;font-size:13px;transition:all .2s;}
.inv-tab.active{border-color:var(--neon);color:var(--neon);background:rgba(0,240,255,.08);}
.inv-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(140px,1fr));gap:10px;
  width:100%;max-width:900px;}
.inv-item{background:var(--surface);border:1px solid var(--border);border-radius:10px;
  padding:12px;text-align:center;cursor:pointer;transition:all .2s;position:relative;}
.inv-item:hover{border-color:var(--gold);transform:translateY(-2px);}
.inv-item .ii-icon{font-size:32px;margin-bottom:4px;}
.inv-item .ii-name{font-size:11px;font-weight:700;margin-bottom:2px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}
.inv-item .ii-value{font-family:'Orbitron';font-size:12px;color:var(--gold);}
.inv-item .ii-demand{font-size:9px;margin-top:2px;}
.inv-item .ii-rarity-bar{position:absolute;bottom:0;left:0;right:0;height:3px;border-radius:0 0 10px 10px;}
.inv-sell-btn{margin-top:6px;padding:4px 12px;border:none;border-radius:4px;font-size:10px;
  font-weight:700;cursor:pointer;background:var(--red);color:#fff;transition:all .15s;}
.inv-sell-btn:hover{background:#ff4466;}
.inv-empty{grid-column:1/-1;text-align:center;padding:40px;color:var(--text2);font-size:14px;}

/* Market stats */
.market-stats{display:flex;gap:16px;align-items:center;justify-content:center;width:100%;max-width:900px;
  margin-bottom:12px;padding:10px;background:var(--surface);border-radius:10px;border:1px solid var(--border);}
.market-stat{text-align:center;}
.market-stat .ms-label{font-size:9px;color:var(--text2);text-transform:uppercase;letter-spacing:1px;}
.market-stat .ms-val{font-family:'Orbitron';font-size:14px;font-weight:700;}

/* ============ PLINKO ============ */
#plinkoPanel{flex-direction:row;background:radial-gradient(ellipse at center,#0a1a2a 0%,#0a0a1a 70%);} 

/* Touch / responsive tweaks for iPad */
@media (max-width:1024px){
  #topNav{overflow-x:auto;-webkit-overflow-scrolling:touch;scrollbar-width:none;gap:1px;flex-wrap:nowrap;padding:0 6px;}
  #topNav::-webkit-scrollbar{display:none;}
  .nav-label{display:none;}
  .nav-btn-inline{font-size:0;padding:6px 8px;}
  .nav-btn-inline .icon{font-size:15px;margin-right:0;}
  #balanceDisplay{gap:3px;margin-left:auto;flex-shrink:1;min-width:0;}
  #balanceDisplay .bal{font-size:12px;white-space:nowrap;}
  #balanceDisplay .add-btn{display:none;}
  .daily-bonus-btn{font-size:8px!important;padding:2px 6px!important;white-space:nowrap;}
  .user-name{display:none;}
  .user-info{gap:3px;margin-left:2px;}
  .user-avatar{width:30px!important;height:30px!important;}
  .logout-btn{width:26px;height:26px;font-size:12px;}
  #muteBtn{padding:3px 5px!important;font-size:11px!important;}
  .game-panel{padding:12px;justify-content:flex-start!important;}
  #plinkoPanel{flex-direction:column;}
  #luckPanel{overflow:hidden!important;padding:0!important;}
  #casesPanel{padding-top:12px!important;}
  #gameCatalog{padding-top:16px;padding-bottom:calc(80px + env(safe-area-inset-bottom,0px));}
  .plinko-sidebar{width:100%;order:2;padding:12px}
  .plinko-canvas-wrap{max-width:calc(100vw - 40px);width:100%;height:min(420px,50vh)}
  .catalog-card{width:110px;height:120px}
  .user-avatar{width:36px;height:36px;font-size:18px}
  .pyl-lobby{padding-top:40px;}
  .pyl-modes{grid-template-columns:repeat(2,1fr);}
  .pyl-title{font-size:22px;}
  .bet-controls{flex-wrap:wrap;gap:6px;padding:8px 10px;}
  .bet-input{width:80px;font-size:12px;padding:6px 8px;}
  .action-btn{padding:10px 20px;font-size:13px;}
  .crash-container{max-height:40vh;width:min(700px,95vw);}
  .crash-multiplier{font-size:48px!important;}
  .slots-machine{padding:12px;}
  .reel-window{width:70px;height:180px;}
  .reel-symbol{width:70px;height:60px;font-size:32px;}
  .roulette-canvas{width:min(300px,70vw)!important;height:min(300px,70vw)!important;}
  .case-selector{gap:6px;}
  .case-card{width:90px;padding:8px 4px;}
  .case-card .case-icon{font-size:24px;}
  .case-card .case-name{font-size:10px;}
  .case-opener{height:100px;}
  .case-item{width:100px;height:100px;}
  .htp-box{max-width:100%;margin:4px 0;}
  .tower-cell{width:60px!important;height:50px!important;}
  .mine-cell{width:50px!important;height:50px!important;}
  .keno-num{width:42px!important;height:42px!important;font-size:11px!important;}
  .scratch-cell{width:72px!important;height:72px!important;font-size:28px!important;}
  .stock-chart-wrap{height:200px!important;}
  .horse-track{max-width:95vw;}
  #chatPanel{right:8px;width:min(340px, calc(100vw - 16px));max-height:min(460px, 70vh);}
  #chatToggleBtn{right:10px;bottom:10px;}
  .nav-dropdown{max-width:calc(100vw - 20px);}
}
@media (max-width:480px){
  #topNav .logo{font-size:12px;margin-right:2px;}
  #balanceDisplay .bal{font-size:11px;}
  #balanceDisplay .add-btn{font-size:9px;padding:2px 5px;}
  #chatPanel{right:4px;left:4px;width:auto;bottom:66px;}
  #gamesMenuOverlay{padding-top:50px;}
  .games-grid{grid-template-columns:repeat(auto-fill,minmax(80px,1fr));gap:6px;}
  .game-btn{padding:10px;font-size:10px;}
  .game-btn .game-icon{font-size:20px;}
  .game-panel{padding:8px;}
  .bet-controls{padding:6px 8px;}
  .bet-input{width:60px;font-size:11px;padding:4px 6px;}
  .action-btn{padding:8px 14px;font-size:12px;}
  .catalog-card{width:90px;height:100px;font-size:14px;}
  .catalog-card .icon{font-size:32px;margin-bottom:4px;}
}

/* Force avatar rounding and touch behavior */
.user-avatar{border-radius:50% !important;overflow:hidden !important;box-sizing:border-box !important;touch-action:manipulation;-webkit-tap-highlight-color:transparent}
.user-avatar, .user-avatar *{border-radius:50% !important;overflow:hidden !important}
.user-avatar img{width:100%;height:100%;object-fit:cover;display:block}
#gameCatalog{ -webkit-overflow-scrolling: touch; }

.plinko-sidebar{width:280px;padding:20px;display:flex;flex-direction:column;gap:16px;
  background:var(--surface);border-right:1px solid var(--border);overflow-y:auto;}
.plinko-sidebar label{font-size:13px;font-weight:600;color:var(--text2);margin-bottom:4px;display:block;}
.plinko-sidebar select,.plinko-sidebar input[type="number"]{width:100%;padding:8px 12px;border-radius:8px;
  border:1px solid var(--border);background:var(--bg);color:var(--text);font-size:14px;outline:none;font-family:'Inter',sans-serif;}
.plinko-sidebar select:focus,.plinko-sidebar input:focus{border-color:var(--neon);}
.plinko-main{flex:1;display:flex;flex-direction:column;align-items:center;justify-content:center;position:relative;}
.plinko-canvas-wrap{position:relative;width:760px;max-width:calc(100vw - 320px);height:570px;}
#plinkoCanvas{border-radius:12px;display:block;}
.plinko-bins{display:flex;gap:1%;justify-content:center;margin:4px auto 0;}
.plinko-bin{flex:1;text-align:center;padding:4px 0;border-radius:4px;font-size:11px;font-weight:700;
  color:#111;transition:transform .2s;min-width:0;}
.plinko-bin.bounce{animation:binBounce .3s ease;}
@keyframes binBounce{0%{transform:translateY(0)}50%{transform:translateY(30%)}100%{transform:translateY(0)}}
.plinko-last-wins{position:absolute;right:16px;top:50%;transform:translateY(-50%);
  display:flex;flex-direction:column;gap:0;width:48px;overflow:hidden;border-radius:6px;}
.plinko-last-win{width:48px;height:48px;display:flex;align-items:center;justify-content:center;
  font-size:12px;font-weight:700;color:#111;}

/* ============ PUSH YOUR LUCK ============ */
#luckPanel{flex-direction:column;align-items:center;justify-content:flex-start;gap:0;
  background:#000;padding:0!important;overflow:hidden;}
#luckPanel iframe{border:none;position:absolute;top:0;left:0;right:0;bottom:0;width:100%;height:100%;z-index:1;}

/* PYL Lobby Overlay */
.pyl-lobby{position:absolute;top:0;left:0;right:0;bottom:0;z-index:10;
  background:radial-gradient(ellipse at top,#1a0a2e 0%,#0a0a1a 60%,#000 100%);
  display:flex;flex-direction:column;align-items:center;padding:80px 20px 20px;overflow-y:auto;}
.pyl-lobby.hidden{display:none;}
.pyl-title{font-family:'Orbitron';font-size:28px;font-weight:900;text-align:center;
  background:linear-gradient(135deg,#ff6b6b,#ffd93d,#6bcb77,#4d96ff);
  -webkit-background-clip:text;background-clip:text;-webkit-text-fill-color:transparent;margin-bottom:6px;}
.pyl-subtitle{color:var(--text2);font-size:13px;margin-bottom:24px;text-align:center;}
.pyl-modes{display:grid;grid-template-columns:repeat(auto-fit,minmax(200px,1fr));gap:12px;
  width:100%;max-width:660px;margin-bottom:20px;}
.pyl-mode{background:var(--surface);border:2px solid var(--border);border-radius:14px;
  padding:18px;cursor:pointer;transition:all .25s;text-align:center;}
.pyl-mode:hover{border-color:var(--neon);transform:translateY(-3px);
  box-shadow:0 8px 30px rgba(0,240,255,.15);}
.pyl-mode .pm-icon{font-size:36px;margin-bottom:6px;}
.pyl-mode .pm-name{font-family:'Orbitron';font-size:14px;font-weight:700;margin-bottom:4px;}
.pyl-mode .pm-desc{font-size:11px;color:var(--text2);line-height:1.4;}
.pyl-mode .pm-badge{display:inline-block;margin-top:6px;padding:3px 10px;border-radius:20px;
  font-size:10px;font-weight:700;background:rgba(0,240,255,.1);color:var(--neon);border:1px solid var(--neon);}

/* PYL Game Overlay */
.pyl-overlay{position:absolute;top:60px;right:10px;z-index:15;display:flex;flex-direction:column;gap:6px;
  pointer-events:none;}
.pyl-overlay.hidden{display:none;}
.pyl-score-card{background:rgba(10,10,26,.9);border:1px solid var(--border);border-radius:10px;
  padding:10px 14px;pointer-events:auto;min-width:160px;}
.pyl-score-card .psc-label{font-size:9px;color:var(--text2);text-transform:uppercase;letter-spacing:1px;}
.pyl-score-card .psc-val{font-family:'Orbitron';font-size:16px;font-weight:700;}
.pyl-back-btn{pointer-events:auto;padding:8px 16px;border:1px solid var(--border);border-radius:8px;
  background:rgba(10,10,26,.9);color:var(--text);cursor:pointer;font-weight:600;font-size:12px;
  transition:all .2s;text-align:center;}
.pyl-back-btn:hover{border-color:var(--red);color:var(--red);}

/* PYL Leaderboard */
.pyl-leaderboard{width:100%;max-width:660px;}
.pyl-lb-title{font-family:'Orbitron';font-size:16px;font-weight:700;color:var(--gold);margin-bottom:10px;}
.pyl-lb-row{display:flex;align-items:center;gap:10px;padding:8px 12px;background:var(--surface);
  border:1px solid var(--border);border-radius:8px;margin-bottom:4px;font-size:13px;}
.pyl-lb-row .lb-rank{font-family:'Orbitron';font-weight:900;width:30px;text-align:center;color:var(--gold);}
.pyl-lb-row .lb-name{flex:1;font-weight:600;}
.pyl-lb-row .lb-score{font-family:'Orbitron';font-weight:700;color:var(--neon);}
.pyl-lb-row .lb-wager{font-size:11px;color:var(--gold);}

/* 1v1 Room */
.pyl-room{width:100%;max-width:500px;background:var(--surface);border:1px solid var(--border);
  border-radius:14px;padding:20px;text-align:center;}
.pyl-room .pr-title{font-family:'Orbitron';font-size:18px;font-weight:700;margin-bottom:12px;}
.pyl-room .pr-code{font-family:'Orbitron';font-size:28px;font-weight:900;color:var(--neon);
  letter-spacing:6px;margin:10px 0;padding:12px;background:rgba(0,240,255,.05);
  border:1px dashed var(--neon);border-radius:8px;}
.pyl-room .pr-status{color:var(--text2);font-size:13px;margin:8px 0;}
.pyl-room .pr-players{display:flex;gap:16px;justify-content:center;margin:12px 0;}
.pyl-room .pr-player{padding:8px 16px;border:1px solid var(--border);border-radius:8px;
  background:rgba(255,255,255,.03);font-weight:600;}
.pyl-room .pr-player.ready{border-color:var(--green);color:var(--green);}
.pyl-vs{font-family:'Orbitron';font-weight:900;font-size:20px;color:var(--red);}

/* ============ STOCKS ============ */
#stocksPanel{flex-direction:column;align-items:center;gap:0;overflow-y:auto;
  padding:70px 16px 20px!important;background:radial-gradient(ellipse at top,#0f1923 0%,#080c10 70%);}
#cryptoPanel{flex-direction:column;align-items:center;gap:0;overflow-y:auto;
  padding:70px 16px 20px!important;}
.stock-hero{text-align:center;margin-bottom:6px;}
.stock-hero .sh-ticker{font-family:'Orbitron';font-size:14px;font-weight:700;color:#58a6ff;
  letter-spacing:3px;text-transform:uppercase;}
.stock-hero .sh-price{font-family:'Orbitron';font-size:42px;font-weight:900;color:#e6edf3;
  text-shadow:0 0 30px rgba(88,166,255,.15);margin:4px 0;line-height:1;}
.stock-hero .sh-change{font-size:14px;font-weight:700;}
.stock-hero .sh-change.up{color:#3fb950;}
.stock-hero .sh-change.down{color:#f85149;}
.stock-chart-wrap{width:100%;max-width:600px;height:220px;position:relative;border-radius:12px;
  overflow:hidden;background:#0d1117;border:1px solid #1e2933;margin:8px 0;}
#stockChart{width:100%;height:100%;display:block;}
.stock-portfolio{display:flex;gap:20px;align-items:center;justify-content:center;
  width:100%;max-width:600px;padding:12px 0;}
.stock-portfolio .sp-stat{text-align:center;}
.stock-portfolio .sp-label{font-size:10px;color:#8b949e;text-transform:uppercase;letter-spacing:1px;margin-bottom:2px;}
.stock-portfolio .sp-val{font-family:'Orbitron';font-size:16px;font-weight:700;color:#e6edf3;}
.stock-actions-row{display:flex;gap:10px;align-items:center;justify-content:center;
  width:100%;max-width:600px;margin-top:4px;}
.stock-actions-row .sa-btn{flex:1;padding:14px 8px;border:none;border-radius:12px;cursor:pointer;
  font-weight:900;font-size:15px;font-family:'Orbitron';transition:all .2s;text-transform:uppercase;
  letter-spacing:1px;max-width:180px;}
.sa-buy{background:linear-gradient(180deg,#2ea043,#1a7f37);color:#fff;
  box-shadow:0 4px 20px rgba(46,160,67,.3);}
.sa-buy:hover{transform:translateY(-2px);box-shadow:0 6px 25px rgba(46,160,67,.5);}
.sa-sell{background:linear-gradient(180deg,#f85149,#da3633);color:#fff;
  box-shadow:0 4px 20px rgba(248,81,73,.3);}
.sa-sell:hover:not(:disabled){transform:translateY(-2px);box-shadow:0 6px 25px rgba(248,81,73,.5);}
.sa-sell:disabled{opacity:.25;cursor:not-allowed;transform:none!important;}
.stock-amt-row{display:flex;align-items:center;gap:8px;justify-content:center;margin-top:8px;}
.stock-live-dot{display:inline-block;width:8px;height:8px;border-radius:50%;background:#3fb950;
  animation:stockPulse 1.5s infinite;margin-right:6px;vertical-align:middle;}
@keyframes stockPulse{0%,100%{opacity:1;box-shadow:0 0 4px #3fb950}50%{opacity:.4;box-shadow:0 0 8px #3fb950}}

/* Particles */
#particles{position:fixed;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:999;}

/* Win Toast */
.win-toast{position:fixed;top:80px;left:50%;transform:translateX(-50%) translateY(-20px);
  background:linear-gradient(135deg,#1a3a1a,#0a2a0a);border:1px solid var(--green);
  border-radius:12px;padding:16px 32px;font-family:'Orbitron';font-size:20px;color:var(--green);
  box-shadow:0 0 30px rgba(0,255,136,.3);opacity:0;transition:all .4s;z-index:10000;pointer-events:none;white-space:nowrap;}
.win-toast.show{opacity:1;transform:translateX(-50%) translateY(0);}
.win-toast.loss{background:linear-gradient(135deg,#3a1a1a,#2a0a0a);border-color:var(--red);color:var(--red);
  box-shadow:0 0 30px rgba(255,51,85,.3);}

/* Phone-specific */
@media(max-width:600px){
  .catalog-card{width:90px;height:100px;font-size:14px;}
  .catalog-card .icon{font-size:32px;margin-bottom:4px;}
  #topNav .logo{font-size:13px;margin-right:3px;}
  .game-panel{padding:6px 4px;}
  .pyl-modes{grid-template-columns:1fr;}
  .win-toast{font-size:15px;padding:10px 20px;}
  .bet-controls{flex-wrap:wrap;gap:4px;padding:6px 4px;}
  .bet-input{width:70px;font-size:11px;padding:5px 6px;}
  .action-btn{padding:8px 14px;font-size:12px;}
  .htp-box{font-size:11px;padding:6px;}
  .case-card{width:70px;padding:6px 2px;}
  .case-card .case-icon{font-size:18px;}
  .case-card .case-name{font-size:8px;}
  .case-card .case-price{font-size:9px;}
  .case-opener{height:80px;}
  .case-item{width:80px;height:80px;font-size:9px;}
  .case-item .item-icon{font-size:24px;}
  .case-won{font-size:14px;}
  .crash-multiplier{font-size:36px!important;}
  .crash-container{max-height:35vh;}
  .slots-machine{padding:8px;}
  .reel-window{width:55px;height:150px;}
  .reel-symbol{width:55px;height:50px;font-size:26px;}
  .roulette-canvas{width:min(220px,60vw)!important;height:min(220px,60vw)!important;}
  .tower-cell{width:48px!important;height:40px!important;font-size:16px!important;}
  .mine-cell{width:42px!important;height:42px!important;font-size:16px!important;}
  .keno-num{width:34px!important;height:34px!important;font-size:10px!important;}
  .scratch-cell{width:56px!important;height:56px!important;font-size:22px!important;}
  .scratch-card{width:200px;padding:10px;}
  .hilo-card{width:100px!important;height:140px!important;font-size:28px!important;}
  .hilo-act-btn{padding:8px 12px!important;font-size:11px!important;}
  .lb-data-row{padding:8px 10px;}
  .lb-col-rank{width:30px;font-size:12px;}
  .lb-col-name{font-size:11px;}
  .lb-col-val{font-size:10px;min-width:70px;}
  .plinko-canvas-wrap{height:min(300px,40vh);}
  .horse-track{max-width:98vw;}
  #chatPanel{right:4px;left:4px;width:auto;bottom:60px;max-height:350px;}
  .user-avatar{width:32px;height:32px;font-size:16px;}
  .user-name{font-size:10px;}
  #balanceDisplay .bal{font-size:11px;}
  #profileAvatar{width:64px!important;height:64px!important;}
}

/* Scrollbar */
::-webkit-scrollbar{width:6px;}
::-webkit-scrollbar-track{background:var(--bg);}
::-webkit-scrollbar-thumb{background:var(--border);border-radius:3px;}

/* ============ LOGIN SCREEN ============ */
#loginScreen{position:fixed;top:0;left:0;right:0;bottom:0;z-index:99999;display:flex;align-items:center;justify-content:center;
  background:linear-gradient(135deg,#0a0a2e 0%,#1a0a3e 40%,#0a0a1a 100%);overflow:hidden;}
#loginScreen .login-bg-particles{position:absolute;top:0;left:0;right:0;bottom:0;overflow:hidden;pointer-events:none;}
#loginScreen .login-bg-particles div{position:absolute;width:3px;height:3px;background:var(--gold);
  border-radius:50%;animation:loginFloat linear infinite;opacity:.4;}
@keyframes loginFloat{0%{transform:translateY(100vh) scale(0)}50%{opacity:1}100%{transform:translateY(-100px) scale(1);opacity:0;}}
.login-box{position:relative;z-index:1;width:380px;padding:40px 36px;
  background:linear-gradient(180deg,rgba(20,20,60,.95),rgba(12,12,30,.98));
  border:1px solid var(--border);border-radius:20px;
  box-shadow:0 0 80px rgba(255,215,0,.08),0 0 200px rgba(0,240,255,.05);text-align:center;}
.login-logo{font-family:'Orbitron';font-weight:900;font-size:36px;
  background:linear-gradient(135deg,var(--gold),var(--neon));-webkit-background-clip:text;background-clip:text;-webkit-text-fill-color:transparent;
  margin-bottom:4px;letter-spacing:3px;}
.login-subtitle{font-size:13px;color:var(--text2);margin-bottom:28px;letter-spacing:1px;}
.login-input{width:100%;padding:14px 16px;border-radius:10px;border:1px solid var(--border);
  background:rgba(10,10,30,.8);color:var(--text);font-family:'Inter',sans-serif;font-size:15px;
  outline:none;transition:all .2s;margin-bottom:12px;}
.login-input:focus{border-color:var(--neon);box-shadow:0 0 15px rgba(0,240,255,.15);}
.login-input::placeholder{color:#555;}
.login-btn{width:100%;padding:14px;border:none;border-radius:10px;cursor:pointer;
  font-family:'Orbitron';font-weight:700;font-size:15px;letter-spacing:2px;
  transition:all .25s;margin-top:4px;}
.login-btn.primary{background:linear-gradient(135deg,#ffd700,#ff8c00);color:#0a0a1a;
  box-shadow:0 4px 20px rgba(255,215,0,.3);}
.login-btn.primary:hover{transform:translateY(-2px);box-shadow:0 6px 30px rgba(255,215,0,.5);}
.login-btn.secondary{background:transparent;border:1px solid var(--border);color:var(--text2);margin-top:8px;}
.login-btn.secondary:hover{border-color:var(--neon);color:var(--neon);}
.login-error{color:var(--red);font-size:12px;margin-top:8px;min-height:16px;}
.login-toggle{margin-top:16px;font-size:13px;color:var(--text2);}
.login-toggle a{color:var(--neon);cursor:pointer;text-decoration:none;font-weight:600;}
.login-toggle a:hover{text-decoration:underline;}

/* User display in nav */
.user-info{display:flex;align-items:center;gap:8px;margin-left:8px;}
.user-avatar {
  width: 40px;
  height: 40px;
  border-radius: 50%;
  background: linear-gradient(135deg,var(--neon),var(--neon2));
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: 900;
  font-size: 22px;
  color: #fff;
  border: 2px solid rgba(0,240,255,.3);
  text-transform: uppercase;
  box-shadow: 0 2px 8px rgba(0,240,255,.08);
  overflow: hidden;
}
#profileAvatar{width:96px;height:96px;border-radius:50%;display:flex;align-items:center;justify-content:center;background:linear-gradient(135deg,var(--neon),var(--neon2));color:#fff;font-size:40px;font-weight:900;border:3px solid rgba(0,240,255,.08);box-shadow:0 8px 40px rgba(0,0,0,.35);overflow:hidden;}
.user-avatar svg, #profileAvatar svg{width:100%;height:100%;display:block;border-radius:50% !important;clip-path:circle(50% at 50% 50%) !important;-webkit-clip-path:circle(50% at 50% 50%) !important;mask-image:radial-gradient(circle,#000 100%);-webkit-mask-image:radial-gradient(circle,#000 100%);} 
.user-avatar, #profileAvatar, .user-avatar * { border-radius:50% !important; overflow:hidden !important; box-sizing:border-box !important; clip-path:circle(50% at 50% 50%) !important; -webkit-clip-path:circle(50% at 50% 50%) !important; }
.user-avatar img, #profileAvatar img { width:100%; height:100%; object-fit:cover; display:block; border-radius:50% !important; clip-path:circle(50% at 50% 50%) !important; -webkit-clip-path:circle(50% at 50% 50%) !important; }
.user-name{font-family:'Orbitron';font-size:12px;color:var(--neon);font-weight:700;}
.logout-btn{width:36px;height:36px;padding:0;border:1px solid rgba(255,51,85,.18);border-radius:50%;
  background:transparent;color:var(--red);cursor:pointer;font-size:14px;font-weight:700;display:flex;align-items:center;justify-content:center;
  transition:all .18s;font-family:'Inter',sans-serif;}
.logout-btn:hover{background:rgba(255,51,85,.08);border-color:var(--red);transform:translateY(-1px);}

/* Global Leaderboard Tab */
#leaderboardPanel{flex-direction:column;align-items:center;gap:16px;overflow-y:auto;
  padding:80px 20px 20px;background:radial-gradient(ellipse at top,#1a1a40 0%,#0a0a1a 70%);}
.lb-container{width:100%;max-width:700px;}
.lb-tabs{display:flex;gap:3px;margin-bottom:16px;flex-wrap:wrap;justify-content:center;}
.lb-tab{padding:6px 10px;border:1px solid var(--border);border-radius:8px;background:transparent;
  color:var(--text2);cursor:pointer;font-weight:600;font-size:11px;transition:all .2s;
  font-family:'Inter',sans-serif;}
.lb-tab:hover{border-color:var(--neon);color:var(--text);}
.lb-tab.active{background:linear-gradient(135deg,#1a1a5e,#2a1a4e);color:var(--gold);
  border-color:rgba(255,215,0,.4);box-shadow:0 0 12px rgba(255,215,0,.1);}
.lb-table{width:100%;}
.lb-header-row{display:flex;padding:10px 16px;font-size:11px;font-weight:700;color:var(--text2);
  text-transform:uppercase;letter-spacing:1px;border-bottom:1px solid var(--border);}
.lb-data-row{display:flex;align-items:center;padding:12px 16px;background:var(--surface);
  border:1px solid var(--border);border-radius:10px;margin-bottom:4px;transition:all .2s;}
.lb-data-row:hover{border-color:var(--neon);background:rgba(0,240,255,.03);}
.lb-data-row.me{border-color:var(--gold);background:rgba(255,215,0,.05);}
.lb-col-rank{width:40px;font-family:'Orbitron';font-weight:900;font-size:14px;color:var(--gold);}
.lb-col-name{flex:1;font-weight:600;font-size:14px;}
.lb-col-val{min-width:90px;max-width:180px;text-align:right;font-family:'Orbitron';font-weight:700;font-size:12px;color:var(--neon);overflow:hidden;text-overflow:ellipsis;white-space:nowrap;}
.lb-col-extra{width:100px;text-align:right;font-size:12px;color:var(--text2);}
.lb-empty{text-align:center;padding:30px;color:var(--text2);font-size:13px;}

/* Daily bonus */
.daily-bonus-btn{padding:6px 12px;border:none;border-radius:6px;cursor:pointer;
  background:linear-gradient(135deg,#ffd700,#ff8c00);color:#0a0a1a;font-weight:800;font-size:12px;
  font-family:'Orbitron';animation:dailyPulse 2s infinite;transition:all .2s;}
.daily-bonus-btn:hover{transform:scale(1.05);}
.daily-bonus-btn:disabled{opacity:.4;animation:none;cursor:not-allowed;transform:none!important;
  background:var(--surface2);color:var(--text2);}
@keyframes dailyPulse{0%,100%{box-shadow:0 0 10px rgba(255,215,0,.3)}50%{box-shadow:0 0 25px rgba(255,215,0,.6)}}

/* ============ BLACKJACK ============ */
#blackjackPanel{flex-direction:column;align-items:center;justify-content:center;gap:14px;background:radial-gradient(ellipse at top,#0a2a0a 0%,#0a0a1a 70%);}
.bj-table{width:min(560px,90vw);min-height:260px;background:linear-gradient(180deg,#0d4a0d,#0a380a);border-radius:18px;border:3px solid #1a6a1a;padding:18px;box-shadow:inset 0 0 40px rgba(0,0,0,.5);}
.bj-area{min-height:85px;display:flex;flex-wrap:wrap;gap:5px;align-items:center;justify-content:center;padding:5px;}
.bj-label{font-family:'Orbitron';font-size:11px;color:rgba(255,255,255,.5);margin-bottom:2px;}
.bj-score{font-family:'Orbitron';font-size:15px;font-weight:700;display:inline;margin-left:6px;}
.bj-card{width:52px;height:74px;border-radius:7px;background:#fff;color:#111;display:inline-flex;flex-direction:column;align-items:center;justify-content:center;font-size:15px;font-weight:900;box-shadow:0 2px 8px rgba(0,0,0,.3);border:1px solid #ddd;}
.bj-card.red{color:#cc2233;}
.bj-card.hidden{background:linear-gradient(135deg,#1a1a8e,#2a1a6e);color:transparent;background-image:repeating-linear-gradient(45deg,transparent,transparent 5px,rgba(255,255,255,.05) 5px,rgba(255,255,255,.05) 10px);}
#bjResult{font-family:'Orbitron';font-size:15px;font-weight:700;min-height:22px;text-align:center;}

/* ============ MINES ============ */
#minesPanel{flex-direction:column;align-items:center;justify-content:center;gap:14px;background:radial-gradient(ellipse at center,#1a1a0a 0%,#0a0a1a 70%);}
.mines-wrap{display:flex;gap:14px;align-items:flex-start;}
.mines-grid{display:grid;grid-template-columns:repeat(5,1fr);gap:4px;}
.mine-cell{width:58px;height:58px;border-radius:8px;border:2px solid var(--border);background:var(--surface);cursor:pointer;display:flex;align-items:center;justify-content:center;font-size:24px;transition:all .15s;}
.mine-cell:hover:not(.revealed){background:var(--surface2);border-color:var(--neon);transform:scale(1.05);}
.mine-cell.revealed.safe{background:#0a2a0a;border-color:var(--green);}
.mine-cell.revealed.mine{background:#2a0a0a;border-color:var(--red);}
.mines-side{width:170px;display:flex;flex-direction:column;gap:8px;padding:12px;background:var(--surface);border-radius:10px;border:1px solid var(--border);}
.mines-side label{font-size:11px;color:var(--text2);font-weight:600;}
.mines-side select,.mines-side input{width:100%;padding:6px;border-radius:6px;border:1px solid var(--border);background:var(--bg);color:var(--text);font-size:12px;}
#minesMultiplier{font-family:'Orbitron';font-size:15px;font-weight:700;text-align:center;}
#minesProfit{font-size:11px;text-align:center;color:var(--text2);}

/* ============ DICE ============ */
#dicePanel{flex-direction:column;align-items:center;justify-content:center;gap:14px;background:radial-gradient(ellipse at top,#1a0a2a 0%,#0a0a1a 70%);}
.dice-roll-display{font-family:'Orbitron';font-size:60px;font-weight:900;min-height:74px;text-shadow:0 0 30px rgba(0,240,255,.4);}
.dice-slider-wrap{width:min(480px,85vw);}
.dice-slider{width:100%;-webkit-appearance:none;appearance:none;height:8px;border-radius:4px;outline:none;}
.dice-slider::-webkit-slider-thumb{-webkit-appearance:none;width:22px;height:22px;border-radius:50%;background:var(--gold);cursor:pointer;box-shadow:0 0 10px rgba(255,215,0,.5);}
.dice-info{display:flex;justify-content:space-between;width:min(480px,85vw);font-size:12px;color:var(--text2);}
.dice-info span{font-family:'Orbitron';font-weight:700;}
.dice-mode-btns{display:flex;gap:6px;}
.dice-mode-btn{padding:5px 12px;border:1px solid var(--border);border-radius:6px;background:var(--surface);color:var(--text2);cursor:pointer;font-weight:700;font-size:11px;transition:all .2s;}
.dice-mode-btn.active{border-color:var(--neon);color:var(--neon);background:rgba(0,240,255,.08);}

/* ============ TOWER ============ */
#towerPanel{flex-direction:column;align-items:center;justify-content:center;gap:10px;background:radial-gradient(ellipse at bottom,#1a1a2e 0%,#0a0a1a 70%);}
.tower-grid{display:flex;flex-direction:column-reverse;gap:3px;padding:8px;background:var(--surface);border-radius:10px;border:1px solid var(--border);}
.tower-row{display:flex;gap:3px;}
.tower-cell{width:66px;height:38px;border-radius:6px;border:2px solid var(--border);background:var(--surface2);cursor:pointer;display:flex;align-items:center;justify-content:center;font-size:16px;transition:all .15s;}
.tower-cell:hover:not(.revealed):not(.locked){border-color:var(--neon);}
.tower-cell.revealed.safe{background:#0a2a0a;border-color:var(--green);}
.tower-cell.revealed.trap{background:#2a0a0a;border-color:var(--red);}
.tower-cell.locked{opacity:.3;cursor:default;}
.tower-cell.current-row{border-color:var(--neon);opacity:1;}
#towerInfo{font-family:'Orbitron';font-size:13px;text-align:center;}

/* ============ COIN FLIP ============ */
#coinflipPanel{flex-direction:column;align-items:center;justify-content:center;gap:18px;background:radial-gradient(ellipse at center,#1a1a2e 0%,#0a0a1a 70%);}
.coin{width:120px;height:120px;border-radius:50%;font-size:52px;display:flex;align-items:center;justify-content:center;background:linear-gradient(135deg,#ffd700,#ff8c00);color:#333;box-shadow:0 0 40px rgba(255,215,0,.3);font-weight:900;}
.coin.flip{animation:coinSpin .8s ease-out;}@keyframes coinSpin{0%{transform:rotateY(0)}100%{transform:rotateY(1800deg)}}
.coin-choices{display:flex;gap:10px;}
.coin-choice{padding:10px 24px;border:2px solid var(--border);border-radius:10px;background:var(--surface);color:var(--text);cursor:pointer;font-size:15px;font-weight:700;transition:all .2s;}
.coin-choice:hover{border-color:var(--gold);}
.coin-choice.selected{border-color:var(--gold);background:rgba(255,215,0,.12);color:var(--gold);}
#coinResult{font-family:'Orbitron';font-size:16px;font-weight:700;min-height:24px;}

/* ============ KENO ============ */
#kenoPanel{flex-direction:column;align-items:center;justify-content:center;gap:10px;background:radial-gradient(ellipse at top,#0a1a2a 0%,#0a0a1a 70%);}
.keno-grid{display:grid;grid-template-columns:repeat(8,1fr);gap:3px;}
.keno-num{width:46px;height:38px;border-radius:5px;border:1px solid var(--border);background:var(--surface);cursor:pointer;display:flex;align-items:center;justify-content:center;font-size:12px;font-weight:700;transition:all .15s;}
.keno-num:hover:not(.drawn){background:var(--surface2);}
.keno-num.selected{background:rgba(0,240,255,.12);border-color:var(--neon);color:var(--neon);}
.keno-num.drawn{border-color:var(--gold);color:var(--gold);}
.keno-num.hit{background:#0a2a0a!important;border-color:var(--green)!important;color:var(--green)!important;}
.keno-num.miss{opacity:.35;}
#kenoInfo{font-size:11px;color:var(--text2);text-align:center;}
#kenoResult{font-family:'Orbitron';font-size:15px;font-weight:700;min-height:22px;text-align:center;}

/* ============ LIMBO ============ */
#limboPanel{flex-direction:column;align-items:center;justify-content:center;gap:18px;background:radial-gradient(ellipse at center,#0a0a2a 0%,#0a0a1a 70%);}
#limboResult{font-family:'Orbitron';font-size:60px;font-weight:900;min-height:74px;transition:color .3s;text-shadow:0 0 30px rgba(0,240,255,.3);}
.limbo-target-wrap{display:flex;align-items:center;gap:10px;}
.limbo-target-wrap label{font-size:12px;color:var(--text2);font-weight:600;}
#limboTarget{width:85px;padding:7px;border-radius:7px;border:1px solid var(--border);background:var(--bg);color:var(--neon);font-family:'Orbitron';font-size:15px;text-align:center;}
#limboPayout{font-size:12px;color:var(--text2);}

/* ============ VIDEO POKER ============ */
#pokerPanel{flex-direction:column;align-items:center;justify-content:center;gap:12px;background:radial-gradient(ellipse at top,#0a1a0a 0%,#0a0a1a 70%);}
.poker-hand{display:flex;gap:6px;justify-content:center;flex-wrap:wrap;}
.poker-card{width:72px;height:100px;border-radius:9px;background:#fff;color:#111;display:flex;flex-direction:column;align-items:center;justify-content:center;font-size:17px;font-weight:900;cursor:pointer;transition:all .2s;box-shadow:0 4px 12px rgba(0,0,0,.3);border:2px solid transparent;position:relative;}
.poker-card.red{color:#cc2233;}
.poker-card.held{border-color:var(--gold);transform:translateY(-10px);box-shadow:0 8px 20px rgba(255,215,0,.3);}
.poker-card .held-tag{position:absolute;top:-8px;font-size:8px;font-weight:700;color:var(--gold);font-family:'Orbitron';background:var(--bg);padding:1px 4px;border-radius:3px;border:1px solid var(--gold);}
.poker-paytable{display:grid;grid-template-columns:auto auto;gap:1px 10px;font-size:10px;background:var(--surface);padding:6px 10px;border-radius:7px;border:1px solid var(--border);}
.poker-paytable .pt-h{color:var(--text2);}
.poker-paytable .pt-v{color:var(--gold);font-family:'Orbitron';text-align:right;}
#pokerResult{font-family:'Orbitron';font-size:15px;font-weight:700;min-height:22px;text-align:center;}

/* ============ HORSE RACING ============ */
#horsesPanel{flex-direction:column;align-items:center;justify-content:center;gap:12px;background:radial-gradient(ellipse at bottom,#1a0a0a 0%,#0a0a1a 70%);}
.horse-track{width:min(620px,90vw);background:var(--surface);border-radius:10px;border:1px solid var(--border);padding:10px;}
.horse-lane{display:flex;align-items:center;gap:6px;padding:4px 0;border-bottom:1px solid rgba(255,255,255,.05);}
.horse-lane:last-child{border-bottom:none;}
.horse-name{width:65px;font-size:11px;font-weight:700;}
.horse-bar{flex:1;height:24px;background:var(--bg);border-radius:5px;position:relative;overflow:hidden;}
.horse-progress{height:100%;border-radius:5px;transition:width .3s;position:absolute;left:0;top:0;}
.horse-emoji{position:absolute;right:-2px;top:-3px;font-size:24px;}
.horse-odds{width:44px;text-align:right;font-family:'Orbitron';font-size:10px;color:var(--gold);}
.horse-bets{display:flex;gap:4px;flex-wrap:wrap;justify-content:center;}
.horse-bet{padding:6px 12px;border:1px solid var(--border);border-radius:6px;background:var(--surface);color:var(--text);cursor:pointer;font-weight:700;font-size:11px;transition:all .2s;}
.horse-bet:hover{border-color:var(--neon);}
.horse-bet.selected{border-color:var(--gold);background:rgba(255,215,0,.1);color:var(--gold);}
#horseResult{font-family:'Orbitron';font-size:14px;font-weight:700;min-height:22px;text-align:center;}

/* ============ SCRATCH CARDS ============ */
#scratchPanel{flex-direction:column;align-items:center;justify-content:center;gap:12px;background:radial-gradient(ellipse at center,#1a1a0a 0%,#0a0a1a 70%);}
.scratch-card{width:260px;padding:14px;background:linear-gradient(135deg,#2a2a5e,#1a1a3e);border-radius:12px;border:2px solid var(--gold);box-shadow:0 0 30px rgba(255,215,0,.1);}
.scratch-grid{display:grid;grid-template-columns:repeat(3,1fr);gap:5px;margin-bottom:8px;}
.scratch-cell{width:64px;height:64px;border-radius:8px;background:linear-gradient(135deg,#666,#999);cursor:pointer;display:flex;align-items:center;justify-content:center;font-size:24px;color:transparent;user-select:none;border:1px solid #aaa;transition:all .3s;}
.scratch-cell.revealed{background:var(--surface);border-color:var(--border);color:var(--text);}
#scratchResult{font-family:'Orbitron';font-size:13px;font-weight:700;text-align:center;min-height:20px;}
.scratch-tiers{display:flex;gap:5px;justify-content:center;flex-wrap:wrap;}
.scratch-tier{padding:4px 10px;border:1px solid var(--border);border-radius:6px;font-size:10px;background:var(--surface);cursor:pointer;transition:all .2s;}
.scratch-tier:hover{border-color:var(--gold);}
.scratch-tier.selected{border-color:var(--gold);background:rgba(255,215,0,.1);}

/* ============ WHEEL ============ */
#wheelPanel{flex-direction:column;align-items:center;justify-content:center;gap:12px;background:radial-gradient(ellipse at center,#1a0a2e 0%,#0a0a1a 70%);}
.wheel-wrap{position:relative;}
.wheel-ptr{position:absolute;top:-14px;left:50%;transform:translateX(-50%);width:0;height:0;border-left:11px solid transparent;border-right:11px solid transparent;border-top:20px solid var(--neon);filter:drop-shadow(0 0 6px rgba(0,240,255,.6));z-index:5;}
#wheelResult{font-family:'Orbitron';font-size:18px;font-weight:700;min-height:26px;}

/* ============ BACCARAT ============ */
#baccaratPanel{flex-direction:column;align-items:center;justify-content:center;gap:12px;background:radial-gradient(ellipse at top,#1a0a0a 0%,#0a0a1a 70%);}
.bacc-table{width:min(520px,90vw);background:linear-gradient(180deg,#1a0a0a,#150808);border-radius:16px;border:2px solid #4a2020;padding:18px;}
.bacc-hands{display:flex;justify-content:space-around;gap:16px;}
.bacc-hand{text-align:center;min-width:110px;}
.bacc-hand-label{font-family:'Orbitron';font-size:11px;color:var(--text2);margin-bottom:5px;}
.bacc-hand-score{font-family:'Orbitron';font-size:20px;font-weight:900;margin-top:5px;}
.bacc-cards{display:flex;gap:3px;justify-content:center;min-height:74px;align-items:center;}
.bacc-bets{display:flex;gap:6px;justify-content:center;}
.bacc-bet{padding:9px 18px;border:2px solid var(--border);border-radius:9px;background:var(--surface);color:var(--text);cursor:pointer;font-weight:700;font-size:12px;transition:all .2s;}
.bacc-bet:hover{border-color:var(--neon);}
.bacc-bet.selected{border-color:var(--gold);background:rgba(255,215,0,.1);color:var(--gold);}
#baccResult{font-family:'Orbitron';font-size:15px;font-weight:700;min-height:22px;text-align:center;}

/* ============ HILO ============ */
#hiloPanel{flex-direction:column;align-items:center;justify-content:center;gap:12px;background:radial-gradient(ellipse at center,#0a1a2a 0%,#0a0a1a 70%);}
.hilo-card{width:100px;height:140px;border-radius:12px;background:#fff;color:#111;display:flex;flex-direction:column;align-items:center;justify-content:center;font-size:26px;font-weight:900;box-shadow:0 8px 30px rgba(0,0,0,.4);border:2px solid #ddd;}
.hilo-card.red{color:#cc2233;}
.hilo-actions{display:flex;gap:8px;}
.hilo-act-btn{padding:10px 22px;border:none;border-radius:9px;cursor:pointer;font-weight:700;font-size:13px;font-family:'Orbitron';transition:all .2s;}
.hilo-act-btn.higher{background:linear-gradient(135deg,#00cc66,#009944);color:#fff;}
.hilo-act-btn.lower{background:linear-gradient(135deg,#cc3355,#991133);color:#fff;}
.hilo-act-btn.skip-btn{background:var(--surface2);color:var(--text);border:1px solid var(--border);}
#hiloStreak{font-family:'Orbitron';font-size:12px;color:var(--text2);}
#hiloCashout{font-family:'Orbitron';font-size:14px;color:var(--gold);}
.last-results{display:flex;gap:4px;flex-wrap:wrap;justify-content:center;max-width:320px;min-height:18px;}
.result-dot{display:inline-block;padding:2px 6px;border-radius:4px;font-size:10px;font-family:'Orbitron';font-weight:700;color:#fff;animation:dotIn .2s ease;}
@keyframes dotIn{from{opacity:0;transform:scale(.5);}to{opacity:1;transform:scale(1);}}

/* ============ GLOBAL CHAT ============ */
#chatToggleBtn{position:fixed;bottom:16px;right:16px;z-index:1100;width:48px;height:48px;border-radius:50%;
  border:2px solid var(--neon);background:linear-gradient(135deg,#15153a,#0d0d25);color:var(--neon);
  font-size:22px;cursor:pointer;box-shadow:0 4px 20px rgba(0,240,255,.25);transition:all .2s;display:flex;align-items:center;justify-content:center;}
#chatToggleBtn:hover{transform:scale(1.1);box-shadow:0 6px 30px rgba(0,240,255,.4);}
#chatToggleBtn .chat-badge{position:absolute;top:-4px;right:-4px;background:var(--red);color:#fff;font-size:10px;
  font-weight:900;width:18px;height:18px;border-radius:50%;display:none;align-items:center;justify-content:center;font-family:'Inter';}
#chatPanel{position:fixed;bottom:76px;right:16px;width:340px;max-height:460px;z-index:1100;
  background:linear-gradient(180deg,#15153a,#0d0d25);border:1px solid var(--border);border-radius:14px;
  display:none;flex-direction:column;overflow:hidden;box-shadow:0 8px 40px rgba(0,0,0,.7);
  animation:chatSlideIn .2s ease;}
#chatPanel.open{display:flex;}
@keyframes chatSlideIn{from{opacity:0;transform:translateY(20px);}to{opacity:1;transform:translateY(0);}}
.chat-header{display:flex;align-items:center;justify-content:space-between;padding:12px 14px;
  border-bottom:1px solid var(--border);background:rgba(0,0,0,.2);}
.chat-header-title{font-family:'Orbitron';font-size:13px;font-weight:700;color:var(--neon);display:flex;align-items:center;gap:6px;}
.chat-header-title .online-dot{width:8px;height:8px;border-radius:50%;background:var(--green);animation:onlinePulse 2s infinite;}
@keyframes onlinePulse{0%,100%{opacity:1;}50%{opacity:.4;}}
.chat-close{background:none;border:none;color:var(--text2);font-size:16px;cursor:pointer;padding:4px;}
.chat-close:hover{color:var(--red);}
.chat-messages{flex:1;overflow-y:auto;padding:10px 14px;display:flex;flex-direction:column;gap:6px;min-height:200px;max-height:320px;
  scrollbar-width:thin;scrollbar-color:var(--border) transparent;}
.chat-messages::-webkit-scrollbar{width:5px;}
.chat-messages::-webkit-scrollbar-thumb{background:var(--border);border-radius:4px;}
.chat-msg{display:flex;gap:8px;padding:6px 0;animation:chatMsgIn .15s ease;}
@keyframes chatMsgIn{from{opacity:0;transform:translateY(6px);}to{opacity:1;transform:translateY(0);}}
.chat-msg-avatar{width:28px;height:28px;border-radius:50%;background:linear-gradient(135deg,var(--neon),var(--neon2));
  display:flex;align-items:center;justify-content:center;font-size:12px;font-weight:900;color:#fff;flex-shrink:0;}
.chat-msg-body{flex:1;min-width:0;}
.chat-msg-name{font-size:11px;font-weight:700;color:var(--neon);margin-bottom:2px;}
.chat-msg-name.guest-name{color:var(--text2);}
.role-badge-owner{display:inline-block;font-size:8px;padding:1px 5px;border-radius:6px;margin-left:4px;background:linear-gradient(135deg,#ff3300,#ff6600);color:#fff;font-weight:900;letter-spacing:.5px;vertical-align:middle;}
.role-badge-coowner{display:inline-block;font-size:8px;padding:1px 5px;border-radius:6px;margin-left:4px;background:linear-gradient(135deg,#9b59b6,#8e44ad);color:#fff;font-weight:900;letter-spacing:.5px;vertical-align:middle;}
.chat-msg-text{font-size:12px;color:var(--text);line-height:1.4;word-break:break-word;}
.chat-msg-time{font-size:9px;color:var(--text2);margin-top:2px;}
.chat-msg-system{text-align:center;color:var(--text2);font-size:11px;font-style:italic;padding:4px 0;}
.chat-msg-win{background:linear-gradient(90deg,rgba(0,255,136,.06),transparent);border-left:3px solid var(--green);
  padding:6px 10px;border-radius:0 8px 8px 0;margin:2px 0;}
.chat-msg-win .win-text{color:var(--green);font-weight:700;font-size:11px;}
.chat-input-wrap{display:flex;gap:6px;padding:10px 14px;border-top:1px solid var(--border);background:rgba(0,0,0,.15);}
.chat-input{flex:1;padding:8px 12px;background:var(--bg);border:1px solid var(--border);border-radius:8px;
  color:var(--text);font-size:13px;outline:none;font-family:'Inter',sans-serif;}
.chat-input:focus{border-color:var(--neon);}
.chat-input::placeholder{color:var(--text2);}
.chat-send-btn{padding:8px 14px;background:linear-gradient(135deg,var(--neon),#0088cc);border:none;border-radius:8px;
  color:#fff;font-weight:700;font-size:12px;cursor:pointer;transition:all .15s;font-family:'Inter';}
.chat-send-btn:hover{transform:translateY(-1px);box-shadow:0 4px 12px rgba(0,240,255,.3);}
.chat-send-btn:disabled{opacity:.4;cursor:not-allowed;transform:none!important;}
.chat-online-count{font-size:10px;color:var(--text2);font-weight:400;}
@media(max-width:500px){#chatPanel{right:8px;left:8px;width:auto;bottom:70px;max-height:380px;}}

/* Big Win Animations */
@keyframes screenShake{
  0%,100%{transform:translate(0,0)}
  10%{transform:translate(-4px,-2px)}
  20%{transform:translate(4px,2px)}
  30%{transform:translate(-3px,3px)}
  40%{transform:translate(3px,-3px)}
  50%{transform:translate(-2px,2px)}
  60%{transform:translate(2px,-1px)}
  70%{transform:translate(-1px,1px)}
  80%{transform:translate(1px,-1px)}
  90%{transform:translate(0,1px)}
}
@keyframes bigWinBounce{
  0%{transform:scale(0) translateY(30px);opacity:0;}
  60%{transform:scale(1.15) translateY(-5px);opacity:1;}
  100%{transform:scale(1) translateY(0);opacity:1;}
}
@keyframes fadeInOut{
  0%{opacity:0;}10%{opacity:1;}75%{opacity:1;}100%{opacity:0;}
}

/* ===== PRESTIGE BADGES ===== */
.prestige-badge{display:inline-block;font-size:9px;padding:1px 5px;border-radius:4px;font-weight:700;letter-spacing:1px;margin-left:4px;vertical-align:middle;font-family:'Orbitron',sans-serif;}
.prestige-1{background:linear-gradient(135deg,#cd7f32,#8b4513);color:#fff;text-shadow:0 1px 2px rgba(0,0,0,.5);}
.prestige-2{background:linear-gradient(135deg,#c0c0c0,#808080);color:#fff;text-shadow:0 1px 2px rgba(0,0,0,.5);}
.prestige-3{background:linear-gradient(135deg,#ffd700,#ff8c00);color:#1a1a2e;text-shadow:0 1px 2px rgba(255,255,255,.3);}
.prestige-4{background:linear-gradient(135deg,#00f0ff,#0066ff);color:#fff;text-shadow:0 0 6px rgba(0,240,255,.5);}
.prestige-5{background:linear-gradient(135deg,#ff00ff,#6b2fd9);color:#fff;text-shadow:0 0 8px rgba(255,0,255,.5);animation:prestigeGlow 2s ease-in-out infinite;}
@keyframes prestigeGlow{0%,100%{box-shadow:0 0 4px rgba(255,0,255,.4);}50%{box-shadow:0 0 12px rgba(255,0,255,.8);}}
.prestige-btn{background:linear-gradient(135deg,var(--gold),#ff8800);color:#1a1a2e;border:none;border-radius:8px;padding:10px 20px;font-family:'Orbitron',sans-serif;font-weight:900;font-size:13px;cursor:pointer;letter-spacing:2px;transition:all .2s;display:flex;align-items:center;gap:8px;margin:12px auto;}
.prestige-btn:hover{transform:scale(1.05);box-shadow:0 0 20px rgba(255,215,0,.5);}
.prestige-btn:disabled{opacity:.4;cursor:not-allowed;transform:none;}
.prestige-confirm-overlay{position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,.85);z-index:10002;display:flex;align-items:center;justify-content:center;}
.prestige-confirm-box{background:var(--surface);border:2px solid var(--gold);border-radius:16px;padding:24px;max-width:400px;width:90vw;text-align:center;}

/* ===== DUELS ===== */
#duelsPanel .duel-lobby{max-width:600px;margin:0 auto;padding:16px;}
.duel-card{background:var(--surface);border:1px solid var(--border);border-radius:12px;padding:16px;margin-bottom:10px;display:flex;align-items:center;justify-content:space-between;transition:all .2s;}
.duel-card:hover{border-color:var(--gold);box-shadow:0 0 10px rgba(255,215,0,.15);}
.duel-card .duel-host{font-family:'Orbitron',sans-serif;font-size:13px;color:var(--text);}
.duel-card .duel-wager{font-family:'Orbitron',sans-serif;font-size:16px;color:var(--gold);font-weight:900;}
.duel-card .duel-join{background:linear-gradient(135deg,var(--green),#00cc88);color:#fff;border:none;border-radius:8px;padding:8px 16px;font-family:'Orbitron',sans-serif;font-size:11px;cursor:pointer;font-weight:700;letter-spacing:1px;transition:all .2s;}
.duel-card .duel-join:hover{transform:scale(1.05);box-shadow:0 0 12px rgba(0,230,118,.4);}
.duel-create-box{background:var(--surface);border:2px solid var(--gold);border-radius:12px;padding:20px;margin-bottom:16px;text-align:center;}
.duel-create-box input{width:140px;text-align:center;background:var(--bg);border:1px solid var(--border);border-radius:8px;padding:8px;color:var(--text);font-family:'Orbitron',sans-serif;font-size:14px;}
.duel-create-btn{background:linear-gradient(135deg,var(--gold),#ff8800);color:#1a1a2e;border:none;border-radius:8px;padding:10px 24px;font-family:'Orbitron',sans-serif;font-size:13px;cursor:pointer;font-weight:900;letter-spacing:2px;margin-top:10px;transition:all .2s;}
.duel-create-btn:hover{transform:scale(1.05);box-shadow:0 0 16px rgba(255,215,0,.5);}
.duel-vs{font-family:'Orbitron',sans-serif;font-size:36px;color:var(--gold);text-shadow:0 0 20px rgba(255,215,0,.5);margin:12px 0;letter-spacing:6px;}
.duel-player{text-align:center;flex:1;}
.duel-player-name{font-family:'Orbitron',sans-serif;font-size:16px;color:var(--text);margin-bottom:4px;transition:all .5s;}
.duel-player-bet{font-family:'Orbitron',sans-serif;font-size:12px;color:var(--gold);}
.duel-result{font-family:'Orbitron',sans-serif;font-size:28px;font-weight:900;letter-spacing:3px;margin:12px 0;}
.duel-coin-wrapper{perspective:600px;display:inline-block;}
.duel-coin{width:120px;height:120px;border-radius:50%;position:relative;transform-style:preserve-3d;display:flex;align-items:center;justify-content:center;font-size:48px;font-weight:900;font-family:'Orbitron',sans-serif;}
.duel-coin .coin-face{position:absolute;width:100%;height:100%;border-radius:50%;display:flex;align-items:center;justify-content:center;backface-visibility:hidden;}
.duel-coin .coin-heads{background:linear-gradient(135deg,#ffd700,#ffaa00,#ffd700);color:#1a1a2e;border:4px solid #cc8800;box-shadow:0 0 30px rgba(255,215,0,.5),inset 0 0 20px rgba(255,255,255,.3);}
.duel-coin .coin-tails{background:linear-gradient(135deg,#2a2a3e,#1a1a2e,#2a2a3e);color:#8888aa;border:4px solid #444;box-shadow:0 0 30px rgba(100,100,200,.3),inset 0 0 20px rgba(0,0,0,.5);transform:rotateY(180deg);}
@keyframes duelCoinSpin{0%{transform:rotateY(0deg);}100%{transform:rotateY(360deg);}}
@keyframes duelCoinSlowDown{0%{transform:rotateY(0deg);}100%{transform:rotateY(1800deg);}}
@keyframes duelCoinRevealHeads{0%{transform:rotateY(0deg);}100%{transform:rotateY(0deg);}}
@keyframes duelCoinRevealTails{0%{transform:rotateY(0deg);}100%{transform:rotateY(180deg);}}
.duel-countdown{font-family:'Orbitron',sans-serif;font-size:72px;font-weight:900;color:var(--gold);text-shadow:0 0 40px rgba(255,215,0,.8),0 0 80px rgba(255,215,0,.4);animation:duelCountPulse .5s ease-out;}
@keyframes duelCountPulse{0%{transform:scale(2);opacity:0;}50%{transform:scale(1.1);opacity:1;}100%{transform:scale(1);opacity:1;}}
.duel-flash{position:fixed;inset:0;z-index:10004;pointer-events:none;opacity:0;}
@keyframes duelFlashBang{0%{opacity:.8;}100%{opacity:0;}}
@keyframes duelShake{0%,100%{transform:translate(0,0);}10%{transform:translate(-8px,4px);}20%{transform:translate(8px,-4px);}30%{transform:translate(-6px,6px);}40%{transform:translate(6px,-6px);}50%{transform:translate(-4px,2px);}60%{transform:translate(4px,-2px);}70%{transform:translate(-2px,4px);}80%{transform:translate(2px,-4px);}90%{transform:translate(-1px,1px);}}
.duel-overlay-shake{animation:duelShake .5s ease-out;}
.duel-win-glow{animation:duelWinGlow 1.5s ease-in-out infinite;}
@keyframes duelWinGlow{0%,100%{text-shadow:0 0 10px currentColor,0 0 20px currentColor;}50%{text-shadow:0 0 30px currentColor,0 0 60px currentColor,0 0 90px currentColor;}}
.duel-result-reveal{animation:duelResultSlam .6s cubic-bezier(.17,.67,.29,1.5);}
@keyframes duelResultSlam{0%{transform:scale(3) rotateZ(-10deg);opacity:0;}60%{transform:scale(1.1) rotateZ(2deg);opacity:1;}100%{transform:scale(1) rotateZ(0deg);opacity:1;}}
.duel-tension-bar{width:80%;max-width:300px;height:6px;background:var(--surface2);border-radius:3px;margin:12px auto;overflow:hidden;}
.duel-tension-fill{height:100%;border-radius:3px;background:linear-gradient(90deg,var(--gold),#ff4444);transition:width .1s linear;}
.duel-history{margin-top:16px;}
.duel-history-item{display:flex;align-items:center;justify-content:space-between;padding:8px 12px;background:var(--surface);border:1px solid var(--border);border-radius:8px;margin-bottom:4px;font-size:11px;}

/* ============ BUCKSHOT ROULETTE ============ */
#rusroulettePanel{padding-top:60px!important;}
.bsr-title{font-family:'Orbitron';font-size:28px;font-weight:900;text-align:center;
  background:linear-gradient(135deg,#ff4444,#ff8800,#ffd700);-webkit-background-clip:text;-webkit-text-fill-color:transparent;
  margin-bottom:4px;letter-spacing:2px;}
.bsr-subtitle{font-size:12px;color:var(--text2);text-align:center;margin-bottom:18px;}

/* Lobby */
.bsr-lobby{max-width:480px;width:100%;margin:0 auto;text-align:center;}
.bsr-lobby .bsr-difficulty{display:grid;grid-template-columns:1fr 1fr 1fr;gap:10px;margin:16px 0;}
.bsr-diff-card{background:var(--surface);border:2px solid var(--border);border-radius:14px;padding:16px 10px;cursor:pointer;transition:all .25s;}
.bsr-diff-card:hover,.bsr-diff-card.selected{border-color:var(--neon);background:rgba(0,240,255,.06);transform:translateY(-2px);}
.bsr-diff-card .diff-icon{font-size:28px;margin-bottom:6px;}
.bsr-diff-card .diff-name{font-family:'Orbitron';font-size:13px;font-weight:700;color:var(--text);margin-bottom:4px;}
.bsr-diff-card .diff-desc{font-size:10px;color:var(--text2);line-height:1.4;}
.bsr-diff-card .diff-mult{font-family:'Orbitron';font-size:14px;font-weight:900;color:var(--gold);margin-top:6px;}

/* Game area */
.bsr-game{max-width:560px;width:100%;margin:0 auto;}
.bsr-top-bar{display:flex;justify-content:space-between;align-items:center;margin-bottom:12px;
  padding:10px 14px;background:var(--surface);border:1px solid var(--border);border-radius:12px;}
.bsr-round-badge{font-family:'Orbitron';font-size:14px;color:var(--neon);font-weight:800;letter-spacing:2px;}
.bsr-multiplier{font-family:'Orbitron';font-size:16px;color:var(--gold);font-weight:900;}
.bsr-shell-count{font-size:12px;color:var(--text2);}

/* Table area - the centerpiece */
.bsr-table{position:relative;background:linear-gradient(180deg,rgba(40,20,10,.5),rgba(20,10,5,.7));
  border:2px solid rgba(255,140,50,.2);border-radius:20px;padding:24px 16px;margin-bottom:14px;
  box-shadow:inset 0 0 60px rgba(0,0,0,.3),0 0 30px rgba(255,100,0,.08);}
.bsr-shotgun{display:flex;justify-content:center;align-items:center;margin:16px 0;min-height:60px;}
.bsr-shotgun-img{font-size:56px;transition:transform .3s;filter:drop-shadow(0 4px 12px rgba(255,100,0,.4));}
.bsr-shotgun-img.shake{animation:bsrShake .4s ease-in-out;}
.bsr-shotgun-img.recoil-left{animation:bsrRecoilLeft .5s ease-out;}
.bsr-shotgun-img.recoil-right{animation:bsrRecoilRight .5s ease-out;}
@keyframes bsrShake{0%,100%{transform:rotate(0)}25%{transform:rotate(-3deg) translateX(-4px)}50%{transform:rotate(2deg) translateX(3px)}75%{transform:rotate(-1deg)}}
@keyframes bsrRecoilLeft{0%{transform:rotate(0) translateX(0)}30%{transform:rotate(-15deg) translateX(-20px) scale(1.1)}100%{transform:rotate(0) translateX(0)}}
@keyframes bsrRecoilRight{0%{transform:rotate(0) translateX(0)}30%{transform:rotate(15deg) translateX(20px) scale(1.1)}100%{transform:rotate(0) translateX(0)}}

/* Shell rack */
.bsr-rack{display:flex;gap:8px;justify-content:center;flex-wrap:wrap;margin-bottom:14px;}
.bsr-shell{width:32px;height:44px;border-radius:6px;display:flex;align-items:center;justify-content:center;
  font-size:12px;font-weight:700;transition:all .3s;position:relative;}
.bsr-shell.used{background:var(--surface2);opacity:0.25;}
.bsr-shell.used.was-live{border:1px solid rgba(255,68,68,.3);}
.bsr-shell.used.was-blank{border:1px solid rgba(68,136,255,.3);}
.bsr-shell.current{background:linear-gradient(135deg,var(--gold),#ff8800);box-shadow:0 0 14px rgba(255,200,0,.5);
  animation:bsrPulse 1.5s ease-in-out infinite;font-size:16px;}
.bsr-shell.unknown{background:var(--surface2);border:1px solid var(--border);}
.bsr-shell.reveal-live{background:linear-gradient(135deg,#ff4444,#cc0000);border-color:#ff4444;
  animation:bsrReveal .4s ease-out;}
.bsr-shell.reveal-blank{background:linear-gradient(135deg,#4488ff,#2255cc);border-color:#4488ff;
  animation:bsrReveal .4s ease-out;}
@keyframes bsrPulse{0%,100%{box-shadow:0 0 14px rgba(255,200,0,.5)}50%{box-shadow:0 0 24px rgba(255,200,0,.8)}}
@keyframes bsrReveal{0%{transform:scale(0.5);opacity:0}100%{transform:scale(1);opacity:1}}

/* Health panels */
.bsr-combatants{display:grid;grid-template-columns:1fr auto 1fr;gap:0;margin-bottom:16px;}
.bsr-fighter{background:var(--surface);border:1px solid var(--border);border-radius:14px;padding:16px;text-align:center;transition:all .3s;}
.bsr-fighter.hit{animation:bsrHit .4s ease-out;border-color:var(--red);}
@keyframes bsrHit{0%{background:rgba(255,68,68,.3)}100%{background:var(--surface)}}
.bsr-fighter-label{font-family:'Orbitron';font-size:11px;font-weight:700;letter-spacing:2px;margin-bottom:8px;}
.bsr-hp-text{font-family:'Orbitron';font-size:26px;font-weight:900;margin-bottom:6px;}
.bsr-hp-bar{height:8px;background:var(--surface2);border-radius:4px;overflow:hidden;margin-bottom:6px;}
.bsr-hp-fill{height:100%;border-radius:4px;transition:width .5s ease-out;}
.bsr-hearts{font-size:14px;letter-spacing:2px;}
.bsr-vs{display:flex;align-items:center;justify-content:center;padding:0 10px;
  font-family:'Orbitron';font-size:16px;color:var(--red);font-weight:900;}

/* Items */
.bsr-items-section{margin-bottom:14px;}
.bsr-items-label{font-family:'Orbitron';font-size:10px;color:var(--text2);letter-spacing:2px;margin-bottom:8px;text-align:center;}
.bsr-items{display:flex;gap:8px;justify-content:center;flex-wrap:wrap;}
.bsr-item-btn{padding:8px 12px;border-radius:10px;background:var(--surface);border:1px solid var(--border);
  cursor:pointer;color:var(--text);font-size:12px;transition:all .2s;display:flex;align-items:center;gap:8px;text-align:left;}
.bsr-item-btn:hover:not(:disabled){border-color:var(--neon);background:rgba(0,240,255,.06);transform:translateY(-2px);box-shadow:0 4px 12px rgba(0,240,255,.1);}
.bsr-item-btn:active:not(:disabled){transform:translateY(0);}
.bsr-item-btn:disabled,.bsr-item-btn.disabled{opacity:0.35;cursor:default;pointer-events:none;border-color:var(--border)!important;}
.bsr-item-btn .item-icon{font-size:20px;flex-shrink:0;}
.bsr-item-btn .item-info{display:flex;flex-direction:column;gap:1px;}
.bsr-item-btn .item-name{font-size:12px;font-weight:700;color:var(--text);line-height:1.2;}
.bsr-item-btn .item-desc{font-size:10px;color:var(--text2);line-height:1.3;}
.bsr-dealer-items{display:flex;gap:6px;justify-content:center;flex-wrap:wrap;margin-top:8px;}
.bsr-dealer-item{padding:4px 8px;border-radius:6px;background:rgba(255,68,68,.08);border:1px solid rgba(255,68,68,.15);
  font-size:11px;color:var(--text2);}

/* Status */
.bsr-status{text-align:center;font-size:15px;color:var(--gold);min-height:28px;margin-bottom:12px;
  font-weight:700;font-family:'Orbitron';letter-spacing:1px;}

/* Action buttons */
.bsr-actions{display:flex;gap:12px;justify-content:center;margin-bottom:14px;}
.bsr-shoot-btn{padding:14px 32px;font-size:15px;font-weight:800;border-radius:12px;border:2px solid;
  cursor:pointer;transition:all .25s;font-family:'Orbitron';letter-spacing:1px;}
.bsr-shoot-btn:disabled{opacity:0.3;cursor:default;transform:none!important;}
.bsr-shoot-dealer{background:linear-gradient(135deg,rgba(255,68,68,.15),rgba(255,68,68,.05));
  border-color:rgba(255,68,68,.5);color:#ff4444;}
.bsr-shoot-dealer:hover:not(:disabled){background:linear-gradient(135deg,rgba(255,68,68,.3),rgba(255,68,68,.1));transform:translateY(-2px);}
.bsr-shoot-self{background:linear-gradient(135deg,rgba(0,240,255,.1),rgba(0,240,255,.03));
  border-color:rgba(0,240,255,.4);color:#00f0ff;}
.bsr-shoot-self:hover:not(:disabled){background:linear-gradient(135deg,rgba(0,240,255,.2),rgba(0,240,255,.06));transform:translateY(-2px);}

/* Log */
.bsr-log{background:var(--surface);border:1px solid var(--border);border-radius:12px;padding:12px;
  max-height:150px;overflow-y:auto;font-size:12px;color:var(--text2);line-height:1.6;}
.bsr-log-entry{padding:3px 0;border-bottom:1px solid rgba(255,255,255,.04);}
.bsr-log-entry:last-child{border-bottom:none;}
.bsr-log-line{padding:3px 0;border-bottom:1px solid rgba(255,255,255,.04);}
.bsr-log-line:last-child{border-bottom:none;}

/* Game over */
.bsr-gameover{display:none;position:fixed;inset:0;background:rgba(4,8,20,.97);z-index:10003;
  align-items:center;justify-content:center;flex-direction:column;}
.bsr-gameover-box{text-align:center;max-width:480px;width:92vw;animation:bsrFadeIn .5s ease-out;}
@keyframes bsrFadeIn{0%{opacity:0;transform:translateY(30px)}100%{opacity:1;transform:translateY(0)}}

/* Round transition */
.bsr-round-splash{position:fixed;inset:0;background:rgba(4,8,20,.95);z-index:10004;
  display:flex;align-items:center;justify-content:center;transition:opacity .4s ease;}
.bsr-round-splash-text{font-family:'Orbitron';font-size:36px;font-weight:900;color:var(--gold);
  text-shadow:0 0 30px rgba(255,215,0,.5);animation:bsrPulse 1s ease-in-out infinite;}

</style>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
</head>
<body>
<noscript><div style="position:fixed;inset:0;background:#0a0a1a;color:#e8e8ff;display:flex;align-items:center;justify-content:center;font-family:sans-serif;font-size:18px;z-index:99999;text-align:center;padding:20px;">JavaScript is required to play Casino Royale. Please enable JavaScript in your browser settings.</div></noscript>
<script>window.addEventListener('error',function(e){console.warn('Global error:',e.message);});window.addEventListener('unhandledrejection',function(e){console.warn('Unhandled promise:',e.reason);});</script>

<!-- DATABASE RESET ANNOUNCEMENT -->
<div id="resetAnnouncement" style="position:fixed;inset:0;background:rgba(4,8,20,.98);z-index:99998;display:flex;align-items:center;justify-content:center;backdrop-filter:blur(2px);">
  <div style="max-width:500px;background:linear-gradient(135deg,rgba(255,107,107,.15),rgba(255,50,50,.08));border:2px solid rgba(255,107,107,.4);border-radius:16px;padding:40px;text-align:center;box-shadow:0 0 40px rgba(255,50,50,.15);">
    <div style="font-size:48px;margin-bottom:20px;">⚠️</div>
    <div style="font-family:'Orbitron';font-size:28px;color:#ff6b6b;margin-bottom:16px;font-weight:900;letter-spacing:2px;">DATABASE RESET</div>
    <div style="font-size:16px;color:#e8e8ff;margin-bottom:24px;line-height:1.6;">
      <p>All player accounts have been cleared due to a database migration.</p>
      <p style="margin-top:16px;"><strong>Your balance has been reset to $1,000</strong></p>
      <p style="margin-top:12px;font-size:13px;color:#b8b8d8;">This is a fresh start for everyone. All data from the previous database has been archived.</p>
    </div>
    <button onclick="document.getElementById('resetAnnouncement').style.display='none';" style="padding:14px 32px;background:linear-gradient(135deg,#ff6b6b,#ff1744);border:none;border-radius:10px;color:#fff;font-family:'Orbitron';font-size:14px;font-weight:700;cursor:pointer;letter-spacing:1px;box-shadow:0 4px 16px rgba(255,50,50,.3);">ACKNOWLEDGE & CONTINUE</button>
  </div>
</div>

<!-- LOGIN SCREEN -->
<div id="loginScreen">
  <div class="login-bg-particles" id="loginParticles"></div>
  <div class="login-box">
    <div class="login-logo">CASINO</div>
    <div class="login-subtitle">ROYALE</div>
    <div id="loginForm">
      <form onsubmit="event.preventDefault();authSubmit();" autocomplete="on">
      <input class="login-input" type="text" id="authUsername" placeholder="Username" autocomplete="username" maxlength="20">
      <input class="login-input" type="password" id="authPassword" placeholder="Password" autocomplete="current-password">
      <button type="submit" class="login-btn primary" id="authSubmitBtn">SIGN IN</button>
      </form>
      <button class="login-btn secondary" id="authToggleBtn" onclick="authToggleMode()">CREATE ACCOUNT</button>
      <button class="login-btn secondary" style="margin-top:4px;border-color:rgba(255,255,255,0.15);color:rgba(255,255,255,0.4);font-family:'Inter',sans-serif;font-size:13px;letter-spacing:0;" onclick="authGuestMode()">Sign in later</button>
      <div class="login-error" id="authError"></div>
      <div class="login-toggle" id="authToggleText">Don't have an account? <a onclick="authToggleMode()">Sign up</a></div>
    </div>
  </div>
</div>

<!-- Top Navigation -->
<nav id="topNav" style="display:none;">
  <div class="logo" title="Home" style="cursor:pointer;">🏠 HOME</div>

  <!-- Games Menu Button -->
  <button class="nav-btn-inline" onclick="openGamesMenu()" style="margin-left:3px;"><span class="icon">🎮</span><span class="nav-label">Games</span></button>

  <!-- Essential Navigation Buttons -->
  <button class="nav-btn-inline" onclick="switchGame('leaderboard',this)"><span class="icon">🏆</span><span class="nav-label">Board</span></button>
  <button class="nav-btn-inline" onclick="switchGame('profile',this)"><span class="icon">👤</span><span class="nav-label">Profile</span></button>
  <button class="nav-btn-inline" onclick="showInventory()"><span class="icon">🎒</span><span class="nav-label">Inv</span></button>
  <button class="nav-btn-inline" onclick="openStoreOverlay()" style="border-color:rgba(255,215,0,.4);"><span class="icon">🏪</span><span class="nav-label">Store</span></button>
  <button class="nav-btn-inline" onclick="openShopOverlay()" style="border-color:rgba(0,200,255,.4);"><span class="icon">🛒</span><span class="nav-label">Shop</span></button>
  <button class="nav-btn-inline" onclick="openTradeOverlay()" style="border-color:rgba(0,230,118,.4);"><span class="icon">🔄</span><span class="nav-label">Trade</span></button>
  <button class="nav-btn-inline" onclick="showFriendsPanel()" style="position:relative;"><span class="icon">👥</span><span class="nav-label">Friends</span><span id="friendReqBadge" style="position:absolute;top:-2px;right:-2px;background:var(--red);color:#fff;font-size:8px;padding:1px 4px;border-radius:8px;display:none;"></span></button>
  <button class="nav-btn-inline" onclick="openSettingsPanel()" style="border-color:rgba(255,255,255,.2);"><span class="icon">⚙️</span><span class="nav-label">Settings</span></button>

  <div id="balanceDisplay">
    <button id="muteBtn" onclick="toggleMute()" style="padding:5px 8px;border:none;border-radius:6px;cursor:pointer;background:var(--surface2);color:var(--text);font-size:13px;transition:all .2s;" title="Toggle Sound">🔊</button>
    <button class="daily-bonus-btn" id="dailyBonusBtn" onclick="claimDailyBonus()" style="font-size:11px;padding:4px 10px;">🎁 DAILY</button>
    <div class="bal">$<span id="balText">1000.00</span></div>
    <button class="add-btn" onclick="addMoney(500)">💸 PITY $500</button>
    <div class="user-info">
      <div class="user-avatar" id="userAvatar"><svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false"><defs><linearGradient id="avG0" x1="0" x2="1"><stop offset="0" stop-color="#00f0ff"/><stop offset="1" stop-color="#6b2fd9"/></linearGradient></defs><circle cx="50" cy="50" r="48" fill="url(#avG0)"/><text x="50" y="58" font-family="Orbitron,Inter,sans-serif" font-weight="900" font-size="48" fill="#fff" text-anchor="middle">G</text></svg></div>
      <span class="user-name" id="userNameDisplay">...</span>
      <button class="logout-btn" onclick="authLogout()" title="Logout" aria-label="Logout">⏻</button>
    </div>
  </div>
</nav>

<!-- Games Menu Overlay -->
<div id="gamesMenuOverlay" style="display:none;position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(4,8,20,.92);z-index:9998;padding-top:60px;overflow-y:auto;-webkit-overflow-scrolling:touch;">
  <div style="max-width:800px;margin:0 auto;padding:20px;position:relative;">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:24px;position:sticky;top:0;background:rgba(4,8,20,.95);padding:12px;border-radius:8px;z-index:1;">
      <span style="font-family:'Orbitron';font-size:24px;color:var(--neon);font-weight:900;letter-spacing:2px;">🎮 ALL GAMES</span>
      <button onclick="closeGamesMenu()" style="background:none;border:none;color:var(--text2);font-size:24px;cursor:pointer;padding:0;width:32px;height:32px;display:flex;align-items:center;justify-content:center;">✕</button>
    </div>
    
    <!-- Game Categories Grid -->
    <div id="gamesCategoriesContainer" style="display:grid;gap:20px;"></div>
  </div>
</div>

<!-- ============ SETTINGS OVERLAY ============ -->
<div id="settingsOverlay" style="display:none;position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(4,8,20,.94);z-index:9999;overflow-y:auto;-webkit-overflow-scrolling:touch;">
  <div style="max-width:500px;margin:60px auto 40px;padding:20px;">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:24px;">
      <span style="font-family:'Orbitron';font-size:22px;color:var(--neon);font-weight:900;letter-spacing:2px;">⚙️ SETTINGS</span>
      <button onclick="closeSettingsPanel()" style="background:none;border:none;color:var(--text2);font-size:24px;cursor:pointer;">✕</button>
    </div>

    <!-- Sound -->
    <div style="background:var(--surface);border:1px solid var(--border);border-radius:12px;padding:16px;margin-bottom:12px;">
      <div style="font-family:'Orbitron';font-size:12px;color:var(--gold);letter-spacing:2px;margin-bottom:12px;">🔊 SOUND</div>
      <div style="display:flex;align-items:center;justify-content:space-between;">
        <span style="color:var(--text);font-size:13px;">Sound Effects</span>
        <label style="position:relative;display:inline-block;width:48px;height:26px;cursor:pointer;">
          <input type="checkbox" id="settingSound" onchange="settingToggle('sound',this.checked)" style="opacity:0;width:0;height:0;">
          <span style="position:absolute;inset:0;background:var(--surface2);border-radius:26px;transition:.3s;"></span>
          <span id="settingSoundKnob" style="position:absolute;top:3px;left:3px;width:20px;height:20px;background:var(--text2);border-radius:50%;transition:.3s;"></span>
        </label>
      </div>
    </div>

    <!-- VFX -->
    <div style="background:var(--surface);border:1px solid var(--border);border-radius:12px;padding:16px;margin-bottom:12px;">
      <div style="font-family:'Orbitron';font-size:12px;color:var(--gold);letter-spacing:2px;margin-bottom:12px;">✨ VISUAL EFFECTS</div>
      <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:10px;">
        <span style="color:var(--text);font-size:13px;">Particles</span>
        <label style="position:relative;display:inline-block;width:48px;height:26px;cursor:pointer;">
          <input type="checkbox" id="settingParticles" onchange="settingToggle('particles',this.checked)" style="opacity:0;width:0;height:0;">
          <span style="position:absolute;inset:0;background:var(--surface2);border-radius:26px;transition:.3s;"></span>
          <span id="settingParticlesKnob" style="position:absolute;top:3px;left:3px;width:20px;height:20px;background:var(--text2);border-radius:50%;transition:.3s;"></span>
        </label>
      </div>
      <div style="display:flex;align-items:center;justify-content:space-between;">
        <span style="color:var(--text);font-size:13px;">Reduced Animations</span>
        <label style="position:relative;display:inline-block;width:48px;height:26px;cursor:pointer;">
          <input type="checkbox" id="settingReducedAnim" onchange="settingToggle('reducedAnim',this.checked)" style="opacity:0;width:0;height:0;">
          <span style="position:absolute;inset:0;background:var(--surface2);border-radius:26px;transition:.3s;"></span>
          <span id="settingReducedAnimKnob" style="position:absolute;top:3px;left:3px;width:20px;height:20px;background:var(--text2);border-radius:50%;transition:.3s;"></span>
        </label>
      </div>
    </div>

    <!-- Theme -->
    <div style="background:var(--surface);border:1px solid var(--border);border-radius:12px;padding:16px;margin-bottom:12px;">
      <div style="font-family:'Orbitron';font-size:12px;color:var(--gold);letter-spacing:2px;margin-bottom:12px;">🎨 THEME</div>
      <div id="themeButtons" style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;">
        <button onclick="setTheme('dark')" class="theme-btn" data-theme="dark" style="padding:10px;border-radius:8px;border:2px solid var(--border);background:linear-gradient(135deg,#040814,#0a0f2e);color:#00f0ff;cursor:pointer;font-size:12px;font-weight:700;">🌑 Dark</button>
        <button onclick="setTheme('midnight')" class="theme-btn" data-theme="midnight" style="padding:10px;border-radius:8px;border:2px solid var(--border);background:linear-gradient(135deg,#0d0221,#1a0533);color:#d32ce6;cursor:pointer;font-size:12px;font-weight:700;">🌌 Midnight</button>
        <button onclick="setTheme('ocean')" class="theme-btn" data-theme="ocean" style="padding:10px;border-radius:8px;border:2px solid var(--border);background:linear-gradient(135deg,#001a33,#003366);color:#00bfff;cursor:pointer;font-size:12px;font-weight:700;">🌊 Ocean</button>
        <button onclick="setTheme('forest')" class="theme-btn" data-theme="forest" style="padding:10px;border-radius:8px;border:2px solid var(--border);background:linear-gradient(135deg,#0a1f0a,#183a18);color:#00e676;cursor:pointer;font-size:12px;font-weight:700;">🌲 Forest</button>
        <button onclick="setTheme('crimson')" class="theme-btn" data-theme="crimson" style="padding:10px;border-radius:8px;border:2px solid var(--border);background:linear-gradient(135deg,#1a0505,#330a0a);color:#ff4444;cursor:pointer;font-size:12px;font-weight:700;">🔥 Crimson</button>
        <button onclick="setTheme('gold')" class="theme-btn" data-theme="gold" style="padding:10px;border-radius:8px;border:2px solid var(--border);background:linear-gradient(135deg,#1a1500,#332a00);color:#ffd700;cursor:pointer;font-size:12px;font-weight:700;">👑 Gold</button>
      </div>
    </div>

    <!-- Version -->
    <div style="text-align:center;color:var(--text2);font-size:11px;margin-top:16px;">Casino v3.0 · Island</div>
  </div>
</div>

<!-- ============ SHOP OVERLAY ============ -->
<div id="shopOverlay" style="display:none;position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(4,8,20,.94);z-index:9999;overflow-y:auto;-webkit-overflow-scrolling:touch;">
  <div style="max-width:600px;margin:60px auto 40px;padding:20px;">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:24px;">
      <span style="font-family:'Orbitron';font-size:22px;color:var(--gold);font-weight:900;letter-spacing:2px;">🛒 SHOP</span>
      <button onclick="closeShopOverlay()" style="background:none;border:none;color:var(--text2);font-size:24px;cursor:pointer;">✕</button>
    </div>
    <div style="color:var(--text2);font-size:12px;margin-bottom:16px;">Balance: $<span id="shopBalText">0</span></div>

    <!-- Potions Section -->
    <div style="font-family:'Orbitron';font-size:13px;color:var(--neon);letter-spacing:2px;margin-bottom:12px;">🧪 POTIONS</div>
    <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-bottom:20px;">
      <!-- Luck Potion -->
      <div style="background:var(--surface);border:1px solid rgba(255,215,0,.3);border-radius:12px;padding:16px;text-align:center;">
        <div style="font-size:36px;margin-bottom:6px;">🍀</div>
        <div style="font-weight:700;color:var(--gold);margin-bottom:4px;">Luck Potion</div>
        <div style="font-size:11px;color:var(--text2);margin-bottom:8px;">+5% better odds for 10 minutes. Stacks up to 5x!</div>
        <div style="font-size:11px;color:var(--neon);margin-bottom:8px;">Active: <span id="shopLuckCount">0</span>/5 stacks</div>
        <button onclick="shopBuyPotion('luck')" class="action-btn primary" style="padding:8px 16px;font-size:12px;">$2,000</button>
      </div>
      <!-- Speed Potion -->
      <div style="background:var(--surface);border:1px solid rgba(0,240,255,.3);border-radius:12px;padding:16px;text-align:center;">
        <div style="font-size:36px;margin-bottom:6px;">⚡</div>
        <div style="font-weight:700;color:var(--neon);margin-bottom:4px;">Speed Potion</div>
        <div style="font-size:11px;color:var(--text2);margin-bottom:8px;">2x faster game animations for 15 minutes.</div>
        <div style="font-size:11px;color:var(--neon);margin-bottom:8px;">Active: <span id="shopSpeedActive">OFF</span></div>
        <button onclick="shopBuyPotion('speed')" class="action-btn primary" style="padding:8px 16px;font-size:12px;">$3,000</button>
      </div>
      <!-- Shield Potion -->
      <div style="background:var(--surface);border:1px solid rgba(0,230,118,.3);border-radius:12px;padding:16px;text-align:center;">
        <div style="font-size:36px;margin-bottom:6px;">🛡️</div>
        <div style="font-weight:700;color:var(--green);margin-bottom:4px;">Shield Potion</div>
        <div style="font-size:11px;color:var(--text2);margin-bottom:8px;">Prevents loss of more than 50% of your bet for 5 mins.</div>
        <div style="font-size:11px;color:var(--neon);margin-bottom:8px;">Active: <span id="shopShieldActive">OFF</span></div>
        <button onclick="shopBuyPotion('shield')" class="action-btn primary" style="padding:8px 16px;font-size:12px;">$5,000</button>
      </div>
      <!-- XP Potion -->
      <div style="background:var(--surface);border:1px solid rgba(138,43,226,.3);border-radius:12px;padding:16px;text-align:center;">
        <div style="font-size:36px;margin-bottom:6px;">📈</div>
        <div style="font-weight:700;color:#8a2be2;margin-bottom:4px;">XP Boost</div>
        <div style="font-size:11px;color:var(--text2);margin-bottom:8px;">2x stats tracking multiplier for 20 minutes.</div>
        <div style="font-size:11px;color:var(--neon);margin-bottom:8px;">Active: <span id="shopXPActive">OFF</span></div>
        <button onclick="shopBuyPotion('xp')" class="action-btn primary" style="padding:8px 16px;font-size:12px;">$4,000</button>
      </div>
    </div>

    <!-- Active Effects -->
    <div style="font-family:'Orbitron';font-size:13px;color:var(--gold);letter-spacing:2px;margin-bottom:12px;">⏱️ ACTIVE EFFECTS</div>
    <div id="shopActiveEffects" style="background:var(--surface);border:1px solid var(--border);border-radius:12px;padding:16px;margin-bottom:20px;min-height:40px;">
      <div style="color:var(--text2);font-size:12px;text-align:center;">No active effects</div>
    </div>
  </div>
</div>

<!-- Particles Canvas -->
<div id="gameCatalog" style="position:fixed;top:50px;left:0;right:0;bottom:0;display:flex;flex-wrap:wrap;justify-content:center;align-content:flex-start;gap:32px;padding:32px 16px 60px;background:var(--surface1);z-index:10;overflow-y:auto;-webkit-overflow-scrolling:touch;">
  <div class="catalog-card" onclick="switchGame('slots',this)"><span class="icon">🎰</span><div>Slots</div></div>
  <div class="catalog-card" onclick="switchGame('crash',this)"><span class="icon">📈</span><div>Crash</div></div>
  <div class="catalog-card" onclick="switchGame('mines',this)"><span class="icon">💣</span><div>Mines</div></div>
  <div class="catalog-card" onclick="switchGame('plinko',this)"><span class="icon">⚡</span><div>Plinko</div></div>
  <div class="catalog-card" onclick="switchGame('cases',this)"><span class="icon">📦</span><div>Cases</div></div>
  <div class="catalog-card" onclick="switchGame('blackjack',this)"><span class="icon">🃏</span><div>Blackjack</div></div>
  <div class="catalog-card" onclick="switchGame('poker',this)"><span class="icon">♠️</span><div>Video Poker</div></div>
  <div class="catalog-card" onclick="switchGame('baccarat',this)"><span class="icon">🎴</span><div>Baccarat</div></div>
  <div class="catalog-card" onclick="switchGame('hilo',this)"><span class="icon">↕️</span><div>Hi-Lo</div></div>
  <div class="catalog-card" onclick="switchGame('roulette',this)"><span class="icon">🎡</span><div>Roulette</div></div>
  <div class="catalog-card" onclick="switchGame('wheel',this)"><span class="icon">💫</span><div>Wheel</div></div>
  <div class="catalog-card" onclick="switchGame('keno',this)"><span class="icon">🔢</span><div>Keno</div></div>
  <div class="catalog-card" onclick="switchGame('horses',this)"><span class="icon">🏇</span><div>Horse Racing</div></div>
  <div class="catalog-card" onclick="switchGame('dice',this)"><span class="icon">🎯</span><div>Dice</div></div>
  <div class="catalog-card" onclick="switchGame('limbo',this)"><span class="icon">🚀</span><div>Limbo</div></div>
  <div class="catalog-card" onclick="switchGame('coinflip',this)"><span class="icon">🪙</span><div>Coin Flip</div></div>
  <div class="catalog-card" onclick="switchGame('tower',this)"><span class="icon">🗼</span><div>Tower</div></div>
  <div class="catalog-card" onclick="switchGame('scratch',this)"><span class="icon">🎫</span><div>Scratch Cards</div></div>
  <div class="catalog-card" onclick="switchGame('luck',this)"><span class="icon">🎲</span><div>Push Your Luck</div></div>
  <div class="catalog-card" onclick="switchGame('stocks',this)"><span class="icon">📊</span><div>Stocks</div></div>
  <div class="catalog-card" onclick="switchGame('rusroulette',this)"><span class="icon">🔫</span><div>Buckshot Roulette</div></div>
  <div class="catalog-card" onclick="switchGame('russianr',this)"><span class="icon">🎰</span><div>Russian Roulette</div></div>
  <div class="catalog-card" onclick="switchGame('mpbsr',this)"><span class="icon">💥</span><div>MP Buckshot</div></div>
  <div class="catalog-card" onclick="switchGame('crypto',this)"><span class="icon">₿</span><div>Crypto</div></div>
  <div class="catalog-card" onclick="switchGame('duels',this)"><span class="icon">⚔️</span><div>Duels</div></div>
</div>

<canvas id="particles"></canvas>

<!-- Win Toast -->
<div class="win-toast" id="winToast"></div>

<!-- ============ SLOTS ============ -->
<div class="game-panel" id="slotsPanel">
  <div class="htp-box"><button class="htp-toggle" onclick="htpToggle(this)"><span class="htp-arrow">▶</span> HOW TO PLAY</button><div class="htp-content"><ul><li>Set your <strong>bet amount</strong> using the bet controls.</li><li>Press <strong>SPIN</strong> to spin the reels.</li><li>Match <strong>3+ symbols</strong> in a row to win — multiplier depends on the symbol.</li><li>Special symbols like 💎 and 👑 pay the highest.</li><li>Wins are calculated as <strong>bet × symbol multiplier</strong>.</li></ul></div></div>
  <div class="slots-machine">
    <div class="slots-header">MEGA SLOTS</div>
    <div class="reels-container" id="reelsContainer">
      <div class="payline-indicator"></div>
    </div>
    <div class="slots-info">Match 3+ symbols on the payline to win!</div>
  </div>
  
  <div style="display:flex;align-items:center;gap:16px;margin-top:4px;">
    <div class="bet-controls">
      <span style="color:var(--text2);font-size:13px;font-weight:600;">BET</span>
      <button class="bet-btn bet-half" onclick="adjustBet('slotsBet',0.5)">½</button>
      <input class="bet-input" type="number" id="slotsBet" value="10" min="1" title="Bet amount">
      <button class="bet-btn bet-double" onclick="adjustBet('slotsBet',2)">2×</button>
      <button class="bet-btn" onclick="betAll('slotsBet')" style="background:var(--gold);color:#000;font-weight:900;font-size:10px;">MAX</button>
    </div>
    <button class="action-btn primary" id="spinBtn" onclick="spinSlots()">SPIN</button>
  </div>
</div>

<!-- ============ CRASH ============ -->
<div class="game-panel" id="crashPanel">
  <div class="htp-box"><button class="htp-toggle" onclick="htpToggle(this)"><span class="htp-arrow">▶</span> HOW TO PLAY</button><div class="htp-content"><ul><li>Set your <strong>bet amount</strong> before the round starts.</li><li>Press <strong>START</strong> — the multiplier begins climbing from 1.00×.</li><li>Press <strong>CASH OUT</strong> before the rocket crashes to lock in your win.</li><li>If you don't cash out in time, you <strong>lose your bet</strong>.</li><li>The crash point is random — it could crash at 1.01× or go past 100×!</li></ul></div></div>
  <div class="crash-container">
    <canvas class="crash-canvas" id="crashCanvas"></canvas>
    <div class="crash-multiplier" id="crashMultiplier">1.00×</div>
  </div>
  <div class="crash-status" id="crashStatus">Place your bet and start the round</div>
  
  <div style="display:flex;align-items:center;gap:16px;">
    <div class="bet-controls">
      <span style="color:var(--text2);font-size:13px;font-weight:600;">BET</span>
      <button class="bet-btn bet-half" onclick="adjustBet('crashBet',0.5)">½</button>
      <input class="bet-input" type="number" id="crashBet" value="10" min="1">
      <button class="bet-btn bet-double" onclick="adjustBet('crashBet',2)">2×</button>
      <button class="bet-btn" onclick="betAll('crashBet')" style="background:var(--gold);color:#000;font-weight:900;font-size:10px;">MAX</button>
    </div>
    <button class="action-btn primary" id="crashStartBtn" onclick="startCrash()">START</button>
    <button class="action-btn danger" id="cashoutBtn" onclick="cashOut()" style="display:none">CASH OUT</button>
  </div>
</div>

<!-- ============ ROULETTE ============ -->
<div class="game-panel" id="roulettePanel">
  <div class="htp-box"><button class="htp-toggle" onclick="htpToggle(this)"><span class="htp-arrow">▶</span> HOW TO PLAY</button><div class="htp-content"><ul><li>Place bets on <strong>numbers, colors, or sections</strong> of the wheel.</li><li>Choose Red (2×), Black (2×), Green (36×), or specific number ranges.</li><li>Press <strong>SPIN</strong> to spin the roulette wheel.</li><li>If the ball lands on your selection, you win <strong>bet × the multiplier</strong>.</li><li>Green (0) is the rarest outcome but pays the most.</li></ul></div></div>
  <div class="roulette-wrapper">
    <div class="roulette-pointer"></div>
    <canvas class="roulette-canvas" id="rouletteCanvas" width="360" height="360"></canvas>
  </div>
  <div class="roulette-result" id="rouletteResult"></div>
  <div class="roulette-bets" id="rouletteBetsDiv">
    <button class="roul-bet-btn red-btn" onclick="selectRoulBet('red',this)">🔴 Red</button>
    <button class="roul-bet-btn black-btn" onclick="selectRoulBet('black',this)">⚫ Black</button>
    <button class="roul-bet-btn green-btn" onclick="selectRoulBet('green',this)">💚 Green</button>
    <button class="roul-bet-btn" onclick="selectRoulBet('odd',this)">Odd</button>
    <button class="roul-bet-btn" onclick="selectRoulBet('even',this)">Even</button>
    <button class="roul-bet-btn" onclick="selectRoulBet('1-18',this)">1-18</button>
    <button class="roul-bet-btn" onclick="selectRoulBet('19-36',this)">19-36</button>
  </div>
  
  
  <div style="display:flex;align-items:center;gap:16px;">
    <div class="bet-controls">
      <span style="color:var(--text2);font-size:13px;font-weight:600;">BET</span>
      <button class="bet-btn bet-half" onclick="adjustBet('roulBetInput',0.5)">½</button>
      <input class="bet-input" type="number" id="roulBetInput" value="10" min="1">
      <button class="bet-btn bet-double" onclick="adjustBet('roulBetInput',2)">2×</button>
      <button class="bet-btn" onclick="betAll('roulBetInput')" style="background:var(--gold);color:#000;font-weight:900;font-size:10px;">MAX</button>
    </div>
    <button class="action-btn primary" id="roulSpinBtn" onclick="spinRoulette()">SPIN</button>
  </div>
</div>

<!-- ============ CASES ============ -->
<div class="game-panel" id="casesPanel">
  <div class="htp-box"><button class="htp-toggle" onclick="htpToggle(this)"><span class="htp-arrow">▶</span> HOW TO PLAY</button><div class="htp-content"><ul><li>Choose a <strong>case tier</strong> — higher tiers have rarer items!</li><li>Press <strong>OPEN CASE</strong> to spin and reveal your prize.</li><li>Items go to your <strong>inventory</strong> — sell or trade them!</li><li>Market prices change live based on <strong>global supply &amp; demand</strong>.</li><li>🔥 Hit a streak bonus by opening cases back-to-back!</li></ul></div></div>
  
  <!-- Case streak & stats bar -->
  <div id="caseStatsBar" style="display:flex;gap:12px;align-items:center;justify-content:center;flex-wrap:wrap;">
    <div style="padding:6px 12px;background:var(--surface);border:1px solid var(--border);border-radius:8px;font-size:11px;">
      <span style="color:var(--text2);">Cases Opened:</span> <span id="caseOpenCount" style="color:var(--gold);font-family:'Orbitron';font-weight:700;">0</span>
    </div>
    <div style="padding:6px 12px;background:var(--surface);border:1px solid var(--border);border-radius:8px;font-size:11px;">
      <span style="color:var(--text2);">Streak:</span> <span id="caseStreak" style="color:var(--neon);font-family:'Orbitron';font-weight:700;">0</span>
      <span id="caseStreakBonus" style="color:var(--green);font-size:10px;font-weight:600;"></span>
    </div>
    <div style="padding:6px 12px;background:var(--surface);border:1px solid var(--border);border-radius:8px;font-size:11px;">
      <span style="color:var(--text2);">Best:</span> <span id="caseBestItem" style="color:var(--gold);font-size:10px;font-weight:600;">—</span>
    </div>
  </div>
  
  <div class="case-selector" id="caseSelector"></div>
  
  <div class="case-opener" id="caseOpener">
    <div class="case-pointer"></div>
    <div class="case-strip" id="caseStrip"></div>
    <!-- Suspense overlay flash -->
    <div id="caseFlash" style="position:absolute;top:0;left:0;right:0;bottom:0;pointer-events:none;opacity:0;transition:opacity 0.3s;z-index:10;"></div>
  </div>
  
  <div class="case-won" id="caseWon"></div>
  <div class="case-won-detail" id="caseWonDetail"></div>
  
  <div style="display:flex;gap:8px;align-items:center;justify-content:center;flex-wrap:wrap;">
    <button class="action-btn primary" id="openCaseBtn" onclick="openCase()" style="min-width:160px;">🎰 OPEN CASE</button>
    <button class="action-btn primary" id="quickOpenBtn" onclick="quickOpenCase()" style="min-width:120px;background:linear-gradient(135deg,#8847ff,#6b2fd9);box-shadow:0 4px 20px rgba(136,71,255,.3);">⚡ QUICK OPEN</button>
  </div>
  
  <!-- Recent unboxings feed -->
  <div id="caseRecentFeed" style="display:flex;gap:6px;overflow-x:auto;width:min(700px,92vw);padding:4px 0;margin-top:4px;"></div>

  <!-- Limited Edition Cases -->
  <div style="margin-top:16px;width:min(700px,92vw);">
    <div style="font-family:'Orbitron';font-size:13px;color:var(--gold);letter-spacing:2px;margin-bottom:10px;">⏱️ LIMITED EDITION CASES</div>
    <div id="limitedCasesContainer" style="display:grid;grid-template-columns:repeat(auto-fill,minmax(180px,1fr));gap:10px;"></div>
  </div>
</div>

<!-- ============ PLINKO ============ -->
<div class="game-panel" id="plinkoPanel">
  <div class="htp-box"><button class="htp-toggle" onclick="htpToggle(this)"><span class="htp-arrow">▶</span> HOW TO PLAY</button><div class="htp-content"><ul><li>Set your <strong>bet</strong> and choose <strong>risk level</strong> (Low/Medium/High).</li><li>Press <strong>DROP</strong> to release a ball from the top.</li><li>The ball bounces off pegs randomly as it falls down.</li><li>Higher risk = bigger potential wins but also more losing slots.</li><li>The slot the ball lands in determines your <strong>multiplier</strong>.</li></ul></div></div>
  <div class="plinko-sidebar">
    <div style="font-family:'Orbitron';font-size:18px;font-weight:700;color:var(--neon);margin-bottom:8px;">PLINKO</div>
    <div>
      <label>Bet Amount</label>
      <div style="display:flex;gap:6px;">
        <input type="number" id="plinkoBet" value="10" min="1" style="flex:1;">
        <button class="bet-btn bet-half" onclick="adjustBet('plinkoBet',0.5)" style="padding:6px 10px;">½</button>
        <button class="bet-btn bet-double" onclick="adjustBet('plinkoBet',2)" style="padding:6px 10px;">2×</button>
        <button class="bet-btn" onclick="betAll('plinkoBet')" style="padding:6px 10px;background:var(--gold);color:#000;font-weight:900;font-size:10px;">MAX</button>
      </div>
    </div>
    <div>
      <label>Risk</label>
      <select id="plinkoRisk">
        <option value="LOW">Low</option>
        <option value="MEDIUM" selected>Medium</option>
        <option value="HIGH">High</option>
      </select>
    </div>
    <div>
      <label>Rows</label>
      <select id="plinkoRows">
        <option value="8">8</option><option value="9">9</option><option value="10">10</option>
        <option value="11">11</option><option value="12">12</option><option value="13">13</option>
        <option value="14">14</option><option value="15">15</option><option value="16" selected>16</option>
      </select>
    </div>
    
    <div style="display:flex;gap:8px;margin-top:8px;">
      <button class="action-btn primary" onclick="dropPlinkoBall()" style="flex:1;">DROP BALL</button>
    </div>
    <button class="action-btn primary" id="autoDropBtn" onclick="toggleAutoDrop()" style="width:100%;background:linear-gradient(135deg,#3355cc,#2244aa);box-shadow:0 4px 20px rgba(51,85,204,.3);margin-top:8px;">AUTO DROP</button>

    <!-- Live Stats (matching plinko-game-online.github.io) -->
    <div class="plinko-live-stats" style="margin-top:12px;">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
        <div style="display:flex;align-items:center;gap:6px;"><span style="font-size:14px;">📈</span><span style="font-size:12px;font-weight:600;color:#fff;">Live Stats</span></div>
        <button class="action-btn" onclick="resetPlinkoStats()" style="padding:4px 10px;font-size:10px;" title="Reset Live Stats">↻ Reset</button>
      </div>
      <!-- Profit / Wins / Losses -->
      <div style="display:flex;background:rgba(15,23,42,0.8);border-radius:8px;padding:10px 12px;font-size:12px;margin-bottom:8px;">
        <div style="flex:1;">
          <div style="color:var(--text2);font-weight:500;margin-bottom:2px;">Profit</div>
          <div id="plinkoProfit" style="font-weight:700;font-variant-numeric:tabular-nums;color:#4ade80;">$0.00</div>
        </div>
        <div style="width:1px;background:rgba(100,116,139,0.4);margin:0 12px;" aria-hidden></div>
        <div style="flex:1;">
          <div><div style="color:var(--text2);font-weight:500;margin-bottom:2px;">Wins</div><div id="plinkoWins" style="font-weight:700;font-variant-numeric:tabular-nums;color:#4ade80;">0</div></div>
          <div style="margin-top:6px;"><div style="color:var(--text2);font-weight:500;margin-bottom:2px;">Losses</div><div id="plinkoLosses" style="font-weight:700;font-variant-numeric:tabular-nums;color:#f87171;">0</div></div>
        </div>
      </div>
      <!-- Profit History Chart -->
      <div style="background:rgba(15,23,42,0.8);border-radius:8px;padding:10px 12px;">
        <div style="display:flex;justify-content:space-between;align-items:flex-start;">
          <div style="color:var(--text2);font-weight:500;font-size:12px;">Profit History</div>
          <div id="plinkoHoverValue" style="font-size:12px;font-weight:600;font-variant-numeric:tabular-nums;"></div>
        </div>
        <div style="height:120px;margin-top:8px;">
          <canvas id="plinkoProfitChart" style="width:100%;height:100%;display:block;"></canvas>
        </div>
      </div>
      <div style="margin-top:6px;font-size:11px;color:var(--text2);">Balls dropped: <span id="plinkoDropCount">0</span></div>
    </div>
  </div>
  <div class="plinko-main">
    <div class="plinko-canvas-wrap">
      <canvas id="plinkoCanvas"></canvas>
      <div class="plinko-bins" id="plinkoBins"></div>
    </div>
    <div class="plinko-last-wins" id="plinkoLastWins"></div>
  </div>
</div>

<!-- ============ PUSH YOUR LUCK ============ -->
<div class="game-panel" id="luckPanel">
  <div class="htp-box"><button class="htp-toggle" onclick="htpToggle(this)"><span class="htp-arrow">▶</span> HOW TO PLAY</button><div class="htp-content"><ul><li>This is a <strong>multiplayer trivia game</strong>!</li><li>Answer questions correctly to earn points and avoid Whammy spaces.</li><li>Press your luck to keep going, or stop to keep your points.</li><li>Landing on a <strong>Whammy</strong> loses all your round points.</li><li>The player with the most points at the end wins!</li></ul></div></div>
  <!-- iframe gets created dynamically when needed -->
    

  <!-- Lobby Overlay -->
  <div class="pyl-lobby" id="pylLobby">
    <div class="pyl-title">PUSH YOUR LUCK</div>
    <div class="pyl-subtitle">Choose your game mode</div>
    

    <div class="pyl-modes">
      <div class="pyl-mode" onclick="pylStartMode('solo')">
        <div class="pm-icon">🎲</div>
        <div class="pm-name">FREE PLAY</div>
        <div class="pm-desc">Practice mode. No wagers, just vibes.</div>
      </div>
      <div class="pyl-mode" onclick="pylShowWager('1v1')">
        <div class="pm-icon">⚔️</div>
        <div class="pm-name">1v1 WAGER</div>
        <div class="pm-desc">Create or join a room. Both play, highest score takes the pot.</div>
        <div class="pm-badge">COMPETITIVE</div>
      </div>
      <div class="pyl-mode" onclick="pylShowWager('highstakes')">
        <div class="pm-icon">💀</div>
        <div class="pm-name">HIGH STAKES</div>
        <div class="pm-desc">Solo play with massive multiplier wagers. Risk it all.</div>
        <div class="pm-badge">2x — 10x PAYOUT</div>
      </div>
      <div class="pyl-mode" onclick="pylStartMode('tournament')">
        <div class="pm-icon">🏆</div>
        <div class="pm-name">TOURNAMENT</div>
        <div class="pm-desc">Compete on the global leaderboard. Top scores win prizes.</div>
        <div class="pm-badge">LEADERBOARD</div>
      </div>
    </div>

    <!-- 1v1 Room UI (hidden by default) -->
    <div class="pyl-room" id="pylRoomUI" style="display:none;">
      <div class="pr-title" id="pylRoomTitle">1v1 WAGER MATCH</div>
      <div style="display:flex;gap:8px;justify-content:center;margin-bottom:12px;">
        <div class="bet-controls">
          <span style="color:var(--text2);font-size:12px;font-weight:600;">WAGER $</span>
          <input class="bet-input" type="number" id="pylWager" value="100" min="10" style="width:80px;">
        </div>
      </div>
      <div style="display:flex;gap:8px;justify-content:center;margin-bottom:12px;">
        <button class="action-btn primary" onclick="pylCreateRoom()" style="font-size:12px;padding:10px 20px;">CREATE ROOM</button>
        <div style="display:flex;gap:4px;">
          <input class="bet-input" type="text" id="pylJoinCode" placeholder="CODE" style="width:70px;text-transform:uppercase;text-align:center;">
          <button class="action-btn primary" onclick="pylJoinRoom()" style="font-size:12px;padding:10px 16px;background:linear-gradient(135deg,#8847ff,#6b2fd9);">JOIN</button>
        </div>
      </div>
      <div class="pr-status" id="pylRoomStatus">Create a room or enter a code to join</div>
      <div class="pr-players" id="pylRoomPlayers"></div>
      <button class="pyl-back-btn" onclick="pylBackToLobby()" style="margin-top:10px;">← Back to modes</button>
    </div>

    <!-- High Stakes UI -->
    <div class="pyl-room" id="pylHighStakesUI" style="display:none;">
      <div class="pr-title">💀 HIGH STAKES</div>
      <div style="color:var(--text2);font-size:12px;margin-bottom:12px;">
        Set your target score. If you hit it, you win BIG. If you don't... you lose it all.
      </div>
      <div style="display:flex;gap:10px;justify-content:center;align-items:center;margin-bottom:12px;flex-wrap:wrap;">
        <div class="bet-controls">
          <span style="color:var(--text2);font-size:11px;font-weight:600;">WAGER $</span>
          <input class="bet-input" type="number" id="pylHSWager" value="500" min="50" style="width:80px;">
        </div>
        <div class="bet-controls">
          <span style="color:var(--text2);font-size:11px;font-weight:600;">TARGET</span>
          <select id="pylHSTarget" style="background:var(--bg);color:var(--text);border:1px solid var(--border);border-radius:6px;padding:6px;font-size:12px;">
            <option value="500" data-mult="2">500 pts (2x)</option>
            <option value="1000" data-mult="3">1000 pts (3x)</option>
            <option value="2000" data-mult="5">2000 pts (5x)</option>
            <option value="5000" data-mult="10">5000 pts (10x)</option>
          </select>
        </div>
      </div>
      <button class="action-btn primary" onclick="pylStartHighStakes()" style="font-size:14px;padding:12px 30px;">
        🔥 LOCK IT IN
      </button>
      <button class="pyl-back-btn" onclick="pylBackToLobby()" style="margin-top:10px;">← Back to modes</button>
    </div>

    <!-- Leaderboard -->
    <div class="pyl-leaderboard" id="pylLeaderboard">
      <div class="pyl-lb-title">🏆 TOP SCORES</div>
      <div id="pylLBRows"></div>
    </div>
  </div>

  <!-- In-Game Overlay -->
  <div class="pyl-overlay hidden" id="pylOverlay">
    <div class="pyl-score-card">
      <div class="psc-label" id="pylModeLabel">FREE PLAY</div>
      <div class="psc-val" style="color:var(--neon);" id="pylScoreDisplay">Score: —</div>
    </div>
    <div class="pyl-score-card" id="pylOpponentCard" style="display:none;">
      <div class="psc-label">⚔️ <span id="pylOpponentName">OPPONENT</span></div>
      <div class="psc-val" style="color:var(--red);" id="pylOpponentScore">—</div>
    </div>
    <div class="pyl-score-card" id="pylWagerCard" style="display:none;">
      <div class="psc-label">WAGER</div>
      <div class="psc-val" style="color:var(--gold);" id="pylWagerDisplay">$0</div>
    </div>
    <button class="pyl-back-btn" onclick="pylEndGame()">END GAME</button>
    <input type="hidden" id="pylScoreInput" value="0">
  </div>
</div>

<!-- ============ STOCKS ============ -->
<div class="game-panel" id="stocksPanel">
  <div class="htp-box"><button class="htp-toggle" onclick="htpToggle(this)"><span class="htp-arrow">▶</span> HOW TO PLAY</button><div class="htp-content"><ul><li>Pick a stock from the ticker bar below.</li><li><strong>Buy</strong> shares of any stock at the current market price.</li><li><strong>Sell All</strong> to cash out your position and lock in profit or cut losses.</li><li>All prices are <strong>synced live</strong> across all players (deterministic market).</li><li>Higher volatility = bigger swings. Watch the chart and time your trades!</li></ul></div></div>
  
  <!-- Ticker selector bar -->
  <div id="stockTickerBar" style="display:flex;gap:6px;padding:6px 8px;overflow-x:auto;width:100%;box-sizing:border-box;"></div>
  
  <div class="stock-hero">
    <div class="sh-ticker"><span class="stock-live-dot"></span><span id="stockTickerLabel">$GMBL</span> <span style="color:#8b949e;font-weight:400;" id="stockNameLabel">Gamble Corp</span></div>
    <div class="sh-price" id="stockPriceDisplay">$100.00</div>
    <div class="sh-change" id="stockChangeDisplay"></div>
  </div>
  
  <div class="stock-chart-wrap">
    <canvas id="stockChart"></canvas>
  </div>
  <div class="stock-portfolio">
    <div class="sp-stat"><div class="sp-label">Shares</div><div class="sp-val" id="stockShares">0</div></div>
    <div class="sp-stat"><div class="sp-label">Value</div><div class="sp-val" id="stockValue">$0</div></div>
    <div class="sp-stat"><div class="sp-label">P&L</div><div class="sp-val" id="stockPnl" style="color:#8b949e;">$0</div></div>
  </div>
  <div class="stock-actions-row">
    <button class="sa-btn sa-buy" onclick="buyStock(selectedStock)">BUY</button>
    <button class="sa-btn sa-sell" id="stockSellBtn" onclick="sellStock(selectedStock)" disabled>SELL ALL</button>
  </div>
  <div class="stock-amt-row">
    <div class="bet-controls">
      <span style="color:#8b949e;font-size:12px;font-weight:600;">$</span>
      <button class="bet-btn bet-half" onclick="adjustBet('stockBuyAmt',0.5)">½</button>
      <input class="bet-input" type="number" id="stockBuyAmt" value="100" min="1" style="width:80px;">
      <button class="bet-btn bet-double" onclick="adjustBet('stockBuyAmt',2)">2×</button>
    </div>
  </div>
  
  <!-- Portfolio overview for all stocks -->
  <div id="stockPortfolioOverview" style="width:100%;margin-top:8px;"></div>
</div>

<!-- ============ CRYPTO PANEL ============ -->
<div class="game-panel" id="cryptoPanel">
  <div class="htp-box"><button class="htp-toggle" onclick="htpToggle(this)"><span class="htp-arrow">▶</span> HOW TO PLAY</button><div class="htp-content"><ul>
    <li>Buy and sell <strong>cryptocurrencies</strong> with your casino balance.</li>
    <li>Prices update every 3 seconds with realistic volatility.</li>
    <li>Enter a <strong>dollar amount</strong> and click BUY to acquire coins.</li>
    <li>SELL to sell a specific dollar amount, or <strong>SELL ALL</strong> to liquidate.</li>
    <li>Watch the sparkline charts for trends. Meme coins swing wildly!</li>
  </ul></div></div>
  <div style="text-align:center;margin-bottom:12px;">
    <span style="font-family:'Orbitron';font-size:24px;font-weight:900;background:linear-gradient(135deg,#f7931a,#ffd700);-webkit-background-clip:text;-webkit-text-fill-color:transparent;">₿ CRYPTO TRADING</span>
    <div style="font-size:11px;color:var(--text2);margin-top:4px;">Buy, hold, and trade cryptocurrencies</div>
  </div>
  <div id="cryptoContent" style="max-height:600px;overflow-y:auto;"></div>
</div>

<!-- ============ BLACKJACK ============ -->
<div class="game-panel" id="blackjackPanel">
  <div class="htp-box"><button class="htp-toggle" onclick="htpToggle(this)"><span class="htp-arrow">▶</span> HOW TO PLAY</button><div class="htp-content"><ul><li>Set your <strong>bet</strong> and press <strong>DEAL</strong> to start.</li><li>Try to get your cards as close to <strong>21</strong> as possible without going over.</li><li><strong>HIT</strong> for another card, <strong>STAND</strong> to keep your hand.</li><li>Face cards = 10, Aces = 1 or 11. Beat the dealer to win <strong>2× your bet</strong>.</li><li>Blackjack (Ace + 10-value) pays <strong>2.5× your bet</strong>!</li></ul></div></div>
  <div class="bj-table">
    <div class="bj-label">DEALER <span class="bj-score" id="bjDealerScore">—</span></div>
    <div class="bj-area" id="bjDealerCards"></div>
    <hr style="border-color:rgba(255,255,255,.1);margin:8px 0;">
    <div class="bj-label">YOU <span class="bj-score" id="bjPlayerScore">—</span></div>
    <div class="bj-area" id="bjPlayerCards"></div>
  </div>
  <div id="bjResult"></div>
  
  <div style="display:flex;align-items:center;gap:10px;flex-wrap:wrap;justify-content:center;">
    <div class="bet-controls">
      <span style="color:var(--text2);font-size:12px;font-weight:600;">BET</span>
      <button class="bet-btn bet-half" onclick="adjustBet('bjBet',0.5)">½</button>
      <input class="bet-input" type="number" id="bjBet" value="10" min="1">
      <button class="bet-btn bet-double" onclick="adjustBet('bjBet',2)">2×</button>
      <button class="bet-btn" onclick="betAll('bjBet')" style="background:var(--gold);color:#000;font-weight:900;font-size:10px;">MAX</button>
    </div>
    <button class="action-btn primary" id="bjDealBtn" onclick="bjDeal()">DEAL</button>
    <button class="action-btn primary" id="bjHitBtn" onclick="bjHit()" disabled style="background:linear-gradient(135deg,#3355cc,#2244aa);">HIT</button>
    <button class="action-btn danger" id="bjStandBtn" onclick="bjStand()" disabled>STAND</button>
    <button class="action-btn primary" id="bjDoubleBtn" onclick="bjDouble()" disabled style="background:linear-gradient(135deg,#cc8800,#996600);">2×</button>
  </div>
</div>

<!-- ============ MINES ============ -->
<div class="game-panel" id="minesPanel">
  <div class="htp-box"><button class="htp-toggle" onclick="htpToggle(this)"><span class="htp-arrow">▶</span> HOW TO PLAY</button><div class="htp-content"><ul><li>Set your <strong>bet</strong> and choose the <strong>number of mines</strong> (1-24).</li><li>Click tiles to reveal gems 💎 — each safe tile increases your multiplier.</li><li>Hit a mine 💣 and you <strong>lose everything</strong>.</li><li>Press <strong>CASH OUT</strong> anytime to collect your current winnings.</li><li>More mines = higher risk but <strong>bigger multipliers</strong> per tile!</li></ul></div></div>
  <div class="mines-wrap">
    <div class="mines-side">
      <div style="font-family:'Orbitron';font-size:14px;font-weight:700;color:var(--neon);">💣 MINES</div>
      <label>Bet</label>
      <div style="display:flex;gap:4px;">
        <input type="number" id="minesBet" value="10" min="1" style="flex:1;">
        <button class="bet-btn bet-half" onclick="adjustBet('minesBet',0.5)" style="padding:4px 8px;">½</button>
        <button class="bet-btn bet-double" onclick="adjustBet('minesBet',2)" style="padding:4px 8px;">2×</button>
        <button class="bet-btn" onclick="betAll('minesBet')" style="padding:4px 8px;background:var(--gold);color:#000;font-weight:900;font-size:10px;">MAX</button>
      </div>
      <label>Mines</label>
      <select id="mineCount"><option value="1">1</option><option value="3" selected>3</option><option value="5">5</option><option value="10">10</option><option value="15">15</option><option value="24">24</option></select>
      
      <div id="minesMultiplier">1.00×</div>
      <div id="minesProfit">Next: $0.00</div>
      <button class="action-btn primary" id="minesStartBtn" onclick="minesStart()" style="width:100%;font-size:12px;padding:8px;">START</button>
      <button class="action-btn danger" id="minesCashoutBtn" onclick="minesCashout()" style="width:100%;display:none;font-size:12px;padding:8px;">CASH OUT</button>
    </div>
    <div class="mines-grid" id="minesGrid"></div>
  </div>
</div>

<!-- ============ DICE ============ -->
<div class="game-panel" id="dicePanel">
  <div class="htp-box"><button class="htp-toggle" onclick="htpToggle(this)"><span class="htp-arrow">▶</span> HOW TO PLAY</button><div class="htp-content"><ul><li>Choose <strong>Roll Over</strong> or <strong>Roll Under</strong> mode.</li><li>Use the slider to set your <strong>target number</strong> (2-98).</li><li>The closer to the edge, the higher the multiplier but lower the chance.</li><li>Press <strong>ROLL</strong> — if the dice result matches your prediction, you win!</li><li>Win chance and multiplier are shown before you roll.</li></ul></div></div>
  <div class="dice-roll-display" id="diceDisplay">—</div>
  <div class="dice-mode-btns">
    <button class="dice-mode-btn active" id="diceOverBtn" onclick="diceSetMode('over')">Roll Over</button>
    <button class="dice-mode-btn" id="diceUnderBtn" onclick="diceSetMode('under')">Roll Under</button>
  </div>
  <div class="dice-slider-wrap">
    <input type="range" class="dice-slider" id="diceSlider" min="2" max="98" value="50" oninput="diceUpdateSlider()">
  </div>
  
  <div class="dice-info">
    <span>Target: <span id="diceTarget">50.00</span></span>
    <span>Chance: <span id="diceChance">50.00%</span></span>
    <span>Payout: <span id="dicePayout">1.98×</span></span>
  </div>
  <div style="display:flex;align-items:center;gap:12px;">
    <div class="bet-controls">
      <span style="color:var(--text2);font-size:12px;font-weight:600;">BET</span>
      <button class="bet-btn bet-half" onclick="adjustBet('diceBet',0.5)">½</button>
      <input class="bet-input" type="number" id="diceBet" value="10" min="1">
      <button class="bet-btn bet-double" onclick="adjustBet('diceBet',2)">2×</button>
      <button class="bet-btn" onclick="betAll('diceBet')" style="background:var(--gold);color:#000;font-weight:900;font-size:10px;">MAX</button>
    </div>
    <button class="action-btn primary" onclick="diceRoll()">ROLL</button>
  </div>
  
</div>

<!-- ============ TOWER ============ -->
<div class="game-panel" id="towerPanel">
  <div class="htp-box"><button class="htp-toggle" onclick="htpToggle(this)"><span class="htp-arrow">▶</span> HOW TO PLAY</button><div class="htp-content"><ul><li>Set your <strong>bet</strong> and choose <strong>difficulty</strong> (Easy to Insane).</li><li>Each row has safe tiles and trap tiles — click a tile to climb.</li><li>Each safe tile increases your <strong>multiplier</strong>.</li><li>Hit a trap 💀 and you <strong>lose your bet</strong>.</li><li>Press <strong>CASH OUT</strong> anytime to collect. Higher floors = bigger wins!</li></ul></div></div>
  <div id="towerInfo">Pick a difficulty and start climbing!</div>
  
  <div class="tower-grid" id="towerGrid"></div>
  <div style="display:flex;align-items:center;gap:10px;flex-wrap:wrap;justify-content:center;">
    <div class="bet-controls">
      <span style="color:var(--text2);font-size:12px;font-weight:600;">BET</span>
      <button class="bet-btn bet-half" onclick="adjustBet('towerBet',0.5)">½</button>
      <input class="bet-input" type="number" id="towerBet" value="10" min="1">
      <button class="bet-btn bet-double" onclick="adjustBet('towerBet',2)">2×</button>
      <button class="bet-btn" onclick="betAll('towerBet')" style="background:var(--gold);color:#000;font-weight:900;font-size:10px;">MAX</button>
    </div>
    <select id="towerDiff" style="padding:7px;border-radius:6px;border:1px solid var(--border);background:var(--bg);color:var(--text);font-size:12px;">
      <option value="easy">Easy (4 cols)</option><option value="medium" selected>Medium (3 cols)</option><option value="hard">Hard (4 cols, 2 safe)</option><option value="insane">Insane (4 cols, 1 safe)</option>
    </select>
    <button class="action-btn primary" id="towerStartBtn" onclick="towerStart()">START</button>
    <button class="action-btn danger" id="towerCashoutBtn" onclick="towerCashout()" style="display:none;">CASH OUT</button>
  </div>
</div>
<!-- ============ COIN FLIP ============ -->
<div class="game-panel" id="coinflipPanel">
  <div class="htp-box"><button class="htp-toggle" onclick="htpToggle(this)"><span class="htp-arrow">▶</span> HOW TO PLAY</button><div class="htp-content"><ul><li>Set your <strong>bet amount</strong>.</li><li>Choose <strong>Heads</strong> or <strong>Tails</strong>.</li><li>The coin flips — if it matches your pick, you win <strong>2× your bet</strong>!</li><li>Simple 50/50 odds — pure luck!</li><li>Watch the result history strip to spot streaks.</li></ul></div></div>
  <div class="coin" id="coinDisplay">🪙</div>
  <div id="coinResult"></div>
  
  <div class="coin-choices">
    <button class="coin-choice selected" id="coinHeads" onclick="coinSelect('heads')">👑 Heads</button>
    <button class="coin-choice" id="coinTails" onclick="coinSelect('tails')">🦅 Tails</button>
  </div>
  <div style="display:flex;align-items:center;gap:12px;">
    <div class="bet-controls">
      <span style="color:var(--text2);font-size:12px;font-weight:600;">BET</span>
      <button class="bet-btn bet-half" onclick="adjustBet('coinBet',0.5)">½</button>
      <input class="bet-input" type="number" id="coinBet" value="10" min="1">
      <button class="bet-btn bet-double" onclick="adjustBet('coinBet',2)">2×</button>
      <button class="bet-btn" onclick="betAll('coinBet')" style="background:var(--gold);color:#000;font-weight:900;font-size:10px;">MAX</button>
    </div>
    <button class="action-btn primary" id="coinFlipBtn" onclick="coinFlip()">FLIP</button>
  </div>
</div>

<!-- ============ KENO ============ -->
<div class="game-panel" id="kenoPanel">
  <div class="htp-box"><button class="htp-toggle" onclick="htpToggle(this)"><span class="htp-arrow">▶</span> HOW TO PLAY</button><div class="htp-content"><ul><li>Click to select <strong>1-10 numbers</strong> on the board (1-40).</li><li>Set your <strong>bet</strong> and press <strong>DRAW</strong>.</li><li>10 numbers are drawn randomly — matches earn payouts.</li><li>More numbers selected = harder to hit but <strong>bigger payouts</strong>.</li><li>Hitting all your picks pays the <strong>jackpot multiplier</strong>!</li></ul></div></div>
  <div style="font-family:'Orbitron';font-size:16px;font-weight:700;color:var(--gold);">KENO</div>
  <div id="kenoInfo">Pick up to 10 numbers, then draw!</div>
  
  <div class="keno-grid" id="kenoGrid"></div>
  <div id="kenoResult"></div>
  <div style="display:flex;align-items:center;gap:10px;">
    <div class="bet-controls">
      <span style="color:var(--text2);font-size:12px;font-weight:600;">BET</span>
      <button class="bet-btn bet-half" onclick="adjustBet('kenoBet',0.5)">½</button>
      <input class="bet-input" type="number" id="kenoBet" value="10" min="1">
      <button class="bet-btn bet-double" onclick="adjustBet('kenoBet',2)">2×</button>
      <button class="bet-btn" onclick="betAll('kenoBet')" style="background:var(--gold);color:#000;font-weight:900;font-size:10px;">MAX</button>
    </div>
    <button class="action-btn primary" id="kenoDrawBtn" onclick="kenoDraw()">DRAW</button>
    <button class="bet-btn" onclick="kenoClear()" style="color:var(--red);">CLEAR</button>
  </div>
  
</div>

<!-- ============ LIMBO ============ -->
<div class="game-panel" id="limboPanel">
  <div class="htp-box"><button class="htp-toggle" onclick="htpToggle(this)"><span class="htp-arrow">▶</span> HOW TO PLAY</button><div class="htp-content"><ul><li>Set your <strong>bet</strong> and enter a <strong>target multiplier</strong>.</li><li>Press <strong>GO</strong> — the game generates a random multiplier.</li><li>If the result is <strong>≥ your target</strong>, you win at that multiplier!</li><li>Higher targets = lower chance but bigger payouts.</li><li>Minimum target is 1.01× (99% chance), max risk for max reward!</li></ul></div></div>
  <div id="limboResult">—</div>
  <div style="width:100%;max-width:400px;height:8px;background:var(--surface);border-radius:8px;overflow:hidden;border:1px solid var(--border);">
    <div id="limboBar" style="height:100%;width:0%;border-radius:8px;transition:width 0.3s ease;"></div>
  </div>
  <div class="limbo-target-wrap">
    <label>Target ×</label>
    <input type="number" id="limboTarget" value="2" min="1.01" max="1000" step="0.01">
  </div>
  
  <div id="limboPayout">Win chance: 49.50% — Payout: 2.00×</div>
  <div style="display:flex;align-items:center;gap:12px;">
    <div class="bet-controls">
      <span style="color:var(--text2);font-size:12px;font-weight:600;">BET</span>
      <button class="bet-btn bet-half" onclick="adjustBet('limboBet',0.5)">½</button>
      <input class="bet-input" type="number" id="limboBet" value="10" min="1">
      <button class="bet-btn bet-double" onclick="adjustBet('limboBet',2)">2×</button>
      <button class="bet-btn" onclick="betAll('limboBet')" style="background:var(--gold);color:#000;font-weight:900;font-size:10px;">MAX</button>
    </div>
    <button class="action-btn primary" id="limboGoBtn" onclick="limboGo()">BET</button>
  </div>
  <div class="last-results" id="limboHistory"></div>
</div>

<!-- ============ VIDEO POKER ============ -->
<div class="game-panel" id="pokerPanel">
  <div class="htp-box"><button class="htp-toggle" onclick="htpToggle(this)"><span class="htp-arrow">▶</span> HOW TO PLAY</button><div class="htp-content"><ul><li>Set your <strong>bet</strong> and press <strong>DEAL</strong> to get 5 cards.</li><li>Click cards to <strong>hold</strong> the ones you want to keep.</li><li>Press <strong>DRAW</strong> to replace un-held cards.</li><li>Your final hand is evaluated — <strong>Jacks or Better</strong> wins.</li><li>Royal Flush pays <strong>250×</strong>, Straight Flush pays <strong>50×</strong>!</li></ul></div></div>
  <div class="poker-paytable">
    <span class="pt-h">Royal Flush</span><span class="pt-v">250×</span>
    <span class="pt-h">Straight Flush</span><span class="pt-v">50×</span>
    <span class="pt-h">4 of a Kind</span><span class="pt-v">25×</span>
    <span class="pt-h">Full House</span><span class="pt-v">9×</span>
    <span class="pt-h">Flush</span><span class="pt-v">6×</span>
    <span class="pt-h">Straight</span><span class="pt-v">4×</span>
    <span class="pt-h">3 of a Kind</span><span class="pt-v">3×</span>
    <span class="pt-h">Two Pair</span><span class="pt-v">2×</span>
    <span class="pt-h">Jacks+</span><span class="pt-v">1×</span>
  </div>
  <div class="poker-hand" id="pokerHand"></div>
  <div id="pokerResult"></div>
  <div style="display:flex;align-items:center;gap:10px;">
    <div class="bet-controls">
      <span style="color:var(--text2);font-size:12px;font-weight:600;">BET</span>
      <button class="bet-btn bet-half" onclick="adjustBet('pokerBet',0.5)">½</button>
      <input class="bet-input" type="number" id="pokerBet" value="10" min="1">
  
      <button class="bet-btn bet-double" onclick="adjustBet('pokerBet',2)">2×</button>
      <button class="bet-btn" onclick="betAll('pokerBet')" style="background:var(--gold);color:#000;font-weight:900;font-size:10px;">MAX</button>
    </div>
    <button class="action-btn primary" id="pokerDealBtn" onclick="pokerDeal()">DEAL</button>
    <button class="action-btn primary" id="pokerDrawBtn" onclick="pokerDrawCards()" style="display:none;background:linear-gradient(135deg,#cc8800,#996600);">DRAW</button>
  </div>
</div>

<!-- ============ HORSE RACING ============ -->
<div class="game-panel" id="horsesPanel">
  <div class="htp-box"><button class="htp-toggle" onclick="htpToggle(this)"><span class="htp-arrow">▶</span> HOW TO PLAY</button><div class="htp-content"><ul><li>Review the <strong>odds</strong> for each horse — lower odds = more likely to win.</li><li>Set your <strong>bet</strong> and click a horse to place your wager.</li><li>Watch the race — horses run at speeds influenced by their odds.</li><li>If your horse wins, you earn <strong>bet × horse odds</strong>.</li><li>Underdogs pay big but win less often!</li></ul></div></div>
  <div style="font-family:'Orbitron';font-size:16px;font-weight:700;color:var(--gold);">🏇 HORSE RACING</div>
  
  <div class="horse-track" id="horseTrack"></div>
  <div id="horseResult"></div>
  <div class="horse-bets" id="horseBets"></div>
  <div style="display:flex;align-items:center;gap:12px;">
    <div class="bet-controls">
      <span style="color:var(--text2);font-size:12px;font-weight:600;">BET</span>
      <button class="bet-btn bet-half" onclick="adjustBet('horseBet',0.5)">½</button>
      <input class="bet-input" type="number" id="horseBet" value="10" min="1">
      <button class="bet-btn bet-double" onclick="adjustBet('horseBet',2)">2×</button>
      <button class="bet-btn" onclick="betAll('horseBet')" style="background:var(--gold);color:#000;font-weight:900;font-size:10px;">MAX</button>
    </div>
    <button class="action-btn primary" id="horseRaceBtn" onclick="horseRace()">RACE!</button>
  </div>
</div>

<!-- ============ SCRATCH CARDS ============ -->
<div class="game-panel" id="scratchPanel">
  <div class="htp-box"><button class="htp-toggle" onclick="htpToggle(this)"><span class="htp-arrow">▶</span> HOW TO PLAY</button><div class="htp-content"><ul><li>Set your <strong>bet</strong> (card price) and press <strong>BUY CARD</strong>.</li><li>Scratch tiles by clicking them, or press <strong>SCRATCH ALL</strong> to reveal everything.</li><li>Match <strong>3 identical symbols</strong> to win that symbol's prize.</li><li>Match <strong>4 symbols</strong> for an even bigger payout!</li><li>Prizes range from 1× to 50× your bet depending on the symbol.</li></ul></div></div>
  <div style="font-family:'Orbitron';font-size:16px;font-weight:700;color:var(--gold);">🎫 SCRATCH CARDS</div>
  
  <div class="scratch-tiers">
    <div class="scratch-tier selected" onclick="scratchSelectTier(0,this)">$5 Basic</div>
    <div class="scratch-tier" onclick="scratchSelectTier(1,this)">$25 Silver</div>
    <div class="scratch-tier" onclick="scratchSelectTier(2,this)">$100 Gold</div>
    <div class="scratch-tier" onclick="scratchSelectTier(3,this)">$500 Diamond</div>
  </div>
  <div class="scratch-card"><div class="scratch-grid" id="scratchGrid"></div></div>
  <div id="scratchResult"></div>
  <button class="action-btn primary" id="scratchBuyBtn" onclick="scratchBuy()">BUY CARD — $5</button>
  <button class="action-btn primary" id="scratchRevealAllBtn" onclick="scratchRevealAll()" style="display:none;font-size:12px;padding:8px 16px;">SCRATCH ALL</button>
</div>

<!-- ============ WHEEL ============ -->
<div class="game-panel" id="wheelPanel">
  <div class="htp-box"><button class="htp-toggle" onclick="htpToggle(this)"><span class="htp-arrow">▶</span> HOW TO PLAY</button><div class="htp-content"><ul><li>Set your <strong>bet amount</strong>.</li><li>Press <strong>SPIN</strong> to spin the wheel.</li><li>The wheel has segments with different <strong>multipliers</strong>.</li><li>Where the wheel stops determines your payout.</li><li>Rare high-value segments can pay <strong>huge multipliers</strong>!</li></ul></div></div>
  <div class="wheel-wrap">
    <div class="wheel-ptr"></div>
    <canvas id="wheelCanvas" width="320" height="320"></canvas>
  </div>
  <div id="wheelResult"></div>
  
  <div style="display:flex;align-items:center;gap:12px;">
    <div class="bet-controls">
      <span style="color:var(--text2);font-size:12px;font-weight:600;">BET</span>
      <button class="bet-btn bet-half" onclick="adjustBet('wheelBet',0.5)">½</button>
      <input class="bet-input" type="number" id="wheelBet" value="10" min="1">
      <button class="bet-btn bet-double" onclick="adjustBet('wheelBet',2)">2×</button>
      <button class="bet-btn" onclick="betAll('wheelBet')" style="background:var(--gold);color:#000;font-weight:900;font-size:10px;">MAX</button>
    </div>
    <button class="action-btn primary" id="wheelSpinBtn" onclick="wheelSpin()">SPIN</button>
  </div>
</div>

<!-- ============ BACCARAT ============ -->
<div class="game-panel" id="baccaratPanel">
  <div class="htp-box"><button class="htp-toggle" onclick="htpToggle(this)"><span class="htp-arrow">▶</span> HOW TO PLAY</button><div class="htp-content"><ul><li>Choose to bet on <strong>Player</strong>, <strong>Banker</strong>, or <strong>Tie</strong>.</li><li>Set your <strong>bet</strong> and press <strong>DEAL</strong>.</li><li>Cards are dealt automatically — closest to <strong>9</strong> wins.</li><li>Player pays <strong>2×</strong>, Banker pays <strong>1.95×</strong>, Tie pays <strong>8×</strong>.</li><li>Face cards and 10s count as 0. Only the last digit of the total matters.</li></ul></div></div>
  <div class="bacc-table">
    <div class="bacc-hands">
      <div class="bacc-hand"><div class="bacc-hand-label">PLAYER</div><div class="bacc-cards" id="baccPlayerCards"></div><div class="bacc-hand-score" id="baccPlayerScore">—</div></div>
      <div class="bacc-hand"><div class="bacc-hand-label">BANKER</div><div class="bacc-cards" id="baccBankerCards"></div><div class="bacc-hand-score" id="baccBankerScore">—</div></div>
    </div>
  </div>
  <div id="baccResult"></div>
  <div class="last-results" id="baccHistory"></div>
  
  <div class="bacc-bets">
    <button class="bacc-bet" onclick="baccSelect('player',this)">Player (2×)</button>
    <button class="bacc-bet" onclick="baccSelect('tie',this)">Tie (8×)</button>
  <button class="bacc-bet" onclick="baccSelect('banker',this)">Banker (1.95×)</button>
  </div>
  <div style="display:flex;align-items:center;gap:12px;">
    <div class="bet-controls">
      <span style="color:var(--text2);font-size:12px;font-weight:600;">BET</span>
      <button class="bet-btn bet-half" onclick="adjustBet('baccBet',0.5)">½</button>
      <input class="bet-input" type="number" id="baccBet" value="10" min="1">
      <button class="bet-btn bet-double" onclick="adjustBet('baccBet',2)">2×</button>
      <button class="bet-btn" onclick="betAll('baccBet')" style="background:var(--gold);color:#000;font-weight:900;font-size:10px;">MAX</button>
    </div>
    <button class="action-btn primary" onclick="baccDeal()">DEAL</button>
  </div>
</div>

<!-- ============ HILO ============ -->
<div class="game-panel" id="hiloPanel">
  <div class="htp-box"><button class="htp-toggle" onclick="htpToggle(this)"><span class="htp-arrow">▶</span> HOW TO PLAY</button><div class="htp-content"><ul><li>Press <strong>START</strong> — a card is revealed.</li><li>Guess if the next card will be <strong>Higher</strong> or <strong>Lower</strong>.</li><li><strong>Ties (same rank) count as WRONG</strong> — the next card must be strictly higher or lower!</li><li>Each correct guess multiplies your winnings by 1.88×.</li><li>Press <strong>SKIP</strong> to swap the current card — but each skip costs <strong>10% of your payout</strong>.</li><li>Max multiplier is capped at <strong>500×</strong>.</li><li>Press <strong>CASH OUT</strong> anytime to collect, or risk it for more!</li></ul></div></div>
  <div id="hiloStreak">Start a game to begin!</div>
  
  <div class="hilo-card" id="hiloCard" style="color:#888;">?<br>?</div>
  <div id="hiloCashout"></div>
  <div class="hilo-actions">
    <button class="hilo-act-btn higher" onclick="hiloGuess('higher')" id="hiloHigherBtn" disabled>▲ HIGHER</button>
    <button class="hilo-act-btn skip-btn" onclick="hiloGuess('skip')" id="hiloSkipBtn" disabled>= SKIP</button>
    <button class="hilo-act-btn lower" onclick="hiloGuess('lower')" id="hiloLowerBtn" disabled>▼ LOWER</button>
  </div>
  <div style="display:flex;align-items:center;gap:10px;">
    <div class="bet-controls">
      <span style="color:var(--text2);font-size:12px;font-weight:600;">BET</span>
      <button class="bet-btn bet-half" onclick="adjustBet('hiloBet',0.5)">½</button>
      <input class="bet-input" type="number" id="hiloBet" value="10" min="1">
      <button class="bet-btn bet-double" onclick="adjustBet('hiloBet',2)">2×</button>
      <button class="bet-btn" onclick="betAll('hiloBet')" style="background:var(--gold);color:#000;font-weight:900;font-size:10px;">MAX</button>
    </div>
    <button class="action-btn primary" id="hiloStartBtn" onclick="hiloStart()">START</button>
    <button class="action-btn danger" id="hiloCashoutBtn" onclick="hiloCashout()" style="display:none;">CASH OUT</button>
  </div>
</div>

<!-- ============ BUCKSHOT ROULETTE ============ -->
<div class="game-panel" id="rusroulettePanel">
  <div class="htp-box"><button class="htp-toggle" onclick="htpToggle(this)"><span class="htp-arrow">▶</span> HOW TO PLAY</button><div class="htp-content"><ul>
    <li>Face the <strong>Dealer</strong> in a deadly shotgun standoff across multiple rounds.</li>
    <li>The shotgun is loaded with a mix of <strong style="color:#ff4444;">LIVE</strong> and <strong style="color:#4488ff;">BLANK</strong> shells — you can see the counts but not the order.</li>
    <li><strong>Shoot Dealer</strong>: LIVE = dealer takes damage, BLANK = turn passes.</li>
    <li><strong>Shoot Self</strong>: LIVE = you take damage, <strong style="color:#00e676;">BLANK = FREE EXTRA TURN!</strong></li>
    <li>Use <strong>items</strong> before shooting to gain an edge:<br>
      🔗 <em>Handcuffs</em> — Dealer skips next turn<br>
      🚬 <em>Cigarettes</em> — Heal +1 HP<br>
      🍬 <em>Rotten Gummy</em> — 40% chance +2 HP, 60% chance −1 HP<br>
      🪚 <em>Saw</em> — Next LIVE shell deals <strong>double damage</strong><br>
      📱 <em>Burner Phone</em> — Reveals a random upcoming shell<br>
      🔍 <em>Magnifying Glass</em> — Peek at the current shell
    </li>
    <li>Difficulty sets rounds, HP, items, and your <strong>payout multiplier</strong>.</li>
    <li>Beat all rounds to win <strong>Bet × Multiplier</strong>. Die and you lose your bet.</li>
  </ul></div></div>

  <div class="bsr-title">🔫 BUCKSHOT ROULETTE</div>
  <div class="bsr-subtitle">Man vs. Machine. One shotgun. Who walks away?</div>

  <!-- LOBBY -->
  <div id="bsrLobby" class="bsr-lobby">
    <!-- Difficulty select -->
    <div style="font-family:'Orbitron';font-size:11px;color:var(--text2);letter-spacing:2px;margin-bottom:6px;">CHOOSE DIFFICULTY</div>
    <div class="bsr-difficulty">
      <div class="bsr-diff-card" onclick="bsrSelectDiff('easy',this)">
        <div class="diff-icon">😎</div>
        <div class="diff-name">EASY</div>
        <div class="diff-desc">2 rounds · 5 HP · 4 items</div>
        <div class="diff-mult">2.5×</div>
      </div>
      <div class="bsr-diff-card selected" onclick="bsrSelectDiff('normal',this)">
        <div class="diff-icon">💀</div>
        <div class="diff-name">NORMAL</div>
        <div class="diff-desc">3 rounds · 4 HP · 3 items</div>
        <div class="diff-mult">4×</div>
      </div>
      <div class="bsr-diff-card" onclick="bsrSelectDiff('hard',this)">
        <div class="diff-icon">☠️</div>
        <div class="diff-name">HARD</div>
        <div class="diff-desc">4 rounds · 3 HP · 2 items</div>
        <div class="diff-mult">7×</div>
      </div>
    </div>
    <!-- Bet -->
    <div style="display:flex;gap:8px;align-items:center;justify-content:center;margin-top:16px;">
      <div class="bet-controls">
        <span style="color:var(--text2);font-size:12px;font-weight:600;">BET</span>
        <button class="bet-btn bet-half" onclick="adjustBet('bsrBet',0.5)">½</button>
        <input class="bet-input" type="number" id="bsrBet" value="100" min="10">
        <button class="bet-btn bet-double" onclick="adjustBet('bsrBet',2)">2×</button>
        <button class="bet-btn" onclick="betAll('bsrBet')" style="background:var(--gold);color:#000;font-weight:900;font-size:10px;">MAX</button>
      </div>
      <button class="action-btn primary" onclick="bsrStartGame()" style="padding:12px 28px;font-size:15px;font-family:'Orbitron';letter-spacing:1px;">⚔️ PLAY</button>
    </div>
    <!-- Stats -->
    <div id="bsrStats" style="display:flex;gap:12px;justify-content:center;margin-top:14px;font-size:11px;color:var(--text2);">
      <span>Win rate: <span id="bsrStatWinRate" style="color:var(--green);font-weight:700;">--</span></span>
      <span>Biggest win: <span id="bsrStatBigWin" style="color:var(--gold);font-weight:700;">--</span></span>
      <span>Streak: <span id="bsrStatStreak" style="color:var(--neon);font-weight:700;">0</span></span>
    </div>
  </div>

  <!-- GAME AREA -->
  <div id="bsrGame" class="bsr-game" style="display:none;">
    <!-- Top bar: round + multiplier -->
    <div class="bsr-top-bar">
      <div class="bsr-round-badge" id="bsrRoundInfo">ROUND 1/3</div>
      <div class="bsr-multiplier" id="bsrMultiplier">4× PAYOUT</div>
      <div class="bsr-shell-count" id="bsrShellInfo">5 shells</div>
    </div>

    <!-- Shell rack -->
    <div class="bsr-rack" id="bsrShellRack"></div>

    <!-- Table area with shotgun -->
    <div class="bsr-table">
      <!-- Combatants -->
      <div class="bsr-combatants">
        <div class="bsr-fighter" id="bsrPlayerCard">
          <div class="bsr-fighter-label" style="color:var(--neon);">🧑 YOU</div>
          <div class="bsr-hp-text" id="bsrPlayerHP" style="color:var(--green);">4 HP</div>
          <div class="bsr-hp-bar"><div class="bsr-hp-fill" id="bsrPlayerHPBar" style="width:100%;background:linear-gradient(90deg,var(--green),#66ff99);"></div></div>
          <div class="bsr-hearts" id="bsrPlayerHearts">❤️❤️❤️❤️</div>
        </div>
        <div class="bsr-vs">VS</div>
        <div class="bsr-fighter" id="bsrDealerCard">
          <div class="bsr-fighter-label" style="color:var(--red);">🤖 DEALER</div>
          <div class="bsr-hp-text" id="bsrDealerHP" style="color:var(--red);">4 HP</div>
          <div class="bsr-hp-bar"><div class="bsr-hp-fill" id="bsrDealerHPBar" style="width:100%;background:linear-gradient(90deg,#ff4444,#ff8888);"></div></div>
          <div class="bsr-hearts" id="bsrDealerHearts">❤️❤️❤️❤️</div>
        </div>
      </div>

      <!-- Shotgun visual -->
      <div class="bsr-shotgun">
        <div class="bsr-shotgun-img" id="bsrShotgun">🔫</div>
      </div>

      <!-- Status -->
      <div class="bsr-status" id="bsrStatus">Your turn — choose wisely.</div>

      <!-- Actions -->
      <div class="bsr-actions">
        <button class="bsr-shoot-btn bsr-shoot-dealer" id="bsrShootDealer" onclick="bsrShoot('dealer')">🔫 SHOOT DEALER</button>
        <button class="bsr-shoot-btn bsr-shoot-self" id="bsrShootSelf" onclick="bsrShoot('self')">🫵 SHOOT SELF</button>
      </div>
    </div>

    <!-- Items section -->
    <div class="bsr-items-section">
      <div class="bsr-items-label">YOUR ITEMS</div>
      <div class="bsr-items" id="bsrItems"></div>
      <div class="bsr-items-label" style="margin-top:10px;color:rgba(255,68,68,.5);">DEALER'S ITEMS</div>
      <div class="bsr-dealer-items" id="bsrDealerItemsDisplay"></div>
    </div>

    <!-- Log -->
    <div class="bsr-log" id="bsrLog"></div>
  </div>

  <!-- ROUND TRANSITION SPLASH -->
  <div id="bsrRoundSplash" class="bsr-round-splash" style="display:none;">
    <div class="bsr-round-splash-text" id="bsrRoundSplashText">ROUND 2</div>
  </div>

  <!-- GAME OVER -->
  <div id="bsrGameOver" class="bsr-gameover">
    <div class="bsr-gameover-box" id="bsrGameOverContent"></div>
  </div>
</div>

<!-- ============ RUSSIAN ROULETTE ============ -->
<div class="game-panel" id="russianrPanel" style="padding-top:60px!important;">
  <div class="htp-box"><button class="htp-toggle" onclick="htpToggle(this)"><span class="htp-arrow">▶</span> HOW TO PLAY</button><div class="htp-content"><ul>
    <li>6-chamber revolver, <strong>1 bullet</strong>. Take turns pulling the trigger.</li>
    <li><strong>Pull Trigger</strong>: 1-in-6 chance (decreasing chambers) of death.</li>
    <li><strong>Spin Cylinder</strong>: Reset to 1-in-6 (uses your turn).</li>
    <li>Survive all rounds and the opponent dies? <strong>You win the pot!</strong></li>
    <li><strong>Bot mode</strong>: Play against the Dealer AI. <strong>PvP</strong>: Challenge a real player live.</li>
    <li>Higher difficulty = more rounds, bigger multiplier.</li>
  </ul></div></div>

  <div style="text-align:center;margin-bottom:14px;">
    <span style="font-family:'Orbitron';font-size:26px;font-weight:900;background:linear-gradient(135deg,#ff4444,#ff8800);-webkit-background-clip:text;-webkit-text-fill-color:transparent;">🎰 RUSSIAN ROULETTE</span>
    <div style="font-size:11px;color:var(--text2);margin-top:4px;">One bullet. Six chambers. Who survives?</div>
  </div>

  <!-- MODE TABS -->
  <div style="display:flex;gap:6px;justify-content:center;margin-bottom:14px;">
    <button class="inv-tab active" id="rrBotTab" onclick="rrSwitchMode('bot',this)" style="border-color:rgba(255,68,68,.3);color:#ff4444;">🤖 vs Bot</button>
    <button class="inv-tab" id="rrPvpTab" onclick="rrSwitchMode('pvp',this)" style="border-color:rgba(0,240,255,.3);color:var(--neon);">👥 PvP</button>
  </div>

  <!-- BOT LOBBY -->
  <div id="rrBotLobby">
    <div style="display:flex;gap:8px;justify-content:center;margin-bottom:10px;">
      <div class="bsr-diff-card selected" onclick="rrSelectDiff('easy',this)" style="padding:10px 14px;min-width:90px;">
        <div class="diff-icon">😎</div><div class="diff-name">EASY</div><div class="diff-desc">3 rounds</div><div class="diff-mult">2×</div>
      </div>
      <div class="bsr-diff-card" onclick="rrSelectDiff('normal',this)" style="padding:10px 14px;min-width:90px;">
        <div class="diff-icon">💀</div><div class="diff-name">NORMAL</div><div class="diff-desc">5 rounds</div><div class="diff-mult">4×</div>
      </div>
      <div class="bsr-diff-card" onclick="rrSelectDiff('hard',this)" style="padding:10px 14px;min-width:90px;">
        <div class="diff-icon">☠️</div><div class="diff-name">HARD</div><div class="diff-desc">8 rounds</div><div class="diff-mult">8×</div>
      </div>
    </div>
    <div style="display:flex;gap:8px;align-items:center;justify-content:center;margin-top:10px;">
      <div class="bet-controls">
        <span style="color:var(--text2);font-size:12px;font-weight:600;">BET</span>
        <button class="bet-btn bet-half" onclick="adjustBet('rrBet',0.5)">½</button>
        <input class="bet-input" type="number" id="rrBet" value="100" min="10">
        <button class="bet-btn bet-double" onclick="adjustBet('rrBet',2)">2×</button>
        <button class="bet-btn" onclick="betAll('rrBet')" style="background:var(--gold);color:#000;font-weight:900;font-size:10px;">MAX</button>
      </div>
      <button class="action-btn primary" onclick="rrStartBot()" style="padding:12px 28px;font-size:15px;font-family:'Orbitron';">⚔️ PLAY</button>
    </div>
  </div>

  <!-- PVP LOBBY -->
  <div id="rrPvpLobby" style="display:none;text-align:center;">
    <div style="font-size:13px;color:var(--text2);margin-bottom:12px;">Challenge another player — loser loses their bet!</div>
    <div style="display:flex;gap:8px;align-items:center;justify-content:center;margin-bottom:12px;">
      <div class="bet-controls">
        <span style="color:var(--text2);font-size:12px;font-weight:600;">WAGER</span>
        <button class="bet-btn bet-half" onclick="adjustBet('rrPvpBet',0.5)">½</button>
        <input class="bet-input" type="number" id="rrPvpBet" value="100" min="10">
        <button class="bet-btn bet-double" onclick="adjustBet('rrPvpBet',2)">2×</button>
        <button class="bet-btn" onclick="betAll('rrPvpBet')" style="background:var(--gold);color:#000;font-weight:900;font-size:10px;">MAX</button>
      </div>
    </div>
    <input type="text" id="rrPvpOpponent" placeholder="Enter opponent username..." maxlength="16" autocomplete="off" style="width:90%;max-width:300px;padding:10px 14px;background:var(--bg);border:2px solid var(--border);border-radius:10px;color:var(--text);font-size:14px;text-align:center;margin-bottom:10px;">
    <br>
    <button class="action-btn primary" onclick="rrStartPvP()" style="padding:12px 28px;font-size:15px;font-family:'Orbitron';">🎯 CHALLENGE</button>
    <div id="rrPvpStatus" style="font-size:12px;color:var(--text2);margin-top:8px;min-height:20px;"></div>
  </div>

  <!-- GAME AREA -->
  <div id="rrGameArea" style="display:none;max-width:500px;margin:0 auto;">
    <!-- Revolver visual -->
    <div style="text-align:center;margin-bottom:16px;">
      <div id="rrRevolver" style="font-size:90px;transition:transform .3s;filter:drop-shadow(0 0 20px rgba(255,68,68,.3));">🔫</div>
      <div id="rrChamberInfo" style="font-family:'Orbitron';font-size:12px;color:var(--text2);margin-top:6px;letter-spacing:2px;"></div>
    </div>
    <!-- Round info -->
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:12px;">
      <div id="rrRoundInfo" style="font-family:'Orbitron';font-size:14px;color:var(--gold);letter-spacing:1px;"></div>
      <div id="rrMultInfo" style="font-family:'Orbitron';font-size:14px;color:var(--green);"></div>
    </div>
    <!-- Players -->
    <div style="display:grid;grid-template-columns:1fr auto 1fr;gap:10px;align-items:center;margin-bottom:14px;">
      <div id="rrPlayerCard" style="background:var(--surface);border:1px solid var(--border);border-radius:12px;padding:14px;text-align:center;transition:all .3s;">
        <div style="font-family:'Orbitron';font-size:11px;color:var(--neon);letter-spacing:2px;margin-bottom:6px;">🧑 YOU</div>
        <div id="rrPlayerStatus" style="font-size:22px;">😐</div>
        <div id="rrPlayerAlive" style="font-size:11px;color:var(--green);margin-top:4px;">ALIVE</div>
      </div>
      <div style="font-family:'Orbitron';font-size:16px;color:var(--text2);">VS</div>
      <div id="rrDealerCard" style="background:var(--surface);border:1px solid var(--border);border-radius:12px;padding:14px;text-align:center;transition:all .3s;">
        <div style="font-family:'Orbitron';font-size:11px;color:var(--red);letter-spacing:2px;margin-bottom:6px;" id="rrOpponentLabel">🤖 DEALER</div>
        <div id="rrDealerStatus" style="font-size:22px;">😐</div>
        <div id="rrDealerAlive" style="font-size:11px;color:var(--green);margin-top:4px;">ALIVE</div>
      </div>
    </div>
    <!-- Status -->
    <div id="rrStatusMsg" style="text-align:center;font-size:15px;color:var(--gold);font-weight:700;min-height:24px;margin-bottom:12px;font-family:'Orbitron';"></div>
    <!-- Actions -->
    <div id="rrActions" style="display:flex;gap:12px;justify-content:center;margin-bottom:14px;">
      <button class="bsr-shoot-btn bsr-shoot-dealer" id="rrPullBtn" onclick="rrPullTrigger()" style="flex:1;max-width:200px;">💀 PULL TRIGGER</button>
      <button class="bsr-shoot-btn bsr-shoot-self" id="rrSpinBtn" onclick="rrSpinCylinder()" style="flex:1;max-width:200px;">🔄 SPIN CYLINDER</button>
    </div>
    <!-- Log -->
    <div id="rrLog" class="bsr-log" style="max-height:120px;"></div>
  </div>

  <!-- GAME OVER -->
  <div id="rrGameOver" class="bsr-gameover">
    <div class="bsr-gameover-box" id="rrGameOverContent"></div>
  </div>
</div>
MULTIPLAYER BUCKSHOT ROULETTE ============ -->
<div class="game-panel" id="mpbsrPanel" style="padding-top:60px!important;">
  <div class="htp-box"><button class="htp-toggle" onclick="htpToggle(this)"><span class="htp-arrow">▶</span> HOW TO PLAY</button><div class="htp-content"><ul>
    <li>PvP Buckshot Roulette — challenge a real player!</li>
    <li>Both players start with <strong>4 HP</strong>. Shotgun loaded with LIVE & BLANK shells.</li>
    <li>On your turn: <strong>Shoot Opponent</strong> or <strong>Shoot Self</strong> (blank self = bonus turn).</li>
    <li>Use <strong>items</strong> strategically: Saw (2× damage), Magnifying Glass (peek shell), Cigarette (+1 HP), Handcuffs (skip turn).</li>
    <li>Winner takes the full pot (both bets)!</li>
  </ul></div></div>

  <div style="text-align:center;margin-bottom:14px;">
    <span style="font-family:'Orbitron';font-size:24px;font-weight:900;background:linear-gradient(135deg,#ff4444,#ff8800);-webkit-background-clip:text;-webkit-text-fill-color:transparent;">💥 MULTIPLAYER BUCKSHOT</span>
    <div style="font-size:11px;color:var(--text2);margin-top:4px;">PvP Shotgun Standoff — Who walks away?</div>
  </div>

  <!-- LOBBY -->
  <div id="mpbsrLobby">
    <div style="text-align:center;margin-bottom:12px;">
      <div style="font-size:13px;color:var(--text2);margin-bottom:12px;">Challenge another player to a live Buckshot Roulette match!</div>
      <div style="display:flex;gap:8px;align-items:center;justify-content:center;margin-bottom:12px;">
        <div class="bet-controls">
          <span style="color:var(--text2);font-size:12px;font-weight:600;">WAGER</span>
          <button class="bet-btn bet-half" onclick="adjustBet('mpbsrBet',0.5)">½</button>
          <input class="bet-input" type="number" id="mpbsrBet" value="100" min="10">
          <button class="bet-btn bet-double" onclick="adjustBet('mpbsrBet',2)">2×</button>
          <button class="bet-btn" onclick="betAll('mpbsrBet')" style="background:var(--gold);color:#000;font-weight:900;font-size:10px;">MAX</button>
        </div>
      </div>
      <input type="text" id="mpbsrOpponent" placeholder="Enter opponent username..." maxlength="16" autocomplete="off" style="width:90%;max-width:300px;padding:10px 14px;background:var(--bg);border:2px solid var(--border);border-radius:10px;color:var(--text);font-size:14px;text-align:center;margin-bottom:10px;">
      <br>
      <button class="action-btn primary" onclick="mpbsrChallenge()" style="padding:12px 28px;font-size:15px;font-family:'Orbitron';">⚔️ CHALLENGE</button>
      <div id="mpbsrStatus" style="font-size:12px;color:var(--text2);margin-top:8px;min-height:20px;"></div>
    </div>
  </div>

  <!-- GAME AREA -->
  <div id="mpbsrGameArea" style="display:none;max-width:500px;margin:0 auto;">
    <!-- Top bar -->
    <div class="bsr-top-bar">
      <div class="bsr-round-badge" id="mpbsrRoundInfo">ROUND 1</div>
      <div class="bsr-multiplier" id="mpbsrPotInfo">POT: $0</div>
      <div class="bsr-shell-count" id="mpbsrShellInfo">0 shells</div>
    </div>
    <!-- Shell rack -->
    <div class="bsr-rack" id="mpbsrShellRack"></div>
    <!-- Players -->
    <div style="display:grid;grid-template-columns:1fr auto 1fr;gap:10px;align-items:start;margin:14px 0;">
      <div id="mpbsrMyCard" class="bsr-player-card">
        <div class="bsr-player-label" style="color:var(--neon);">YOU</div>
        <div class="bsr-hp" id="mpbsrMyHP"></div>
        <div class="bsr-items" id="mpbsrMyItems"></div>
      </div>
      <div style="font-family:'Orbitron';font-size:16px;color:var(--text2);align-self:center;">VS</div>
      <div id="mpbsrOpCard" class="bsr-player-card">
        <div class="bsr-player-label" style="color:var(--red);" id="mpbsrOpLabel">OPPONENT</div>
        <div class="bsr-hp" id="mpbsrOpHP"></div>
        <div class="bsr-items" id="mpbsrOpItems"></div>
      </div>
    </div>
    <!-- Status -->
    <div id="mpbsrStatusMsg" class="bsr-status"></div>
    <!-- Actions -->
    <div id="mpbsrActions" style="display:flex;gap:10px;justify-content:center;margin:12px 0;">
      <button class="bsr-shoot-btn bsr-shoot-dealer" id="mpbsrShootOp" onclick="mpbsrShoot('opponent')">🔫 SHOOT OPPONENT</button>
      <button class="bsr-shoot-btn bsr-shoot-self" id="mpbsrShootSelf" onclick="mpbsrShoot('self')">🤕 SHOOT SELF</button>
    </div>
    <!-- Log -->
    <div id="mpbsrLog" class="bsr-log" style="max-height:120px;"></div>
  </div>

  <!-- GAME OVER -->
  <div id="mpbsrGameOver" class="bsr-gameover">
    <div class="bsr-gameover-box" id="mpbsrGameOverContent"></div>
  </div>
</div>

<!-- ============ 
<!-- ============ DUELS PANEL ============ -->
<div class="game-panel" id="duelsPanel">
  <div class="duel-lobby">
    <div style="text-align:center;margin-bottom:12px;">
      <span style="font-family:'Orbitron';font-size:24px;font-weight:900;background:linear-gradient(135deg,var(--gold),#ff4444);-webkit-background-clip:text;-webkit-text-fill-color:transparent;">⚔️ COINFLIP DUELS</span>
      <div style="font-size:11px;color:var(--text2);margin-top:4px;">Challenge other players! Winner takes all.</div>
    </div>
    <!-- Create Duel -->
    <div class="duel-create-box">
      <div style="font-family:'Orbitron';font-size:12px;color:var(--text2);letter-spacing:2px;margin-bottom:8px;">CREATE A DUEL</div>
      <input id="duelWagerInput" type="number" min="10" value="100" placeholder="Wager">
      <br>
      <button class="duel-create-btn" onclick="duelCreate()">⚔️ CREATE DUEL</button>
    </div>
    <!-- Active Duels List -->
    <div style="font-family:'Orbitron';font-size:12px;color:var(--text2);letter-spacing:2px;margin-bottom:8px;">OPEN DUELS</div>
    <div id="duelList" style="min-height:60px;">
      <div style="text-align:center;color:var(--text2);font-size:12px;padding:20px;">No open duels. Create one!</div>
    </div>
    <!-- Duel History -->
    <div class="duel-history">
      <div style="font-family:'Orbitron';font-size:12px;color:var(--text2);letter-spacing:2px;margin-bottom:8px;">RECENT DUELS</div>
      <div id="duelHistory"></div>
    </div>
  </div>
  <!-- Duel Game Overlay -->
  <div id="duelGameOverlay" style="display:none;position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(4,8,20,.97);z-index:10003;align-items:center;justify-content:center;">
    <div id="duelFlash" class="duel-flash"></div>
    <div id="duelInner" style="text-align:center;max-width:560px;width:92vw;">
      <div id="duelWagerText" style="font-family:'Orbitron';font-size:18px;color:var(--gold);margin-bottom:16px;letter-spacing:3px;"></div>
      <div style="display:flex;align-items:center;justify-content:center;gap:28px;margin-bottom:20px;">
        <div class="duel-player">
          <div style="font-size:40px;margin-bottom:4px;">🟡</div>
          <div class="duel-player-name" id="duelP1Name">Player 1</div>
          <div class="duel-player-bet">HEADS</div>
        </div>
        <div class="duel-vs" id="duelVsText">VS</div>
        <div class="duel-player">
          <div style="font-size:40px;margin-bottom:4px;">⚫</div>
          <div class="duel-player-name" id="duelP2Name">Player 2</div>
          <div class="duel-player-bet">TAILS</div>
        </div>
      </div>
      <div id="duelCoinArea" style="min-height:140px;margin:20px 0;display:flex;align-items:center;justify-content:center;">
        <div id="duelCountdown" class="duel-countdown" style="display:none;"></div>
        <div class="duel-coin-wrapper">
          <div class="duel-coin" id="duelCoin" style="display:none;">
            <div class="coin-face coin-heads">H</div>
            <div class="coin-face coin-tails">T</div>
          </div>
        </div>
      </div>
      <div class="duel-tension-bar" id="duelTensionBar" style="display:none;"><div class="duel-tension-fill" id="duelTensionFill" style="width:0%;"></div></div>
      <div id="duelStatusText" style="font-family:'Orbitron';font-size:11px;color:var(--text2);letter-spacing:2px;margin:8px 0;"></div>
      <div id="duelResultText" class="duel-result" style="display:none;"></div>
      <button id="duelCloseBtn" onclick="duelCloseOverlay()" style="display:none;padding:10px 24px;background:var(--surface2);border:1px solid var(--border);border-radius:8px;color:var(--text);cursor:pointer;font-family:'Orbitron';font-size:12px;margin-top:12px;">CLOSE</button>
    </div>
  </div>
</div>

<!-- ============ LEADERBOARD PANEL ============ -->
<div class="game-panel" id="leaderboardPanel">
  <div class="lb-container">
    <div style="text-align:center;margin-bottom:8px;">
      <span style="font-family:'Orbitron';font-size:24px;font-weight:900;background:linear-gradient(135deg,var(--gold),#ff8800);-webkit-background-clip:text;-webkit-text-fill-color:transparent;">🏆 LEADERBOARDS</span>
    </div>
    <div class="lb-tabs" style="flex-wrap:wrap;">
      <button class="lb-tab active" onclick="switchLB('richest',this)">💰 Richest</button>
      <button class="lb-tab" onclick="switchLB('profit',this)">📊 Profit</button>
      <button class="lb-tab" onclick="switchLB('slots',this)">🎰 Slots</button>
      <button class="lb-tab" onclick="switchLB('crash',this)">📈 Crash</button>
      <button class="lb-tab" onclick="switchLB('roulette',this)">🎡 Roulette</button>
      <button class="lb-tab" onclick="switchLB('blackjack',this)">🃏 BJ</button>
      <button class="lb-tab" onclick="switchLB('cases',this)">📦 Cases</button>
      <button class="lb-tab" onclick="switchLB('plinko',this)">⚡ Plinko</button>
      <button class="lb-tab" onclick="switchLB('mines',this)">💣 Mines</button>
      <button class="lb-tab" onclick="switchLB('dice',this)">🎲 Dice</button>
      <button class="lb-tab" onclick="switchLB('tower',this)">🗼 Tower</button>
      <button class="lb-tab" onclick="switchLB('coinflip',this)">🪙 Flip</button>
      <button class="lb-tab" onclick="switchLB('keno',this)">🔢 Keno</button>
      <button class="lb-tab" onclick="switchLB('limbo',this)">🎯 Limbo</button>
      <button class="lb-tab" onclick="switchLB('poker',this)">♠️ Poker</button>
      <button class="lb-tab" onclick="switchLB('horses',this)">🐎 Horses</button>
      <button class="lb-tab" onclick="switchLB('scratch',this)">🎫 Scratch</button>
      <button class="lb-tab" onclick="switchLB('wheel',this)">🎡 Wheel</button>
      <button class="lb-tab" onclick="switchLB('baccarat',this)">🂡 Baccarat</button>
      <button class="lb-tab" onclick="switchLB('hilo',this)">⬆️ Hi-Lo</button>
      <button class="lb-tab" onclick="switchLB('pyl',this)">🍀 Luck</button>
      <button class="lb-tab" onclick="switchLB('duels',this)">⚔️ Duels</button>
      <button class="lb-tab" onclick="switchLB('prestige',this)">👑 Prestige</button>
    </div>
    <div class="lb-table" id="lbTable">
      <div class="lb-empty">Loading...</div>
    </div>
  </div>
</div>

<!-- ============ PROFILE PANEL ============ -->
<div class="game-panel" id="profilePanel">
  <div style="max-width:600px;margin:0 auto;padding:20px;">
    <div style="text-align:center;margin-bottom:16px;">
      <div style="font-size:48px;margin-bottom:8px;cursor:pointer;" id="profileAvatar" onclick="openPfpPicker()" title="Click to change avatar">👤</div>
      <button onclick="openPfpPicker()" style="background:transparent;border:1px solid var(--border);border-radius:6px;padding:4px 12px;color:var(--text2);font-size:10px;cursor:pointer;margin-bottom:6px;font-family:Inter,sans-serif;">✏️ Change Avatar</button>
      <input type="file" id="pfpFileInput" accept="image/*" style="display:none;" onchange="handlePfpUpload(this)">
      <div style="font-family:'Orbitron';font-size:22px;font-weight:900;color:var(--gold);letter-spacing:3px;" id="profileName">PLAYER</div>
      <div id="profilePrestigeBadge" style="margin-top:4px;"></div>
      <div style="font-size:11px;color:var(--text2);letter-spacing:2px;margin-top:4px;" id="profileJoined"></div>
    </div>
    <!-- PFP Picker Modal -->
    <div id="pfpPickerOverlay" style="display:none;position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,.7);z-index:10001;align-items:center;justify-content:center;">
      <div style="background:var(--surface);border:2px solid var(--gold);border-radius:16px;padding:20px;max-width:380px;width:90vw;max-height:70vh;overflow-y:auto;">
```
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:12px;">
          <span style="font-family:'Orbitron';font-size:14px;color:var(--gold);">CHOOSE AVATAR</span>
          <button onclick="closePfpPicker()" style="background:none;border:none;color:var(--text);font-size:18px;cursor:pointer;">✕</button>
        </div>
        <div id="pfpGrid" style="display:grid;grid-template-columns:repeat(5,1fr);gap:8px;"></div>
      </div>
    </div>
    <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:16px;">
      <div style="background:var(--surface);border:1px solid var(--border);border-radius:8px;padding:12px;text-align:center;">
        <div style="font-size:10px;color:var(--text2);letter-spacing:2px;">BALANCE</div>
        <div style="font-family:'Orbitron';font-size:18px;color:var(--gold);margin-top:4px;" id="profBalance">$0</div>
      </div>
      <div style="background:var(--surface);border:1px solid var(--border);border-radius:8px;padding:12px;text-align:center;">
        <div style="font-size:10px;color:var(--text2);letter-spacing:2px;">GAMES</div>
        <div style="font-family:'Orbitron';font-size:18px;color:var(--text);margin-top:4px;" id="profGames">0</div>
      </div>
      <div style="background:var(--surface);border:1px solid var(--border);border-radius:8px;padding:12px;text-align:center;">
        <div style="font-size:10px;color:var(--text2);letter-spacing:2px;">PROFIT</div>
        <div style="font-family:'Orbitron';font-size:18px;margin-top:4px;" id="profProfit">$0</div>
      </div>
    </div>
    <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-bottom:16px;">
      <div style="background:var(--surface);border:1px solid var(--border);border-radius:8px;padding:12px;text-align:center;">
        <div style="font-size:10px;color:var(--text2);letter-spacing:2px;">WAGERED</div>
        <div style="font-family:'Orbitron';font-size:14px;color:var(--text);margin-top:4px;" id="profWagered">$0</div>
      </div>
      <div style="background:var(--surface);border:1px solid var(--border);border-radius:8px;padding:12px;text-align:center;">
        <div style="font-size:10px;color:var(--text2);letter-spacing:2px;">BIGGEST WIN</div>
        <div style="font-family:'Orbitron';font-size:14px;color:var(--green);margin-top:4px;" id="profBiggest">$0</div>
      </div>
    </div>
    <div style="margin-bottom:16px;">
      <div style="font-family:'Orbitron';font-size:13px;color:var(--gold);letter-spacing:2px;margin-bottom:8px;">🏆 ACHIEVEMENTS <span id="casinoAchCount" style="color:var(--text2);font-size:10px;"></span></div>
      <div id="casinoAchGrid" style="display:grid;grid-template-columns:repeat(auto-fill,minmax(200px,1fr));gap:6px;"></div>
    </div>
    <div style="margin-bottom:16px;">
      <div style="font-family:'Orbitron';font-size:13px;color:var(--gold);letter-spacing:2px;margin-bottom:8px;">🎮 GAME STATS</div>
      <div id="profGameStats" style="display:grid;grid-template-columns:repeat(auto-fill,minmax(150px,1fr));gap:6px;"></div>
    </div>
    <div style="margin-bottom:16px;">
      <div style="font-family:'Orbitron';font-size:13px;color:var(--gold);letter-spacing:2px;margin-bottom:8px;">📦 INVENTORY VALUE</div>
      <div id="profInvValue" style="font-family:'Orbitron';font-size:20px;color:var(--green);">$0</div>
    </div>
    <!-- Prestige Section -->
    <div style="margin-bottom:16px;padding:16px;background:linear-gradient(135deg,rgba(255,215,0,.05),rgba(255,136,0,.05));border:1px solid rgba(255,215,0,.2);border-radius:12px;text-align:center;">
      <div style="font-family:'Orbitron';font-size:13px;color:var(--gold);letter-spacing:2px;margin-bottom:8px;">👑 PRESTIGE</div>
      <div style="font-family:'Orbitron';font-size:28px;color:var(--gold);margin-bottom:4px;" id="profPrestigeLevel">0</div>
      <div style="font-size:10px;color:var(--text2);margin-bottom:8px;">Reset your balance to $1,000 and earn a prestige rank.<br>Higher prestige = exclusive badges in chat & leaderboards.</div>
      <div style="font-size:10px;color:var(--text2);margin-bottom:10px;" id="prestigeReqText"></div>
      <button class="prestige-btn" onclick="prestigeConfirm()" id="prestigeBtn">👑 PRESTIGE UP</button>
    </div>
    <!-- Admin Panel (mojheh only) -->
    <div id="adminPanel" style="display:none;margin-top:16px;padding:16px;background:linear-gradient(135deg,rgba(255,0,0,.05),rgba(255,136,0,.05));border:2px solid rgba(255,0,0,.3);border-radius:12px;text-align:center;">
      <div style="font-family:'Orbitron';font-size:13px;color:var(--red);letter-spacing:2px;margin-bottom:12px;">⚙️ ADMIN PANEL</div>
      <div style="background:var(--bg);border:1px solid var(--border);border-radius:8px;padding:12px;margin-bottom:12px;">
        <div style="font-size:10px;color:var(--text2);letter-spacing:1px;margin-bottom:8px;">GIVE MONEY TO PLAYER</div>
        <div style="display:flex;gap:6px;">
          <input type="text" id="adminUsername" placeholder="Username" style="flex:1;padding:8px 10px;background:var(--surface);border:1px solid var(--border);border-radius:6px;color:var(--text);font-size:11px;">
          <input type="number" id="adminAmount" placeholder="Amount" style="width:120px;padding:8px 10px;background:var(--surface);border:1px solid var(--border);border-radius:6px;color:var(--text);font-size:11px;">
          <button onclick="adminGiveMoney()" style="padding:8px 12px;background:linear-gradient(135deg,#ff6600,#ff3300);border:none;border-radius:6px;color:#fff;cursor:pointer;font-weight:700;font-size:11px;">GIVE</button>
        </div>
      </div>
      <div style="background:var(--bg);border:1px solid var(--border);border-radius:8px;padding:12px;">
        <div style="font-size:10px;color:var(--text2);letter-spacing:1px;margin-bottom:8px;">SET OWN BALANCE</div>
        <div style="display:flex;gap:6px;">
          <input type="number" id="adminSelfBalance" placeholder="New balance" style="flex:1;padding:8px 10px;background:var(--surface);border:1px solid var(--border);border-radius:6px;color:var(--text);font-size:11px;">
          <button onclick="adminSetSelfBalance()" style="padding:8px 12px;background:linear-gradient(135deg,#ff9900,#ff6600);border:none;border-radius:6px;color:#fff;cursor:pointer;font-weight:700;font-size:11px;">SET</button>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- ============ INVENTORY OVERLAY ============ -->
<div id="inventoryOverlay">
  <div class="inv-header">
    <div class="inv-title">INVENTORY</div>
    <div style="display:flex;gap:8px;align-items:center;">
      <div style="font-family:'Orbitron';font-size:14px;color:var(--gold);">Portfolio: $<span id="invTotalValue">0</span></div>
      <button class="inv-close" onclick="hideInventory()">CLOSE</button>
    </div>
  </div>
  <div class="market-stats">
    <div class="market-stat"><div class="ms-label">Items Owned</div><div class="ms-val" id="invCount">0</div></div>
    <div class="market-stat"><div class="ms-label">Rarest Item</div><div class="ms-val" id="invRarest">—</div></div>
    <div class="market-stat"><div class="ms-label">Market Trend</div><div class="ms-val" id="invTrend">—</div></div>
  </div>
  <div class="inv-tabs">
    <button class="inv-tab active" onclick="filterInventory('all',this)">All</button>
    <button class="inv-tab" onclick="filterInventory('legendary',this)">★ Legendary</button>
    <button class="inv-tab" onclick="filterInventory('covert',this)">Covert</button>
    <button class="inv-tab" onclick="filterInventory('classified',this)">Classified</button>
    <button class="inv-tab" onclick="filterInventory('restricted',this)">Restricted</button>
    <button class="inv-tab" onclick="hideInventory();openTradeOverlay()" style="border-color:rgba(0,230,118,0.3);color:#00e676;">🔄 Trade</button>
    <button class="inv-tab" onclick="hideInventory();openStoreOverlay()" style="border-color:rgba(255,215,0,0.3);color:#ffd700;">🏪 Store</button>
  </div>
  <div class="inv-grid" id="invGrid"></div>
</div>

<!-- ============ TRADE OVERLAY ============ -->
<div id="tradeOverlay" style="display:none;position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(4,8,20,.92);z-index:9999;overflow-y:auto;padding:20px;-webkit-overflow-scrolling:touch;">
  <div style="max-width:900px;margin:0 auto;">
    <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:16px;">
      <div style="font-family:'Orbitron';font-size:18px;color:var(--green);letter-spacing:2px;">🔄 TRADING</div>
      <button onclick="closeTradeOverlay()" style="padding:8px 16px;background:var(--surface2);border:1px solid var(--border);border-radius:8px;color:var(--text);cursor:pointer;font-family:'Orbitron';font-size:12px;">CLOSE</button>
    </div>

  <div id="tradePanel" style="width:100%;">
    <!-- Trade tabs -->
    <div style="display:flex;gap:6px;margin-bottom:12px;flex-wrap:wrap;">
      <button class="inv-tab active" id="tradeSendTab" onclick="switchTradeTab('send',this)" style="border-color:rgba(0,230,118,0.3);color:#00e676;">📤 Send</button>
      <button class="inv-tab" id="tradeInboxTab" onclick="switchTradeTab('inbox',this)" style="border-color:rgba(255,184,107,0.3);color:#ffb86b;">📥 Inbox <span id="tradeInboxCount" style="font-size:9px;background:var(--red);color:#fff;padding:1px 5px;border-radius:8px;margin-left:4px;display:none;"></span></button>
      <button class="inv-tab" id="tradeHistoryTab" onclick="switchTradeTab('history',this)">📋 History</button>
      <button class="inv-tab" id="giftTabBtn" onclick="switchTradeTab('gift',this)" style="border-color:rgba(255,193,7,0.3);color:#ffc107;">🎁 Gift</button>
    </div>
    
    <!-- SEND TAB — Step 1: Enter Username -->
    <div id="tradeSendView" style="background:var(--surface);border:1px solid var(--border);border-radius:12px;padding:16px;">
      <!-- STEP 1: Username entry -->
      <div id="tradeStep1" style="text-align:center;">
        <div style="font-family:'Orbitron';font-size:16px;color:var(--gold);letter-spacing:2px;margin-bottom:16px;">🔄 START A TRADE</div>
        <div style="font-size:13px;color:var(--text2);margin-bottom:16px;">Enter the username of the player you want to trade with</div>
        <div style="max-width:360px;margin:0 auto;">
          <input type="text" id="tradeRecipient" placeholder="Enter username..." maxlength="16" autocomplete="off" style="width:100%;padding:12px 16px;background:var(--bg);border:2px solid var(--border);border-radius:10px;color:var(--text);font-family:'Inter',sans-serif;font-size:15px;text-align:center;transition:border-color .2s;">
          <div id="tradeUserStatus" style="font-size:11px;color:var(--text2);margin-top:8px;min-height:18px;"></div>
          <button id="tradeRequestBtn" onclick="tradeRequestSend()" style="width:100%;padding:14px;margin-top:8px;background:linear-gradient(135deg,#00cc66,#009944);border:none;border-radius:10px;color:#fff;cursor:pointer;font-family:'Orbitron';font-size:14px;font-weight:700;letter-spacing:2px;transition:all .2s;opacity:0.5;" disabled>SEND TRADE REQUEST</button>
        </div>
      </div>

      <!-- STEP 2: Waiting for accept -->
      <div id="tradeStep2" style="display:none;text-align:center;">
        <div style="font-family:'Orbitron';font-size:16px;color:var(--neon);letter-spacing:2px;margin-bottom:16px;">⏳ WAITING FOR RESPONSE</div>
        <div style="font-size:42px;margin:12px 0;">🤝</div>
        <div style="font-size:14px;color:var(--text);">Trade request sent to <strong id="tradeWaitingFor" style="color:var(--neon);"></strong></div>
        <div style="font-size:12px;color:var(--text2);margin-top:8px;">Waiting for them to accept...</div>
        <div id="tradeWaitDots" style="font-size:24px;color:var(--neon);margin:12px 0;letter-spacing:6px;">...</div>
        <button onclick="tradeCancelRequest()" style="margin-top:16px;padding:10px 24px;background:transparent;border:1px solid var(--red);border-radius:8px;color:var(--red);cursor:pointer;font-size:12px;font-family:'Orbitron';">CANCEL</button>
      </div>

      <!-- STEP 3: Live two-way trade interface -->
      <div id="tradeStep3" style="display:none;">
        <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:14px;">
          <div style="font-family:'Orbitron';font-size:14px;color:var(--gold);letter-spacing:2px;">🔄 LIVE TRADE WITH <span id="tradePartnerName" style="color:var(--neon);"></span></div>
          <button onclick="tradeCancelSession()" style="padding:6px 14px;background:transparent;border:1px solid var(--red);border-radius:6px;color:var(--red);cursor:pointer;font-size:10px;">✕ CANCEL</button>
        </div>
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:12px;">
          <!-- Your offer -->
          <div style="background:rgba(0,240,255,.03);border:1px solid rgba(0,240,255,.15);border-radius:10px;padding:12px;">
            <div style="font-size:12px;font-weight:700;color:var(--neon);margin-bottom:8px;">🧑 YOUR OFFER</div>
            <select id="tradeItemSelect" onchange="liveTradeAddItem()" style="width:100%;padding:8px;background:var(--bg);border:1px solid var(--border);border-radius:6px;color:var(--text);font-size:12px;margin-bottom:6px;"></select>
            <div id="liveTradeMyItems" style="min-height:40px;background:var(--bg);border:1px solid var(--border);border-radius:6px;padding:8px;margin-bottom:8px;font-size:12px;color:var(--text2);">No items added</div>
            <div style="margin-bottom:6px;">
              <label style="font-size:11px;color:var(--text2);display:block;margin-bottom:4px;">+ Cash</label>
              <div style="display:flex;gap:4px;">
                <input type="number" id="tradeCashAmount" value="0" min="0" onchange="liveTradeUpdateCash()" oninput="liveTradeUpdateCash()" style="flex:1;padding:6px;background:var(--bg);border:1px solid var(--border);border-radius:6px;color:var(--gold);font-family:'Orbitron';font-size:12px;text-align:right;">
                <button class="bet-btn" onclick="betAll('tradeCashAmount');liveTradeUpdateCash()" style="padding:4px 8px;background:var(--gold);color:#000;font-weight:900;font-size:9px;">MAX</button>
              </div>
            </div>
            <div id="liveTradeMyReady" style="text-align:center;margin-top:8px;">
              <button onclick="liveTradeToggleReady()" id="liveTradeReadyBtn" style="padding:10px 24px;background:linear-gradient(135deg,#00cc66,#009944);border:none;border-radius:8px;color:#fff;cursor:pointer;font-family:'Orbitron';font-size:12px;font-weight:700;">✅ LOCK IN</button>
            </div>
          </div>
          <!-- Their offer (live) -->
          <div style="background:rgba(255,184,107,.03);border:1px solid rgba(255,184,107,.15);border-radius:10px;padding:12px;">
            <div style="font-size:12px;font-weight:700;color:#ffb86b;margin-bottom:8px;">👤 THEIR OFFER</div>
            <div id="liveTradeTheirItems" style="min-height:40px;background:var(--bg);border:1px solid var(--border);border-radius:6px;padding:8px;margin-bottom:8px;font-size:12px;color:var(--text2);">Waiting...</div>
            <div id="liveTradeTheirCash" style="font-family:'Orbitron';font-size:14px;color:var(--gold);margin-bottom:8px;">$0</div>
            <div id="liveTradeTheirReadyStatus" style="text-align:center;font-size:12px;color:var(--text2);margin-top:8px;">⏳ Not locked in</div>
          </div>
        </div>
        <div id="liveTradeConfirmArea" style="display:none;text-align:center;margin-top:12px;">
          <div style="font-size:13px;color:var(--green);margin-bottom:8px;">✅ Both players locked in!</div>
          <button onclick="liveTradeExecute()" style="padding:12px 32px;background:linear-gradient(135deg,#ffc107,#ff9800);border:none;border-radius:10px;color:#000;cursor:pointer;font-family:'Orbitron';font-size:14px;font-weight:700;">🤝 CONFIRM TRADE</button>
        </div>
        <div id="tradeStatus" style="font-size:12px;color:var(--text2);margin-top:8px;text-align:center;"></div>
      </div>
    </div>
    
    <!-- INBOX TAB -->
    <div id="tradeInboxView" style="display:none;background:var(--surface);border:1px solid var(--border);border-radius:12px;padding:16px;">
      <div style="font-family:'Orbitron';font-size:14px;color:#ffb86b;letter-spacing:2px;margin-bottom:12px;">📥 INCOMING TRADES</div>
      <div id="incomingTrades" style="display:flex;flex-direction:column;gap:8px;">
        <div style="color:var(--text2);font-size:12px;text-align:center;padding:20px;">No pending trades</div>
      </div>
    </div>
    
    <!-- HISTORY TAB -->
    <div id="tradeHistoryView" style="display:none;background:var(--surface);border:1px solid var(--border);border-radius:12px;padding:16px;">
      <div style="font-family:'Orbitron';font-size:14px;color:var(--text2);letter-spacing:2px;margin-bottom:12px;">📋 TRADE HISTORY</div>
      <div id="tradeHistoryList" style="display:flex;flex-direction:column;gap:6px;">
        <div style="color:var(--text2);font-size:12px;text-align:center;padding:20px;">No trade history yet</div>
      </div>
    </div>

    <!-- GIFT TAB -->
    <div id="giftView" style="display:none;background:var(--surface);border:1px solid var(--border);border-radius:12px;padding:16px;">
      <div style="font-family:'Orbitron';font-size:16px;color:var(--gold);letter-spacing:2px;margin-bottom:16px;text-align:center;">🎁 GIFT MONEY</div>
      <div style="max-width:400px;margin:0 auto;">
        <div style="margin-bottom:12px;">
          <label style="font-size:12px;color:var(--text2);display:block;margin-bottom:6px;">Recipient Username</label>
          <input type="text" id="giftUsername" placeholder="Enter username..." maxlength="16" autocomplete="off" style="width:100%;padding:12px 14px;background:var(--bg);border:2px solid var(--border);border-radius:10px;color:var(--text);font-family:'Inter',sans-serif;font-size:14px;box-sizing:border-box;">
        </div>
        <div style="margin-bottom:12px;">
          <label style="font-size:12px;color:var(--text2);display:block;margin-bottom:6px;">Amount ($)</label>
          <input type="number" id="giftAmount" placeholder="Enter amount..." min="1" style="width:100%;padding:12px 14px;background:var(--bg);border:2px solid var(--border);border-radius:10px;color:var(--gold);font-family:'Orbitron';font-size:14px;text-align:right;box-sizing:border-box;">
        </div>
        <div style="display:flex;gap:8px;margin-bottom:12px;">
          <button onclick="quickGiftAmount(100)" style="flex:1;padding:8px;background:rgba(212,175,55,.15);border:1px solid rgba(212,175,55,.3);border-radius:6px;color:var(--gold);cursor:pointer;font-size:11px;font-family:'Orbitron';font-weight:700;">$100</button>
          <button onclick="quickGiftAmount(1000)" style="flex:1;padding:8px;background:rgba(212,175,55,.15);border:1px solid rgba(212,175,55,.3);border-radius:6px;color:var(--gold);cursor:pointer;font-size:11px;font-family:'Orbitron';font-weight:700;">$1K</button>
          <button onclick="quickGiftAmount(10000)" style="flex:1;padding:8px;background:rgba(212,175,55,.15);border:1px solid rgba(212,175,55,.3);border-radius:6px;color:var(--gold);cursor:pointer;font-size:11px;font-family:'Orbitron';font-weight:700;">$10K</button>
        </div>
        <button onclick="sendGift()" style="width:100%;padding:14px;background:linear-gradient(135deg,#ffc107,#ff9800);border:none;border-radius:10px;color:#000;cursor:pointer;font-family:'Orbitron';font-size:14px;font-weight:700;letter-spacing:1px;transition:all .2s;">💝 SEND GIFT</button>
        <div id="giftStatus" style="font-size:12px;color:var(--text2);margin-top:8px;text-align:center;min-height:20px;"></div>
      </div>
    </div>
  </div>
  </div>
</div>

<!-- Loans removed -->

<!-- ============ STORE / MARKETPLACE OVERLAY ============ -->
<div id="storeOverlay" style="display:none;position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(4,8,20,.92);z-index:9999;overflow-y:auto;padding:20px;-webkit-overflow-scrolling:touch;">
  <div style="max-width:960px;margin:0 auto;">
    <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:16px;">
      <div style="font-family:'Orbitron';font-size:18px;color:var(--gold);letter-spacing:2px;">🏪 MARKETPLACE</div>
      <button onclick="closeStoreOverlay()" style="padding:8px 16px;background:var(--surface2);border:1px solid var(--border);border-radius:8px;color:var(--text);cursor:pointer;font-family:'Orbitron';font-size:12px;">CLOSE</button>
    </div>

  <div id="storePanel" style="width:100%;">
    <div style="display:flex;gap:6px;margin-bottom:12px;">
      <button class="inv-tab active" id="storeBrowseTab" onclick="switchStoreTab('browse',this)" style="border-color:rgba(255,215,0,0.3);color:#ffd700;">🏪 Browse</button>
      <button class="inv-tab" id="storeListTab" onclick="switchStoreTab('list',this)" style="border-color:rgba(0,230,118,0.3);color:#00e676;">📦 List Item</button>
      <button class="inv-tab" id="storeMyTab" onclick="switchStoreTab('my',this)" style="border-color:rgba(0,240,255,0.3);color:var(--neon);">📋 My Listings</button>
      <button class="inv-tab" id="storeSalesTab" onclick="switchStoreTab('sales',this)">💰 Sales Log</button>
    </div>

    <!-- BROWSE TAB -->
    <div id="storeBrowseView" style="background:var(--surface);border:1px solid var(--border);border-radius:12px;padding:16px;">
      <div style="display:flex;align-items:center;justify-content:space-between;flex-wrap:wrap;gap:8px;margin-bottom:14px;">
        <div style="font-family:'Orbitron';font-size:14px;color:var(--gold);letter-spacing:2px;">🏪 MARKETPLACE</div>
        <div style="display:flex;gap:6px;align-items:center;">
          <select id="storeFilterRarity" onchange="renderStoreListings()" style="padding:6px 10px;background:var(--bg);border:1px solid var(--border);border-radius:6px;color:var(--text);font-size:11px;">
            <option value="all">All Rarities</option>
            <option value="legendary">★ Legendary</option>
            <option value="covert">Covert</option>
            <option value="classified">Classified</option>
            <option value="restricted">Restricted</option>
            <option value="milspec">Mil-Spec</option>
            <option value="industrial">Industrial</option>
            <option value="consumer">Consumer</option>
          </select>
          <select id="storeSortBy" onchange="renderStoreListings()" style="padding:6px 10px;background:var(--bg);border:1px solid var(--border);border-radius:6px;color:var(--text);font-size:11px;">
            <option value="newest">Newest</option>
            <option value="priceAsc">Price: Low → High</option>
            <option value="priceDesc">Price: High → Low</option>
            <option value="ending">Ending Soon</option>
          </select>
          <button onclick="loadStoreListings()" style="padding:6px 10px;background:var(--surface2);border:1px solid var(--border);border-radius:6px;color:var(--neon);cursor:pointer;font-size:11px;">🔄 Refresh</button>
        </div>
      </div>
      <div id="storeListingsGrid" style="display:grid;grid-template-columns:repeat(auto-fill,minmax(200px,1fr));gap:10px;max-height:500px;overflow-y:auto;padding:4px;">
        <div style="grid-column:1/-1;color:var(--text2);font-size:12px;text-align:center;padding:30px;">Loading marketplace...</div>
      </div>
    </div>

    <!-- LIST ITEM TAB -->
    <div id="storeListView" style="display:none;background:var(--surface);border:1px solid var(--border);border-radius:12px;padding:16px;">
      <div style="font-family:'Orbitron';font-size:14px;color:var(--gold);letter-spacing:2px;margin-bottom:14px;">📦 LIST AN ITEM</div>
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:16px;">
        <div style="background:rgba(0,240,255,.03);border:1px solid rgba(0,240,255,.15);border-radius:10px;padding:14px;">
          <div style="font-size:12px;font-weight:700;color:var(--neon);margin-bottom:10px;">SELECT ITEM</div>
          <select id="storeListItemSelect" onchange="storeUpdateListPreview()" style="width:100%;padding:8px;background:var(--bg);border:1px solid var(--border);border-radius:6px;color:var(--text);font-size:12px;margin-bottom:10px;"></select>
          <div id="storeListItemPreview" style="background:var(--bg);border:1px solid var(--border);border-radius:8px;padding:12px;text-align:center;min-height:100px;display:flex;align-items:center;justify-content:center;flex-direction:column;gap:4px;">
            <div style="color:var(--text2);font-size:12px;">Select an item from your inventory</div>
          </div>
        </div>
        <div style="background:rgba(255,215,0,.03);border:1px solid rgba(255,215,0,.15);border-radius:10px;padding:14px;">
          <div style="font-size:12px;font-weight:700;color:var(--gold);margin-bottom:10px;">LISTING TYPE</div>
          <div style="display:flex;gap:8px;margin-bottom:12px;">
            <button id="storeTypeFixed" onclick="storeSetType('fixed')" class="inv-tab active" style="flex:1;text-align:center;padding:8px;">💰 Fixed Price</button>
            <button id="storeTypeAuction" onclick="storeSetType('auction')" class="inv-tab" style="flex:1;text-align:center;padding:8px;">🔨 Auction</button>
          </div>
          <!-- Fixed price fields -->
          <div id="storeFixedFields">
            <label style="font-size:11px;color:var(--text2);display:block;margin-bottom:4px;">Asking Price ($)</label>
            <input type="number" id="storeAskPrice" min="1" style="width:100%;padding:8px;background:var(--bg);border:1px solid var(--border);border-radius:6px;color:var(--gold);font-family:'Orbitron';font-size:13px;">
            <div id="storeMarketRef" style="font-size:10px;color:var(--text2);margin-top:4px;">Market value: —</div>
          </div>
          <!-- Auction fields -->
          <div id="storeAuctionFields" style="display:none;">
            <label style="font-size:11px;color:var(--text2);display:block;margin-bottom:4px;">Starting Bid ($)</label>
            <input type="number" id="storeStartBid" min="1" style="width:100%;padding:8px;background:var(--bg);border:1px solid var(--border);border-radius:6px;color:var(--gold);font-family:'Orbitron';font-size:13px;margin-bottom:8px;">
            <label style="font-size:11px;color:var(--text2);display:block;margin-bottom:4px;">Duration</label>
            <select id="storeAuctionDuration" style="width:100%;padding:8px;background:var(--bg);border:1px solid var(--border);border-radius:6px;color:var(--text);font-size:12px;">
              <option value="300000">5 minutes</option>
              <option value="900000">15 minutes</option>
              <option value="1800000" selected>30 minutes</option>
              <option value="3600000">1 hour</option>
              <option value="86400000">24 hours</option>
            </select>
          </div>
          <div style="margin-top:14px;">
            <button onclick="storeListItem()" style="width:100%;padding:12px;background:linear-gradient(135deg,#ffd700,#ff9900);border:none;border-radius:10px;color:#000;cursor:pointer;font-family:'Orbitron';font-size:13px;font-weight:700;letter-spacing:2px;">LIST ON STORE</button>
          </div>
          <div id="storeListStatus" style="font-size:11px;color:var(--text2);margin-top:8px;text-align:center;"></div>
        </div>
      </div>
    </div>

    <!-- MY LISTINGS TAB -->
    <div id="storeMyView" style="display:none;background:var(--surface);border:1px solid var(--border);border-radius:12px;padding:16px;">
      <div style="font-family:'Orbitron';font-size:14px;color:var(--neon);letter-spacing:2px;margin-bottom:12px;">📋 MY LISTINGS</div>
      <div id="storeMyListings" style="display:flex;flex-direction:column;gap:8px;">
        <div style="color:var(--text2);font-size:12px;text-align:center;padding:20px;">No active listings</div>
      </div>
    </div>

    <!-- SALES LOG TAB -->
    <div id="storeSalesView" style="display:none;background:var(--surface);border:1px solid var(--border);border-radius:12px;padding:16px;">
      <div style="font-family:'Orbitron';font-size:14px;color:var(--gold);letter-spacing:2px;margin-bottom:12px;">💰 RECENT SALES</div>
      <div style="font-size:11px;color:var(--text2);margin-bottom:10px;">See what items have sold for across the marketplace</div>
      <div id="storeSalesLog" style="display:flex;flex-direction:column;gap:6px;">
        <div style="color:var(--text2);font-size:12px;text-align:center;padding:20px;">No sales yet</div>
      </div>
    </div>
  </div>
  </div>
</div>

<!-- ============ FRIENDS PANEL OVERLAY ============ -->
<div id="friendsOverlay" style="display:none;position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(4,8,20,.92);z-index:9999;overflow-y:auto;padding:20px;-webkit-overflow-scrolling:touch;">
  <div style="max-width:700px;margin:0 auto;">
    <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:16px;">
      <div style="font-family:'Orbitron';font-size:18px;color:var(--gold);letter-spacing:2px;">👥 FRIENDS</div>
      <button onclick="hideFriendsPanel()" style="padding:8px 16px;background:var(--surface2);border:1px solid var(--border);border-radius:8px;color:var(--text);cursor:pointer;font-family:'Orbitron';font-size:12px;">CLOSE</button>
    </div>
    <div style="display:flex;gap:6px;margin-bottom:14px;flex-wrap:wrap;">
      <button class="inv-tab active" id="frTabFriends" onclick="switchFriendsTab('friends',this)">👥 Friends</button>
      <button class="inv-tab" id="frTabRequests" onclick="switchFriendsTab('requests',this)">📩 Requests <span id="frReqCount" style="font-size:9px;background:var(--red);color:#fff;padding:1px 5px;border-radius:8px;margin-left:3px;display:none;"></span></button>
      <button class="inv-tab" id="frTabAdd" onclick="switchFriendsTab('add',this)">➕ Add</button>
      <button class="inv-tab" id="frTabBlocked" onclick="switchFriendsTab('blocked',this)">🚫 Blocked</button>
      <button class="inv-tab" id="frTabDM" onclick="switchFriendsTab('dm',this)">💬 Messages</button>
      <button class="inv-tab" id="frTabPrivacy" onclick="switchFriendsTab('privacy',this)">🔒 Privacy</button>
    </div>

    <!-- FRIENDS LIST -->
    <div id="frViewFriends" style="background:var(--surface);border:1px solid var(--border);border-radius:12px;padding:16px;">
      <div style="font-family:'Orbitron';font-size:13px;color:var(--neon);letter-spacing:1px;margin-bottom:12px;">YOUR FRIENDS <span id="frFriendCount" style="color:var(--text2);font-size:11px;"></span></div>
      <div id="frFriendsList" style="display:flex;flex-direction:column;gap:8px;">
        <div style="color:var(--text2);font-size:12px;text-align:center;padding:20px;">Loading...</div>
      </div>
    </div>

    <!-- REQUESTS -->
    <div id="frViewRequests" style="display:none;background:var(--surface);border:1px solid var(--border);border-radius:12px;padding:16px;">
      <div style="font-family:'Orbitron';font-size:13px;color:#ffb86b;letter-spacing:1px;margin-bottom:12px;">FRIEND REQUESTS</div>
      <div id="frRequestsList" style="display:flex;flex-direction:column;gap:8px;">
        <div style="color:var(--text2);font-size:12px;text-align:center;padding:20px;">No pending requests</div>
      </div>
    </div>

    <!-- ADD FRIEND -->
    <div id="frViewAdd" style="display:none;background:var(--surface);border:1px solid var(--border);border-radius:12px;padding:16px;text-align:center;">
      <div style="font-family:'Orbitron';font-size:13px;color:var(--green);letter-spacing:1px;margin-bottom:16px;">ADD A FRIEND</div>
      <div style="max-width:340px;margin:0 auto;">
        <input type="text" id="frAddInput" placeholder="Enter username..." maxlength="16" autocomplete="off" style="width:100%;padding:12px 16px;background:var(--bg);border:2px solid var(--border);border-radius:10px;color:var(--text);font-size:14px;text-align:center;">
        <button onclick="friendSendRequest()" style="width:100%;margin-top:10px;padding:12px;background:linear-gradient(135deg,#00cc66,#009944);border:none;border-radius:10px;color:#fff;cursor:pointer;font-family:'Orbitron';font-size:13px;font-weight:700;">SEND FRIEND REQUEST</button>
        <div id="frAddStatus" style="font-size:11px;color:var(--text2);margin-top:8px;"></div>
      </div>
      <div style="margin-top:20px;border-top:1px solid var(--border);padding-top:16px;">
        <div style="font-family:'Orbitron';font-size:12px;color:var(--red);letter-spacing:1px;margin-bottom:10px;">🚫 BLOCK A PLAYER</div>
        <div style="max-width:340px;margin:0 auto;">
          <input type="text" id="frBlockInput" placeholder="Username to block..." maxlength="16" autocomplete="off" style="width:100%;padding:10px 14px;background:var(--bg);border:2px solid rgba(255,55,95,.3);border-radius:10px;color:var(--text);font-size:13px;text-align:center;">
          <button onclick="friendBlockPlayer()" style="width:100%;margin-top:8px;padding:10px;background:transparent;border:2px solid var(--red);border-radius:10px;color:var(--red);cursor:pointer;font-family:'Orbitron';font-size:12px;font-weight:700;">BLOCK PLAYER</button>
          <div id="frBlockStatus" style="font-size:11px;color:var(--text2);margin-top:6px;"></div>
        </div>
      </div>
    </div>

    <!-- BLOCKED -->
    <div id="frViewBlocked" style="display:none;background:var(--surface);border:1px solid var(--border);border-radius:12px;padding:16px;">
      <div style="font-family:'Orbitron';font-size:13px;color:var(--red);letter-spacing:1px;margin-bottom:12px;">🚫 BLOCKED PLAYERS</div>
      <div id="frBlockedList" style="display:flex;flex-direction:column;gap:8px;">
        <div style="color:var(--text2);font-size:12px;text-align:center;padding:20px;">No blocked players</div>
      </div>
    </div>

    <!-- DM / MESSAGES -->
    <div id="frViewDm" style="display:none;background:var(--surface);border:1px solid var(--border);border-radius:12px;padding:16px;">
      <div style="font-family:'Orbitron';font-size:13px;color:var(--neon);letter-spacing:1px;margin-bottom:12px;">💬 DIRECT MESSAGES</div>
      <!-- DM contact list -->
      <div id="dmContactList" style="display:flex;flex-direction:column;gap:6px;">
        <div style="color:var(--text2);font-size:12px;text-align:center;padding:20px;">Add friends to message them</div>
      </div>
      <!-- DM chat view (hidden until a contact is selected) -->
      <div id="dmChatView" style="display:none;margin-top:12px;">
        <div style="display:flex;align-items:center;gap:8px;margin-bottom:10px;">
          <button onclick="dmBackToList()" style="padding:4px 10px;background:var(--surface2);border:1px solid var(--border);border-radius:6px;color:var(--text);cursor:pointer;font-size:11px;">← Back</button>
          <div id="dmChatPartner" style="font-weight:700;color:var(--neon);font-size:13px;"></div>
          <div id="dmPartnerStatus" style="font-size:10px;margin-left:auto;"></div>
        </div>
        <div id="dmMessages" style="background:var(--bg);border:1px solid var(--border);border-radius:10px;padding:10px;height:280px;overflow-y:auto;display:flex;flex-direction:column;gap:6px;-webkit-overflow-scrolling:touch;"></div>
        <div style="display:flex;gap:6px;margin-top:8px;">
          <input type="text" id="dmInput" placeholder="Type a message..." maxlength="200" autocomplete="off" style="flex:1;padding:10px 14px;background:var(--bg);border:1px solid var(--border);border-radius:8px;color:var(--text);font-size:12px;">
          <button onclick="dmSendMessage()" style="padding:10px 18px;background:linear-gradient(135deg,#00cc66,#009944);border:none;border-radius:8px;color:#fff;cursor:pointer;font-family:'Orbitron';font-size:11px;font-weight:700;">SEND</button>
        </div>
      </div>
    </div>

    <!-- PRIVACY SETTINGS -->
    <div id="frViewPrivacy" style="display:none;background:var(--surface);border:1px solid var(--border);border-radius:12px;padding:16px;">
      <div style="font-family:'Orbitron';font-size:13px;color:var(--gold);letter-spacing:1px;margin-bottom:16px;">🔒 PRIVACY SETTINGS</div>
      <div style="display:flex;flex-direction:column;gap:14px;max-width:400px;">
        <div>
          <label style="font-size:12px;font-weight:700;color:var(--text);display:block;margin-bottom:6px;">Friend Requests</label>
          <select id="privFriendRequests" style="width:100%;padding:8px;background:var(--bg);border:1px solid var(--border);border-radius:6px;color:var(--text);font-size:12px;">
            <option value="everyone">Everyone can send me requests</option>
            <option value="friends_only">Friends of friends only</option>
            <option value="nobody">Nobody</option>
          </select>
        </div>
        <div>
          <label style="font-size:12px;font-weight:700;color:var(--text);display:block;margin-bottom:6px;">Direct Messages</label>
          <select id="privDirectMessages" style="width:100%;padding:8px;background:var(--bg);border:1px solid var(--border);border-radius:6px;color:var(--text);font-size:12px;">
            <option value="friends">Friends only</option>
            <option value="everyone">Everyone</option>
            <option value="nobody">Nobody</option>
          </select>
        </div>
        <div>
          <label style="font-size:12px;font-weight:700;color:var(--text);display:block;margin-bottom:6px;">Online Status</label>
          <select id="privOnlineStatus" style="width:100%;padding:8px;background:var(--bg);border:1px solid var(--border);border-radius:6px;color:var(--text);font-size:12px;">
            <option value="everyone">Visible to everyone</option>
            <option value="friends">Friends only</option>
            <option value="hidden">Hidden (appear offline)</option>
          </select>
        </div>
        <div>
          <label style="font-size:12px;font-weight:700;color:var(--text);display:block;margin-bottom:6px;">Trade Requests</label>
          <select id="privTradeRequests" style="width:100%;padding:8px;background:var(--bg);border:1px solid var(--border);border-radius:6px;color:var(--text);font-size:12px;">
            <option value="everyone">Everyone</option>
            <option value="friends">Friends only</option>
            <option value="nobody">Nobody</option>
          </select>
        </div>
        <button onclick="savePrivacySettings()" style="padding:12px;background:linear-gradient(135deg,#ffd700,#ff9900);border:none;border-radius:10px;color:#000;cursor:pointer;font-family:'Orbitron';font-size:13px;font-weight:700;letter-spacing:2px;">SAVE SETTINGS</button>
        <div id="privSaveStatus" style="font-size:11px;color:var(--text2);text-align:center;"></div>
      </div>
    </div>
  </div>
</div>

<!-- ============ GLOBAL CHAT ============ -->
<button id="chatToggleBtn" onclick="toggleChat()" style="display:none;" title="Chat">💬<span class="chat-badge" id="chatBadge">0</span></button>
<div id="chatPanel">
  <div class="chat-header">
    <div class="chat-header-title"><span class="online-dot"></span> LOBBY CHAT <span class="chat-online-count" id="chatOnlineCount"></span></div>
    <button class="chat-close" onclick="toggleChat()">✕</button>
  </div>
  <div class="chat-messages" id="chatMessages">
    <div class="chat-msg-system">Welcome to Casino Royale chat! Be respectful.</div>
  </div>
  <div class="chat-input-wrap">
    <input class="chat-input" id="chatInput" placeholder="Type a message..." maxlength="200" autocomplete="off">
    <button class="chat-send-btn" id="chatSendBtn" onclick="sendChatMessage()">Send</button>
  </div>
</div>

<!-- Firebase -->
<script type="module">
import{initializeApp}from"https://www.gstatic.com/firebasejs/11.8.1/firebase-app.js";
import{getDatabase,ref,set,get,onValue,push,update,remove,off,onDisconnect,query as fbQuery,limitToLast as fbLimitToLast}from"https://www.gstatic.com/firebasejs/11.8.1/firebase-database.js";
import{getAuth,createUserWithEmailAndPassword,signInWithEmailAndPassword,signOut,onAuthStateChanged}from"https://www.gstatic.com/firebasejs/11.8.1/firebase-auth.js";

const firebaseConfig={
  apiKey:"AIzaSyDJyyYO_JIN2h0uX3UU1MzMWlFvc6K25GM",
  authDomain:"better-gamble.firebaseapp.com",
  databaseURL:"https://better-gamble-default-rtdb.firebaseio.com",
  projectId:"better-gamble",
  storageBucket:"better-gamble.firebasestorage.app",
  messagingSenderId:"95557518690",
  appId:"1:95557518690:web:7d10906370d2b38202d83b",
  measurementId:"G-62KJSECQLZ"
};
const app=initializeApp(firebaseConfig);
const db=getDatabase(app);
const auth=getAuth(app);

// ============ AUTH ============
let currentUser = null;
let currentUsername = '';
let playerId = '';
let playerRef = null;

function usernameToEmail(username) {
  return username.toLowerCase().replace(/[^a-z0-9_]/g,'') + '@casinoroyale.gg';
}

function emailToUsername(email) {
  return email.replace('@casinoroyale.gg','');
}

// Auth submit (sign in or register)
window._authSubmit = async (username, password, isRegister) => {
  const email = usernameToEmail(username);
  if (username.length < 3) throw new Error('Username must be at least 3 characters');
  if (username.length > 16) throw new Error('Username max 16 characters');
  if (!/^[a-zA-Z0-9_]+$/.test(username)) throw new Error('Letters, numbers, and _ only');
  // Profanity filter
  const _badWords = ['nigger','nigga','faggot','fag','retard','chink','spic','kike','beaner','tranny','coon','wetback','gook'];
  const _uLow = username.toLowerCase();
  for (const w of _badWords) { if (_uLow.includes(w)) throw new Error('Username contains inappropriate language'); }
  if (password.length < 6) throw new Error('Password must be at least 6 characters');

  if (isRegister) {
    // Check if username is taken
    const nameSnap = await get(ref(db, 'casino/usernames/' + username.toLowerCase()));
    if (nameSnap.exists()) throw new Error('Username already taken');
    const cred = await createUserWithEmailAndPassword(auth, email, password);
    // Reserve username
    await set(ref(db, 'casino/usernames/' + username.toLowerCase()), cred.user.uid);
    // Create player profile
    await set(ref(db, 'casino/players/' + cred.user.uid), {
      username: username,
      balance: 1000,
      created: Date.now(),
      lastPlayed: Date.now(),
      stats: { totalWagered: 0, totalWon: 0, totalProfit: 0, gamesPlayed: 0, biggestWin: 0 },
      gameStats: {
        slots: { played: 0, won: 0, biggestWin: 0 },
        crash: { played: 0, won: 0, biggestMultiplier: 0, biggestWin: 0 },
        roulette: { played: 0, won: 0, biggestWin: 0 },
        cases: { played: 0, opened: 0, bestItem: '' },
        plinko: { played: 0, won: 0, biggestWin: 0 },
        pyl: { played: 0, highScore: 0 }
      },
      dailyBonus: { lastClaimed: 0, streak: 0 },
      prestige: 0
    });
    return cred.user;
  } else {
    const cred = await signInWithEmailAndPassword(auth, email, password);
    return cred.user;
  }
};

window._authLogout = () => signOut(auth);

// Listen for auth state changes
onAuthStateChanged(auth, async (user) => {
  if (user) {
    currentUser = user;
    playerId = user.uid;
    window._currentPlayerId = playerId;
    playerRef = ref(db, 'casino/players/' + playerId);

    // Load username
    const snap = await get(playerRef);
    if (snap.exists()) {
      const data = snap.val();
      currentUsername = data.username || emailToUsername(user.email);
      if (data.balance != null) window.setBalance(safeNum(data.balance));
      if (data.stocks) window._loadStocks(data.stocks);
      if (data.inventory) window._loadInventory(data.inventory);
      if (data.itemDemand) window._loadDemand(data.itemDemand);
      if (data.stats) window._loadStats(data.stats);
      if (data.gameStats) window._loadGameStats(data.gameStats);
      if (data.dailyBonus) window._loadDailyBonus(data.dailyBonus);
      if (data.achievements) window._loadAchievements(data.achievements);
      if (data.tradeHistory) window._loadTradeHistory(data.tradeHistory);
      if (data.prestige != null) window._loadPrestige(data.prestige);
      if (data.profilePicUrl) window._loadProfilePicUrl(data.profilePicUrl);
    } else {
      currentUsername = emailToUsername(user.email);
    }

    // Set up session ID for multiplayer
    let pylSessionId = sessionStorage.getItem('pyl_session_id');
    if (!pylSessionId) {
      pylSessionId = playerId + '_' + Math.random().toString(36).substr(2, 4);
      sessionStorage.setItem('pyl_session_id', pylSessionId);
    }
    window._pylPlayerId = pylSessionId;
    window._currentPylSessionId = pylSessionId;
    window._currentUsername = currentUsername;
    window._currentPlayerId = playerId;

    // Show casino, hide login
    if (typeof window._onAuthReady === 'function') window._onAuthReady(currentUsername, playerId);

    // Balance sync — poll every 30s + full sync on tab focus for cross-device
    async function _syncBalance() {
      try {
        const balSnap = await get(ref(db, 'casino/players/' + playerId + '/balance'));
        if (balSnap.exists()) {
          const serverBal = safeNum(balSnap.val());
          if (Math.abs(serverBal - window.getBalance()) > 0.02) {
            window.setBalance(serverBal);
          }
        }
      } catch(e) {}
    }
    async function _fullSync() {
      try {
        const snap = await get(playerRef);
        if (!snap.exists()) return;
        const data = snap.val();
        if (data.balance != null) window.setBalance(safeNum(data.balance));
        if (data.inventory && window._loadInventory) window._loadInventory(data.inventory);
        if (data.stats && window._loadStats) window._loadStats(data.stats);
        if (data.gameStats && window._loadGameStats) window._loadGameStats(data.gameStats);
        if (data.prestige != null && window._loadPrestige) window._loadPrestige(data.prestige);
        if (data.achievements && window._loadAchievements) window._loadAchievements(data.achievements);
      } catch(e) {}
    }
    if (window._balanceUnsub) { clearInterval(window._balanceUnsub); window._balanceUnsub = null; }
    window._balanceUnsub = setInterval(_syncBalance, 30000);
    // Full sync when user switches back to tab (cross-device fix)
    document.addEventListener('visibilitychange', () => {
      if (!document.hidden && playerId) _fullSync();
    });
  } else {
    if (window._balanceUnsub) { clearInterval(window._balanceUnsub); window._balanceUnsub = null; }
    currentUser = null;
    currentUsername = '';
    playerId = '';
    playerRef = null;
    if (typeof window._onAuthLoggedOut === 'function') window._onAuthLoggedOut();
  }
});

// ============ FIREBASE SAVE ============
window._firebaseSave = () => {
  if (!playerRef) return;
  const saveData = {
    username: currentUsername,
    balance: safeNum(window.getBalance()),
    lastPlayed: Date.now(),
    stats: window._getStats ? window._getStats() : null,
    gameStats: window._getGameStats ? window._getGameStats() : null,
    achievements: window._getAchievements ? window._getAchievements() : null,
    prestige: window._getPrestige ? window._getPrestige() : null,
    profilePicUrl: window._getProfilePicUrl ? window._getProfilePicUrl() : null
  };
  // Clean nulls
  Object.keys(saveData).forEach(k => { if (saveData[k] == null) delete saveData[k]; });
  update(playerRef, saveData).catch(() => {});
  // Also update leaderboard entry for "richest" — but only every 30 seconds
  if (playerId && currentUsername && (!window._lastLBUpdate || Date.now() - window._lastLBUpdate > 30000)) {
    window._lastLBUpdate = Date.now();
    set(ref(db, 'casino/leaderboards/richest/' + playerId), {
      name: currentUsername,
      value: safeNum(window.getBalance()),
      updated: Date.now()
    }).catch(() => {});
  }
};

// ============ GAME STAT RECORDING ============
// Debounced — stats accumulate locally, only writes to Firebase every 10 seconds
let _pendingStats = null;
let _statsTimer = null;

async function _flushStats() {
  if (!_pendingStats || !playerRef) return;
  const { game, wagered, won } = _pendingStats;
  _pendingStats = null;
  const statsRef = ref(db, 'casino/players/' + playerId + '/stats');
  try {
    const snap = await get(statsRef);
    const s = snap.exists() ? snap.val() : { totalWagered: 0, totalWon: 0, totalProfit: 0, gamesPlayed: 0, biggestWin: 0 };
    // Apply accumulated local stats directly (already tracked in playerStats)
    Object.assign(s, {
      totalWagered: playerStats.totalWagered,
      totalWon: playerStats.totalWon,
      totalProfit: playerStats.totalProfit,
      gamesPlayed: playerStats.gamesPlayed,
      biggestWin: playerStats.biggestWin
    });
    await set(statsRef, s);
    if (window._loadStats) window._loadStats(s);
    // Update leaderboards only on significant wins (>$1000) and only once per 60 seconds per game
    if (won > 1000 && (!window._lastGameLBUpdate || !window._lastGameLBUpdate[game] || Date.now() - window._lastGameLBUpdate[game] > 60000)) {
      if (!window._lastGameLBUpdate) window._lastGameLBUpdate = {};
      window._lastGameLBUpdate[game] = Date.now();
      const lbRef = ref(db, 'casino/leaderboards/' + game + '/' + playerId);
      const lbSnap = await get(lbRef).catch(() => null);
      const cur = (lbSnap && lbSnap.exists()) ? (lbSnap.val().value || 0) : 0;
      if (won > cur) {
        await set(lbRef, { name: currentUsername, value: won, updated: Date.now() }).catch(() => {});
      }
    }
    // Profit leaderboard — update only if substantial change (>$100) and not too frequent (60s)
    if (!window._lastProfitUpdate || Date.now() - window._lastProfitUpdate > 60000) {
      window._lastProfitUpdate = Date.now();
      await set(ref(db, 'casino/leaderboards/profit/' + playerId), {
        name: currentUsername, value: safeNum(s.totalProfit || 0), updated: Date.now()
      }).catch(() => {});
    }
  } catch(e) { console.warn('recordGameResult error:', e); }
}

window._recordGameResult = async (game, wagered, won) => {
  if (!playerRef) return;
  _pendingStats = { game, wagered, won };
  if (_statsTimer) clearTimeout(_statsTimer);
  _statsTimer = setTimeout(() => { _statsTimer = null; _flushStats(); }, 10000); // flush every 10s
};

window._flushStatsNow = () => { if(_statsTimer){clearTimeout(_statsTimer);_statsTimer=null;_flushStats();} };

// ============ LEADERBOARD FETCH ============
window._getLeaderboard = async (category) => {
  try {
    const snap = await get(ref(db, 'casino/leaderboards/' + category));
    if (!snap.exists()) return [];
    const data = snap.val();
    const entries = Object.entries(data).map(([uid, e]) => ({ uid, name: e.name, value: safeNum(e.value), updated: e.updated }));
    entries.sort((a, b) => b.value - a.value);
    return entries.slice(0, 50);
  } catch { return []; }
};

// ============ DAILY BONUS ============
window._claimDailyBonus = async () => {
  if (!playerRef) return null;
  const bonusRef = ref(db, 'casino/players/' + playerId + '/dailyBonus');
  const now = Date.now();
  try {
    const snap = await get(bonusRef);
    const data = snap.exists() ? snap.val() : { lastClaimed: 0, streak: 0 };
    const lastDate = new Date(data.lastClaimed).toDateString();
    const todayDate = new Date(now).toDateString();
    if (lastDate === todayDate) return null; // Already claimed
    const yesterdayDate = new Date(now - 86400000).toDateString();
    const newStreak = (lastDate === yesterdayDate) ? (data.streak || 0) + 1 : 1;
    const bonus = Math.min(500 + (newStreak - 1) * 100, 2000);
    await set(bonusRef, { lastClaimed: now, streak: newStreak });
    return { amount: bonus, streak: newStreak };
  } catch(e) { console.warn('claimDailyBonus error:', e); return null; }
};

// ============ GLOBAL MARKET SYNC ============
// Real-time synced supply/demand — shared across ALL players
let _marketListener = null;
window._initGlobalMarket = () => {
  if (_marketListener) return;
  const marketRef = ref(db, 'casino/market');
  _marketListener = onValue(marketRef, (snap) => {
    if (!snap.exists()) return;
    const data = snap.val();
    // data = { itemId: { globalSupply, totalOpened, lastTradePrice, lastTradeTs } }
    if (window._onGlobalMarketUpdate) window._onGlobalMarketUpdate(data);
  });
};

// Update global market when items change hands
window._updateGlobalMarketItem = async (itemId, action, price) => {
  const itemRef = ref(db, 'casino/market/' + itemId);
  try {
    const snap = await get(itemRef);
    const d = snap.exists() ? snap.val() : { globalSupply: 0, totalOpened: 0, lastTradePrice: 0, lastTradeTs: 0 };
    if (action === 'opened') {
      d.globalSupply = (d.globalSupply || 0) + 1;
      d.totalOpened = (d.totalOpened || 0) + 1;
    } else if (action === 'sold') {
      d.globalSupply = Math.max(0, (d.globalSupply || 0) - 1);
      d.lastTradePrice = price || 0;
      d.lastTradeTs = Date.now();
    } else if (action === 'traded') {
      d.lastTradePrice = price || 0;
      d.lastTradeTs = Date.now();
    }
    await set(itemRef, d);
  } catch(e) {}
};

// ============ 

// ============ TRADING SYSTEM (Firebase) ============
window._sendTradeOffer = async (recipientUsername, item, cash, message) => {
  if (!playerId || !currentUsername) return { error: 'Not logged in' };
  const nameSnap = await get(ref(db, 'casino/usernames/' + recipientUsername));
  if (!nameSnap.exists()) return { error: 'Player not found' };
  const recipientUid = nameSnap.val();
  if (recipientUid === playerId) return { error: "Can't trade with yourself" };
  const itemDef = window.ITEM_CATALOG ? window.ITEM_CATALOG[item.itemId] : null;
  const itemName = itemDef ? itemDef.name : item.itemId;
  const tradeRef = push(ref(db, 'casino/trades/' + recipientUid));
  await set(tradeRef, {
    from: currentUsername,
    fromUid: playerId,
    itemId: item.itemId,
    itemName: itemName,
    cash: cash || 0,
    message: message || '',
    timestamp: Date.now()
  });
  return { success: true };
};

window._loadPendingTrades = async () => {
  if (!playerId) return [];
  const snap = await get(ref(db, 'casino/trades/' + playerId));
  if (!snap.exists()) return [];
  const trades = [];
  snap.forEach(child => {
    trades.push({ id: child.key, ...child.val() });
  });
  return trades;
};

window._acceptTradeOffer = async (tradeId) => {
  if (!playerId) return;
  // Read the trade data before deleting so we can credit items/cash server-side
  const tradeSnap = await get(ref(db, 'casino/trades/' + playerId + '/' + tradeId));
  if (tradeSnap.exists()) {
    const trade = tradeSnap.val();
    // Credit the item/cash to the recipient's player data via a pending refund node
    // This ensures server-side persistence even if client crashes
    const creditData = { item: trade.itemId || null, cash: trade.cash || 0, reason: 'trade_accepted', from: trade.from || 'Unknown', ts: Date.now() };
    const creditRef = push(ref(db, 'casino/pendingRefunds/' + playerId));
    await set(creditRef, creditData);
  }
  await remove(ref(db, 'casino/trades/' + playerId + '/' + tradeId));
};

window._declineTradeOffer = async (tradeId) => {
  if (!playerId) return { error: 'Not logged in' };
  const tradeSnap = await get(ref(db, 'casino/trades/' + playerId + '/' + tradeId));
  if (!tradeSnap.exists()) return { error: 'Trade not found' };
  const trade = tradeSnap.val();
  // Refund sender: add cash back and item back via pending refund node
  if (trade.fromUid) {
    const refundData = { item: trade.itemId || null, cash: trade.cash || 0, reason: 'trade_declined', from: currentUsername || 'Unknown', ts: Date.now() };
    const refundRef = push(ref(db, 'casino/pendingRefunds/' + trade.fromUid));
    await set(refundRef, refundData);
  }
  await remove(ref(db, 'casino/trades/' + playerId + '/' + tradeId));
  return { success: true };
};

window._checkPendingRefunds = async () => {
  if (!playerId) return [];
  const snap = await get(ref(db, 'casino/pendingRefunds/' + playerId));
  if (!snap.exists()) return [];
  const refunds = [];
  snap.forEach(child => { refunds.push({ id: child.key, ...child.val() }); });
  // Clear them after reading
  await remove(ref(db, 'casino/pendingRefunds/' + playerId));
  return refunds;
};

window._checkUsernameExists = async (username) => {
  const snap = await get(ref(db, 'casino/usernames/' + username));
  return snap.exists() ? snap.val() : null;
};

window._currentPlayerId = playerId;

// ============ TRADE REQUEST SYSTEM (Firebase) ============
window._sendTradeRequest = async (recipientUsername) => {
  if (!playerId || !currentUsername) return { error: 'Not logged in' };
  const nameSnap = await get(ref(db, 'casino/usernames/' + recipientUsername));
  if (!nameSnap.exists()) return { error: 'Player not found' };
  const recipientUid = nameSnap.val();
  if (recipientUid === playerId) return { error: "Can't trade with yourself" };
  const reqRef = push(ref(db, 'casino/tradeRequests/' + recipientUid));
  await set(reqRef, { from: currentUsername, fromUid: playerId, ts: Date.now() });
  return { success: true, requestId: reqRef.key, recipientUid };
};

window._listenTradeRequestResponse = (recipientUid, requestId, onAccept, onDecline) => {
  const respRef = ref(db, 'casino/tradeRequests/' + recipientUid + '/' + requestId + '/response');
  const unsub = onValue(respRef, (snap) => {
    if (snap.exists()) {
      const resp = snap.val();
      if (resp === 'accepted') onAccept();
      else onDecline();
      unsub();
      remove(ref(db, 'casino/tradeRequests/' + recipientUid + '/' + requestId));
    }
  });
  return unsub;
};

window._loadTradeRequests = async () => {
  if (!playerId) return [];
  const snap = await get(ref(db, 'casino/tradeRequests/' + playerId));
  if (!snap.exists()) return [];
  const reqs = [];
  snap.forEach(child => {
    const d = child.val();
    if (!d.response) reqs.push({ id: child.key, ...d });
  });
  return reqs;
};

window._respondTradeRequest = async (requestId, accepted) => {
  if (!playerId) return;
  await set(ref(db, 'casino/tradeRequests/' + playerId + '/' + requestId + '/response'), accepted ? 'accepted' : 'declined');
  // Auto-cleanup after 10s
  setTimeout(() => { remove(ref(db, 'casino/tradeRequests/' + playerId + '/' + requestId)).catch(()=>{}); }, 10000);
};

// ============ LIVE TRADE SYSTEM (Firebase) ============
window._createLiveTrade = async (partnerUid, partnerName) => {
  if (!playerId || !currentUsername) return null;
  const tradeId = Date.now().toString(36) + Math.random().toString(36).slice(2, 6);
  await set(ref(db, 'casino/liveTrades/' + tradeId), {
    host: playerId,
    hostName: currentUsername,
    guest: partnerUid,
    guestName: partnerName,
    hostOffer: { items: '', cash: 0 },
    guestOffer: { items: '', cash: 0 },
    hostReady: false,
    guestReady: false,
    status: 'active',
    created: Date.now()
  });
  return tradeId;
};

window._executeLiveTrade = async (tradeId) => {
  if (!playerId) return { error: 'Not logged in' };
  const snap = await get(ref(db, 'casino/liveTrades/' + tradeId));
  if (!snap.exists()) return { error: 'Trade not found' };
  const t = snap.val();
  if (t.status !== 'active') return { error: 'Trade not active' };
  if (!t.hostReady || !t.guestReady) return { error: 'Both must confirm' };
  
  // Execute trade: swap items and cash
  const hostSnap = await get(ref(db, 'casino/players/' + t.host));
  const guestSnap = await get(ref(db, 'casino/players/' + t.guest));
  if (!hostSnap.exists() || !guestSnap.exists()) return { error: 'Player data missing' };
  
  const hostData = hostSnap.val();
  const guestData = guestSnap.val();
  const hostBal = safeNum(hostData.balance || 0);
  const guestBal = safeNum(guestData.balance || 0);
  
  const hostCash = safeNum(t.hostOffer?.cash || 0);
  const guestCash = safeNum(t.guestOffer?.cash || 0);
  
  // Check balances
  if (hostBal < hostCash) return { error: 'Host cannot afford' };
  if (guestBal < guestCash) return { error: 'Guest cannot afford' };
  
  // Transfer cash
  const updates = {};
  updates['players/' + t.host + '/balance'] = safeNum(hostBal - hostCash + guestCash);
  updates['players/' + t.guest + '/balance'] = safeNum(guestBal - guestCash + hostCash);
  
  // Transfer items via pending refunds (items are identified by itemId)
  const hostItems = (t.hostOffer?.items || '').split(',').filter(Boolean);
  const guestItems = (t.guestOffer?.items || '').split(',').filter(Boolean);
  
  // Host items go to guest, guest items go to host
  for (const itemId of hostItems) {
    const refKey = Date.now().toString(36) + Math.random().toString(36).slice(2,4);
    updates['pendingRefunds/' + t.guest + '/' + refKey] = { item: itemId, cash: 0, reason: 'live_trade', from: t.hostName, ts: Date.now() };
  }
  for (const itemId of guestItems) {
    const refKey = Date.now().toString(36) + Math.random().toString(36).slice(2,4);
    updates['pendingRefunds/' + t.host + '/' + refKey] = { item: itemId, cash: 0, reason: 'live_trade', from: t.guestName, ts: Date.now() };
  }
  
  updates['liveTrades/' + tradeId + '/status'] = 'completed';
  
  try {
    await update(ref(db, 'casino'), updates);
    return { success: true, tradeId };
  } catch(e) {
    return { error: 'Trade failed: ' + e.message };
  }
};

// ============ GIFT SYSTEM (Firebase) ============
window._giftMoney = async (recipientUsername, amount) => {
  if (!playerId || !currentUsername) return { error: 'Not logged in' };
  if (!recipientUsername || !amount || amount < 1) return { error: 'Invalid recipient or amount' };
  if (amount > 1e15) return { error: 'Gift amount too large (max $1Q)' };
  amount = safeNum(amount);
  
  // Look up recipient by username
  const nameSnap = await window._fbGet('casino/usernames/' + recipientUsername.toLowerCase());
  if (!nameSnap.val()) return { error: 'Player not found' };
  
  const recipientUid = nameSnap.val();
  if (recipientUid === playerId) return { error: "Can't gift to yourself" };
  
  // Get sender's current balance
  const senderSnap = await window._fbGet('casino/players/' + playerId);
  const senderBal = senderSnap.val()?.balance || 0;
  
  if (senderBal < amount) return { error: 'Insufficient balance' };
  
  // Get recipient's current balance
  const recipientSnap = await window._fbGet('casino/players/' + recipientUid);
  const recipientBal = recipientSnap.val()?.balance || 0;
  
  // Transfer money
  const newSenderBal = safeNum(senderBal - amount);
  const newRecipientBal = safeNum(recipientBal + amount);
  
  // Update both balances atomically
  const updates = {};
  updates['players/' + playerId + '/balance'] = newSenderBal;
  updates['players/' + recipientUid + '/balance'] = newRecipientBal;
  
  try {
    await window._fbUpdate('casino', updates);
    console.log(`Gift sent: ${currentUsername} -> ${recipientUsername}: $${amount}`);
    return { success: true, newBalance: newSenderBal };
  } catch(err) {
    console.error('Gift error:', err);
    return { error: 'Transfer failed' };
  }
};

// ============ STORE / MARKETPLACE (Firebase) ============
window._storeListItem = async (listing) => {
  if (!playerId || !currentUsername) return { error: 'Not logged in' };
  if (!listing.price || listing.price < 1 || listing.price > 999999999) return { error: 'Invalid price' };
  if (!listing.itemId || !listing.itemName) return { error: 'Invalid item' };
  const listRef = push(ref(db, 'casino/store/listings'));
  const data = {
    seller: currentUsername,
    sellerUid: playerId,
    itemId: listing.itemId,
    itemName: listing.itemName,
    rarity: listing.rarity,
    type: listing.type, // 'fixed' or 'auction'
    price: listing.price || 0, // fixed price or starting bid
    currentBid: listing.type === 'auction' ? (listing.price || 0) : 0,
    highBidder: '',
    highBidderUid: '',
    endsAt: listing.type === 'auction' ? (Date.now() + (listing.duration || 1800000)) : 0,
    listedAt: Date.now(),
    sold: false
  };
  await set(listRef, data);
  return { success: true, listingId: listRef.key };
};

window._storeGetListings = async () => {
  const snap = await get(ref(db, 'casino/store/listings'));
  if (!snap.exists()) return [];
  const arr = [];
  snap.forEach(child => {
    const d = child.val();
    if (!d.sold) arr.push({ id: child.key, ...d });
  });
  return arr;
};

window._storeBuyItem = async (listingId) => {
  if (!playerId || !currentUsername) return { error: 'Not logged in' };
  const listRef = ref(db, 'casino/store/listings/' + listingId);
  try {
    const snap = await get(listRef);
    if (!snap.exists()) return { error: 'Listing not found' };
    const d = snap.val();
    if (d.sold) return { error: 'Already sold' };
    if (d.sellerUid === playerId) return { error: "Can't buy your own item" };
    if (d.type === 'auction') return { error: 'This is an auction — place a bid instead' };
    // Mark as sold
    await update(listRef, { sold: true, buyer: currentUsername, buyerUid: playerId, soldAt: Date.now() });
    // Credit seller via pending refund system
    if (d.sellerUid && d.price > 0) {
      const payRef = push(ref(db, 'casino/pendingRefunds/' + d.sellerUid));
      await set(payRef, { item: null, cash: d.price, reason: 'store_sale', from: currentUsername, itemName: d.itemName || d.itemId, ts: Date.now() });
    }
    // Log sale
    const saleRef = push(ref(db, 'casino/store/sales'));
    await set(saleRef, { itemId: d.itemId, itemName: d.itemName, rarity: d.rarity, price: d.price, seller: d.seller, buyer: currentUsername, ts: Date.now() });
    return { success: true, item: d };
  } catch(e) { return { error: 'Purchase failed: ' + (e.message || 'unknown') }; }
};

window._storePlaceBid = async (listingId, bidAmount) => {
  if (!playerId || !currentUsername) return { error: 'Not logged in' };
  const listRef = ref(db, 'casino/store/listings/' + listingId);
  try {
    const snap = await get(listRef);
    if (!snap.exists()) return { error: 'Listing not found' };
    const d = snap.val();
    if (d.sold) return { error: 'Already sold' };
    if (d.sellerUid === playerId) return { error: "Can't bid on your own item" };
    if (d.type !== 'auction') return { error: 'Not an auction' };
    if (Date.now() > d.endsAt) return { error: 'Auction ended' };
    if (bidAmount <= (d.currentBid || 0)) return { error: 'Bid must be higher than $' + (d.currentBid || 0) + ' (someone outbid you)' };
    const oldBidderUid = d.highBidderUid || '';
    const oldBidAmount = d.currentBid || 0;
    const itemNameForRefund = d.itemName || d.itemId;
    // Place bid
    await update(listRef, { currentBid: bidAmount, highBidder: currentUsername, highBidderUid: playerId });
    // Refund previous highest bidder
    if (oldBidderUid && oldBidAmount > 0 && oldBidderUid !== playerId) {
      const refundRef = push(ref(db, 'casino/pendingRefunds/' + oldBidderUid));
      await set(refundRef, { item: null, cash: oldBidAmount, reason: 'outbid', from: currentUsername, itemName: itemNameForRefund, ts: Date.now() });
    }
    return { success: true, oldBidderUid: oldBidderUid, oldBid: oldBidAmount };
  } catch(e) { return { error: 'Bid failed: ' + (e.message || 'unknown') }; }
};

window._storeCancelListing = async (listingId) => {
  if (!playerId) return { error: 'Not logged in' };
  const listRef = ref(db, 'casino/store/listings/' + listingId);
  try {
    const snap = await get(listRef);
    if (!snap.exists()) return { error: 'Listing not found' };
    const d = snap.val();
    if (d.sellerUid !== playerId) return { error: 'Not your listing' };
    if (d.sold) return { error: 'Already sold' };
    // Refund highest bidder if auction
    if (d.type === 'auction' && d.highBidderUid && d.currentBid > 0) {
      const refundRef = push(ref(db, 'casino/pendingRefunds/' + d.highBidderUid));
      await set(refundRef, { item: null, cash: d.currentBid, reason: 'listing_cancelled', from: d.seller, itemName: d.itemName || d.itemId, ts: Date.now() });
    }
    // Remove the listing
    await remove(listRef);
    return { success: true, item: d };
  } catch(e) { return { error: 'Cancel failed: ' + (e.message || 'unknown') }; }
};

window._storeGetSales = async () => {
  const snap = await get(ref(db, 'casino/store/sales'));
  if (!snap.exists()) return [];
  const arr = [];
  snap.forEach(child => { arr.push({ id: child.key, ...child.val() }); });
  arr.sort((a, b) => b.ts - a.ts);
  return arr.slice(0, 50);
};

window._storeClaimAuction = async (listingId) => {
  if (!playerId) return { error: 'Not logged in' };
  const listRef = ref(db, 'casino/store/listings/' + listingId);
  try {
    const snap = await get(listRef);
    if (!snap.exists()) return { error: 'Listing not found' };
    const d = snap.val();
    if (d.sold) return { error: 'Already claimed' };
    if (Date.now() < d.endsAt) return { error: 'Auction not ended yet' };
    // No bids — seller reclaims
    if (!d.highBidderUid) {
      if (d.sellerUid !== playerId) return { error: 'Only the seller can reclaim unsold items' };
      await remove(listRef);
      return { success: true, noBids: true, item: d };
    }
    // Has bids — seller or winner claims
    if (d.sellerUid !== playerId && d.highBidderUid !== playerId) return { error: 'Only the seller or winner can claim' };
    await update(listRef, { sold: true, buyer: d.highBidder, buyerUid: d.highBidderUid, soldAt: Date.now() });
    // Credit seller with auction proceeds
    if (d.sellerUid && d.currentBid > 0) {
      const payRef = push(ref(db, 'casino/pendingRefunds/' + d.sellerUid));
      await set(payRef, { item: null, cash: d.currentBid, reason: 'auction_sold', from: d.highBidder, itemName: d.itemName || d.itemId, ts: Date.now() });
    }
    // Credit buyer with the item
    if (d.highBidderUid) {
      const itemRef = push(ref(db, 'casino/pendingRefunds/' + d.highBidderUid));
      await set(itemRef, { item: d.itemId, cash: 0, reason: 'auction_won', from: d.seller, itemName: d.itemName || d.itemId, ts: Date.now() });
    }
    const saleRef = push(ref(db, 'casino/store/sales'));
    await set(saleRef, { itemId: d.itemId, itemName: d.itemName, rarity: d.rarity, price: d.currentBid, seller: d.seller, buyer: d.highBidder, ts: Date.now(), auction: true });
    return { success: true, item: d };
  } catch(e) { return { error: 'Claim failed: ' + (e.message || 'unknown') }; }
};

// ============ FRIEND SYSTEM (Firebase) ============
window._setOnlineStatus = (online) => {
  if (!playerId) return;
  set(ref(db, 'casino/presence/' + playerId), { online, username: currentUsername, lastSeen: Date.now() });
};

window._sendFriendRequest = async (targetUsername) => {
  if (!playerId || !currentUsername) return { error: 'Not logged in' };
  const nameSnap = await get(ref(db, 'casino/usernames/' + targetUsername));
  if (!nameSnap.exists()) return { error: 'Player not found' };
  const targetUid = nameSnap.val();
  if (targetUid === playerId) return { error: "Can't add yourself" };
  // check if blocked
  const blockSnap = await get(ref(db, 'casino/social/' + playerId + '/blocked/' + targetUid));
  if (blockSnap.exists()) return { error: 'You have blocked this player' };
  const blockSnap2 = await get(ref(db, 'casino/social/' + targetUid + '/blocked/' + playerId));
  if (blockSnap2.exists()) return { error: 'This player has blocked you' };
  // check already friends
  const frSnap = await get(ref(db, 'casino/social/' + playerId + '/friends/' + targetUid));
  if (frSnap.exists()) return { error: 'Already friends' };
  // check pending
  const pendSnap = await get(ref(db, 'casino/social/' + targetUid + '/requests/' + playerId));
  if (pendSnap.exists()) return { error: 'Request already sent' };
  // Check target privacy
  const privSnap = await get(ref(db, 'casino/social/' + targetUid + '/privacy'));
  const priv = privSnap.exists() ? privSnap.val() : {};
  if (priv.friendRequests === 'nobody') return { error: 'This player is not accepting friend requests' };
  if (priv.friendRequests === 'friends_only') return { error: 'This player only accepts requests from mutual friends' };
  await set(ref(db, 'casino/social/' + targetUid + '/requests/' + playerId), { from: currentUsername, fromUid: playerId, ts: Date.now() });
  return { success: true };
};

window._loadFriendRequests = async () => {
  if (!playerId) return [];
  const snap = await get(ref(db, 'casino/social/' + playerId + '/requests'));
  if (!snap.exists()) return [];
  const arr = [];
  snap.forEach(child => { arr.push({ uid: child.key, ...child.val() }); });
  return arr;
};

window._acceptFriendRequest = async (fromUid, fromUsername) => {
  if (!playerId) return;
  await set(ref(db, 'casino/social/' + playerId + '/friends/' + fromUid), { username: fromUsername, since: Date.now() });
  await set(ref(db, 'casino/social/' + fromUid + '/friends/' + playerId), { username: currentUsername, since: Date.now() });
  await remove(ref(db, 'casino/social/' + playerId + '/requests/' + fromUid));
};

window._declineFriendRequest = async (fromUid) => {
  if (!playerId) return;
  await remove(ref(db, 'casino/social/' + playerId + '/requests/' + fromUid));
};

window._removeFriend = async (friendUid) => {
  if (!playerId) return;
  await remove(ref(db, 'casino/social/' + playerId + '/friends/' + friendUid));
  await remove(ref(db, 'casino/social/' + friendUid + '/friends/' + playerId));
};

window._blockPlayer = async (targetUsername) => {
  if (!playerId) return { error: 'Not logged in' };
  const nameSnap = await get(ref(db, 'casino/usernames/' + targetUsername));
  if (!nameSnap.exists()) return { error: 'Player not found' };
  const targetUid = nameSnap.val();
  if (targetUid === playerId) return { error: "Can't block yourself" };
  await set(ref(db, 'casino/social/' + playerId + '/blocked/' + targetUid), { username: targetUsername, ts: Date.now() });
  // Auto remove friend if exists
  await remove(ref(db, 'casino/social/' + playerId + '/friends/' + targetUid));
  await remove(ref(db, 'casino/social/' + targetUid + '/friends/' + playerId));
  // Remove any pending requests
  await remove(ref(db, 'casino/social/' + playerId + '/requests/' + targetUid));
  await remove(ref(db, 'casino/social/' + targetUid + '/requests/' + playerId));
  return { success: true };
};

window._unblockPlayer = async (targetUid) => {
  if (!playerId) return;
  await remove(ref(db, 'casino/social/' + playerId + '/blocked/' + targetUid));
};

window._loadFriendsList = async () => {
  if (!playerId) return [];
  const snap = await get(ref(db, 'casino/social/' + playerId + '/friends'));
  if (!snap.exists()) return [];
  const arr = [];
  snap.forEach(child => { arr.push({ uid: child.key, ...child.val() }); });
  return arr;
};

window._loadBlockedList = async () => {
  if (!playerId) return [];
  const snap = await get(ref(db, 'casino/social/' + playerId + '/blocked'));
  if (!snap.exists()) return [];
  const arr = [];
  snap.forEach(child => { arr.push({ uid: child.key, ...child.val() }); });
  return arr;
};

window._getPresence = async (uid) => {
  const snap = await get(ref(db, 'casino/presence/' + uid));
  return snap.exists() ? snap.val() : { online: false, lastSeen: 0 };
};

window._getPresenceBatch = async (uids) => {
  const results = {};
  for (const uid of uids) {
    const snap = await get(ref(db, 'casino/presence/' + uid));
    results[uid] = snap.exists() ? snap.val() : { online: false, lastSeen: 0 };
  }
  return results;
};

window._sendDirectMessage = async (toUid, toUsername, text) => {
  if (!playerId || !currentUsername) return { error: 'Not logged in' };
  const msgData = { from: currentUsername, fromUid: playerId, text, ts: Date.now(), read: false };
  const key1 = playerId < toUid ? playerId + '_' + toUid : toUid + '_' + playerId;
  await push(ref(db, 'casino/dms/' + key1), msgData);
  return { success: true };
};

window._loadDirectMessages = async (otherUid) => {
  if (!playerId) return [];
  const key1 = playerId < otherUid ? playerId + '_' + otherUid : otherUid + '_' + playerId;
  const snap = await get(ref(db, 'casino/dms/' + key1));
  if (!snap.exists()) return [];
  const arr = [];
  snap.forEach(child => { arr.push({ id: child.key, ...child.val() }); });
  arr.sort((a, b) => a.ts - b.ts);
  return arr;
};

window._listenDirectMessages = (otherUid, callback) => {
  const key1 = playerId < otherUid ? playerId + '_' + otherUid : otherUid + '_' + playerId;
  return onValue(ref(db, 'casino/dms/' + key1), (snap) => {
    const arr = [];
    if (snap.exists()) snap.forEach(child => { arr.push({ id: child.key, ...child.val() }); });
    arr.sort((a, b) => a.ts - b.ts);
    callback(arr);
  });
};

window._savePrivacySettings = async (settings) => {
  if (!playerId) return;
  await set(ref(db, 'casino/social/' + playerId + '/privacy'), settings);
};

window._loadPrivacySettings = async () => {
  if (!playerId) return {};
  const snap = await get(ref(db, 'casino/social/' + playerId + '/privacy'));
  return snap.exists() ? snap.val() : {};
};

window._getMutualFriends = async (otherUid) => {
  if (!playerId) return [];
  const mySnap = await get(ref(db, 'casino/social/' + playerId + '/friends'));
  const theirSnap = await get(ref(db, 'casino/social/' + otherUid + '/friends'));
  if (!mySnap.exists() || !theirSnap.exists()) return [];
  const myFriends = new Set();
  mySnap.forEach(c => myFriends.add(c.key));
  const mutual = [];
  theirSnap.forEach(c => { if (myFriends.has(c.key)) mutual.push({ uid: c.key, ...c.val() }); });
  return mutual;
};

// ============ PYL Firebase helpers ============
window._pylCreateRoom = (roomCode, wager) => {
  const sid = window._currentPylSessionId;
  const name = window._currentUsername || sid.slice(-5);
  const roomRef = ref(db, 'casino/pylRooms/' + roomCode);
  return set(roomRef, {
    host: sid,
    wager: wager,
    status: 'waiting',
    created: Date.now(),
    players: { [sid]: { name: name, score: null, ready: true, online: true } }
  }).then(() => {
    const playerOnlineRef = ref(db, 'casino/pylRooms/' + roomCode + '/players/' + sid + '/online');
    onDisconnect(playerOnlineRef).set(false);
    onDisconnect(roomRef).remove();
  });
};

// Read-only room peek (checks existence + wager without joining)
window._pylPeekRoom = async (roomCode) => {
  const roomRef = ref(db, 'casino/pylRooms/' + roomCode);
  const snap = await get(roomRef);
  if (!snap.exists()) return null;
  const data = snap.val();
  if (data.status !== 'waiting') return null;
  return data;
};

window._pylJoinRoom = async (roomCode) => {
  const sid = window._currentPylSessionId;
  const name = window._currentUsername || sid.slice(-5);
  const roomRef = ref(db, 'casino/pylRooms/' + roomCode);
  const snap = await get(roomRef);
  if (!snap.exists()) return null;
  const data = snap.val();
  if (data.status !== 'waiting') return null;
  if (data.host === sid) return null;
  await update(ref(db, 'casino/pylRooms/' + roomCode + '/players'), {
    [sid]: { name: name, score: null, ready: true, online: true }
  });
  await update(roomRef, { status: 'playing' });
  const playerOnlineRef = ref(db, 'casino/pylRooms/' + roomCode + '/players/' + sid + '/online');
  onDisconnect(playerOnlineRef).set(false);
  onDisconnect(roomRef).cancel();
  return data;
};

window._pylSubmitRoomScore = (roomCode, score) => {
  const sid = window._currentPylSessionId;
  return update(ref(db, 'casino/pylRooms/' + roomCode + '/players/' + sid), { score: score });
};

window._pylListenRoom = (roomCode, callback) => {
  const roomRef = ref(db, 'casino/pylRooms/' + roomCode);
  onValue(roomRef, snap => { callback(snap.val()); });
  return () => off(roomRef);
};

window._pylFinishRoom = (roomCode) => {
  return update(ref(db, 'casino/pylRooms/' + roomCode), { status: 'finished' });
};

window._pylDeleteRoom = (roomCode) => {
  return remove(ref(db, 'casino/pylRooms/' + roomCode));
};

window._pylCancelDisconnect = (roomCode) => {
  const sid = window._currentPylSessionId;
  const playerOnlineRef = ref(db, 'casino/pylRooms/' + roomCode + '/players/' + sid + '/online');
  onDisconnect(playerOnlineRef).cancel();
  const roomRef = ref(db, 'casino/pylRooms/' + roomCode);
  onDisconnect(roomRef).cancel();
};

window._pylMarkOffline = (roomCode) => {
  const sid = window._currentPylSessionId;
  return update(ref(db, 'casino/pylRooms/' + roomCode + '/players/' + sid), { online: false });
};

window._pylWriteChoice = (roomCode, round, choice) => {
  const sid = window._currentPylSessionId;
  return set(ref(db, 'casino/pylRooms/' + roomCode + '/choices/' + round + '/' + sid), choice);
};

let _pylChoiceUnsub = null;
window._pylListenChoice = (roomCode, round, opponentId, callback) => {
  if (_pylChoiceUnsub) { _pylChoiceUnsub(); _pylChoiceUnsub = null; }
  const choiceRef = ref(db, 'casino/pylRooms/' + roomCode + '/choices/' + round + '/' + opponentId);
  onValue(choiceRef, snap => {
    const val = snap.val();
    if (val !== null) {
      callback(val);
      if (_pylChoiceUnsub) { _pylChoiceUnsub(); _pylChoiceUnsub = null; }
    }
  });
  _pylChoiceUnsub = () => off(choiceRef);
};

window._pylGetLeaderboard = async () => {
  const snap = await get(ref(db, 'casino/leaderboards/pyl'));
  if (!snap.exists()) return [];
  const data = snap.val();
  return Object.entries(data).map(([uid, e]) => ({ player: e.name, score: e.value })).sort((a, b) => b.score - a.score).slice(0, 20);
};

window._pylSubmitLeaderboard = (score) => {
  if (!playerId || !currentUsername) return Promise.resolve();
  return set(ref(db, 'casino/leaderboards/pyl/' + playerId), {
    name: currentUsername,
    value: score,
    updated: Date.now()
  });
};

// ============ FIREBASE BRIDGE FOR GAME SCRIPTS ============
// Expose Firebase functions so the main game script can use them for Prestige & Duels
window._fbRef = (path) => ref(db, path);
window._fbSet = (path, data) => set(ref(db, path), data);
window._fbGet = (path) => get(ref(db, path));
window._fbUpdate = (path, data) => update(ref(db, path), data);
window._fbRemove = (path) => remove(ref(db, path));
window._fbOnValue = (path, cb) => { const r = ref(db, path); onValue(r, cb); return () => off(r); };
window._fbOnDisconnect = (path) => onDisconnect(ref(db, path));

// ============ GLOBAL CHAT (Firebase) ============
let chatListener = null;
let chatPresenceRef = null;

window._initChat = () => {
  if (chatListener) return; // already listening
  const chatRef = ref(db, 'casino/chat');
  // Use query to limit to last 60 messages instead of downloading all
  const chatQuery = fbQuery(chatRef, fbLimitToLast(60));
  onValue(chatQuery, (snap) => {
    const msgs = [];
    snap.forEach(child => { msgs.push({ id: child.key, ...child.val() }); });
    window._onChatMessages(msgs);
  });
  chatListener = chatQuery;

  // Presence tracking (unified schema with _setOnlineStatus)
  if (playerId) {
    chatPresenceRef = ref(db, 'casino/presence/' + playerId);
    set(chatPresenceRef, { online: true, username: currentUsername || 'Guest', lastSeen: Date.now() });
    onDisconnect(chatPresenceRef).set({ online: false, username: currentUsername || 'Guest', lastSeen: Date.now() });
    // Update presence periodically
    window._chatPresenceInterval = setInterval(() => {
      if (chatPresenceRef) set(chatPresenceRef, { online: true, username: currentUsername || 'Guest', lastSeen: Date.now() }).catch(()=>{});
    }, 120000); // Every 2 min instead of 30s — reduces presence writes by 4x
  }

  // Poll online count every 30s instead of real-time listener (saves HUGE bandwidth)
  // Each onValue on /presence downloads ALL entries on every single write
  async function _pollOnlineCount() {
    try {
      const snap = await get(ref(db, 'casino/presence'));
      let count = 0;
      const now = Date.now();
      snap.forEach(child => {
        const v = child.val();
        if (!v) return;
        const lastActive = v.lastSeen || v.ts || 0;
        if (v.online || (lastActive && (now - lastActive) < 120000)) count++;
      });
      window._onChatOnlineCount(count);
    } catch(e) {}
  }
  _pollOnlineCount();
  window._presenceCountInterval = setInterval(_pollOnlineCount, 30000);
};

window._sendChatMsg = async (text, username, type) => {
  if (!text || text.length === 0) return;
  const chatRef = ref(db, 'casino/chat');
  const msgRef = push(chatRef);
  const uname = (username || 'Guest').toLowerCase();
  let role = '';
  if (uname === 'mojheh') role = 'owner';
  else if (uname === 'terpez') role = 'co-owner';
  await set(msgRef, {
    user: username || 'Guest',
    text: text.slice(0, 200),
    type: type || 'msg', // 'msg', 'win', 'system'
    ts: Date.now(),
    prestige: window._getPrestige ? window._getPrestige() : 0,
    role: role,
    profilePicUrl: window._getProfilePicUrl ? window._getProfilePicUrl() : null
  });
  // Trim old messages (keep last 100)
  const snap = await get(chatRef);
  const keys = [];
  snap.forEach(child => keys.push(child.key));
  if (keys.length > 100) {
    const toDelete = keys.slice(0, keys.length - 100);
    const updates = {};
    toDelete.forEach(k => { updates[k] = null; });
    update(chatRef, updates).catch(()=>{});
  }
};

window._broadcastWin = (username, game, amount) => {
  if (!username || amount < 500) return; // Only broadcast wins over $500
  amount = safeNum(amount);
  const text = `${username} just won $${formatBalance(amount)} on ${game}! 🎉`;
  window._sendChatMsg(text, 'System', 'win').catch(()=>{});
};
</script>

<script>
// ============ GLOBAL STATE ============
const MAX_BALANCE = 1e18; // $1 Quintillion hard cap
const MIN_BALANCE = 0; // No debt allowed
function safeNum(v) {
  if (typeof v !== 'number' || !isFinite(v)) return 0;
  return Math.max(MIN_BALANCE, Math.min(MAX_BALANCE, Math.round(v * 100) / 100));
}
let balance = 1000;
window.getBalance=()=>balance;
window.setBalance=(v)=>{balance=safeNum(v);updateBalDisplay();};

function formatBalance(v){
  if(typeof v!=='number'||!isFinite(v))return'$0.00';
  v=safeNum(v);
  const sign=v<0?'-':'';
  const abs=Math.abs(v);
  if(abs>=1e18)return sign+(abs/1e18).toFixed(2)+'Qi';
  if(abs>=1e15)return sign+(abs/1e15).toFixed(2)+'Q';
  if(abs>=1e12)return sign+(abs/1e12).toFixed(2)+'T';
  if(abs>=1e9)return sign+(abs/1e9).toFixed(2)+'B';
  if(abs>=1e6)return sign+(abs/1e6).toFixed(2)+'M';
  if(abs>=1e4)return sign+(abs/1e3).toFixed(1)+'K';
  return v.toFixed(2);
}
function updateBalDisplay(){
  balance=safeNum(balance);
  const el=document.getElementById('balText');
  el.textContent=formatBalance(balance);
  el.title='$'+balance.toLocaleString(undefined,{minimumFractionDigits:2,maximumFractionDigits:2});
  el.style.transition='transform .15s';
  el.style.transform='scale(1.15)';
  setTimeout(()=>{el.style.transform='scale(1)';},150);
  // Pity system: auto-give $100 when player hits $0 or below (prevent debt)
  if(balance<=0 && !window._pityOffered){
    window._pityOffered=true;
    // Clamp balance to 0 (no debt allowed)
    if(balance<0) balance=0;
    setTimeout(()=>{
      if(balance<=0){
        balance+=100;
        updateBalDisplay();
        firebaseSave();
        showToast('💸 Pity bonus! Here\'s $100 to get back on your feet.',true);
      }
      window._pityOffered=false;
    },1500);
  }
}

let _lastAddMoney=0;
let _addMoneySessionTotal=0;
const _ADD_MONEY_SESSION_CAP=5000; // max $5K free money per session
function addMoney(amt){if(amt<=0||amt>1000)return;if(_addMoneySessionTotal>=_ADD_MONEY_SESSION_CAP){showToast('Free money limit reached for this session!',false);return;}if(balance>100){showToast('Pity money is only for broke players!',false);return;}if(Date.now()-_lastAddMoney<10000){showToast('Cooldown! Wait 10s',false);return;}_lastAddMoney=Date.now();const give=Math.min(amt,_ADD_MONEY_SESSION_CAP-_addMoneySessionTotal);balance+=give;_addMoneySessionTotal+=give;updateBalDisplay();firebaseSave();showToast('+$'+give+' (pity money)',true);}
let _fbSaveTimer=null, _fbSaveDirty=false;
function firebaseSave(){
  _fbSaveDirty=true;
  if(_fbSaveTimer)return; // already scheduled
  _fbSaveTimer=setTimeout(()=>{
    _fbSaveTimer=null;
    if(_fbSaveDirty && window._firebaseSave){ _fbSaveDirty=false; window._firebaseSave(); }
  },5000);
}
function firebaseSaveNow(){ // immediate save for critical actions (logout, prestige, trade)
  if(_fbSaveTimer){clearTimeout(_fbSaveTimer);_fbSaveTimer=null;}
  _fbSaveDirty=false;
  if(window._firebaseSave) window._firebaseSave();
}

// ============ AUTH UI ============
let authIsRegister = false;
let isGuestMode = false;

function authGuestMode() {
  isGuestMode = true;
  let guestId = localStorage.getItem('casino_guest_id');
  if (!guestId) {
    guestId = 'guest_' + Math.random().toString(36).substr(2, 8);
    localStorage.setItem('casino_guest_id', guestId);
  }
  // Load from localStorage
  const savedBal = localStorage.getItem('casino_guest_balance');
  if (savedBal != null) { balance = safeNum(parseFloat(savedBal)); }
  const savedStats = localStorage.getItem('casino_guest_stats');
  if (savedStats) try { playerStats = JSON.parse(savedStats); } catch(e) {}
  const savedGameStats = localStorage.getItem('casino_guest_gameStats');
  if (savedGameStats) try { gameStats = JSON.parse(savedGameStats); } catch(e) {}

  window._currentPlayerId = guestId;
  window._currentUsername = 'Guest';
  window._pylPlayerId = guestId;
  window._currentPylSessionId = guestId;

  // Override save to use localStorage
  window._firebaseSave = () => {
    localStorage.setItem('casino_guest_balance', balance.toString());
    localStorage.setItem('casino_guest_stats', JSON.stringify(playerStats));
    localStorage.setItem('casino_guest_gameStats', JSON.stringify(gameStats));
  };
  // Guests don't write to leaderboards, chat, or market
  window._recordGameResult = () => {};
  window._claimDailyBonus = async () => null;
  window._sendChatMsg = async () => {};
  window._broadcastWin = () => {};
  window._updateGlobalMarketItem = async () => {};
  window._initGlobalMarket = () => {};

  window._onAuthReady('Guest', guestId);
}

// Login screen particles
(function initLoginParticles() {
  const c = document.getElementById('loginParticles');
  if (!c) return;
  for (let i = 0; i < 40; i++) {
    const d = document.createElement('div');
    d.style.left = Math.random() * 100 + '%';
    d.style.animationDuration = (3 + Math.random() * 6) + 's';
    d.style.animationDelay = (Math.random() * 5) + 's';
    d.style.width = d.style.height = (2 + Math.random() * 3) + 'px';
    c.appendChild(d);
  }
})();

function authToggleMode() {
  authIsRegister = !authIsRegister;
  document.getElementById('authSubmitBtn').textContent = authIsRegister ? 'CREATE ACCOUNT' : 'SIGN IN';
  document.getElementById('authToggleBtn').textContent = authIsRegister ? 'BACK TO SIGN IN' : 'CREATE ACCOUNT';
  document.getElementById('authToggleText').innerHTML = authIsRegister
    ? 'Already have an account? <a onclick="authToggleMode()">Sign in</a>'
    : 'Don\'t have an account? <a onclick="authToggleMode()">Sign up</a>';
  document.getElementById('authError').textContent = '';
}

async function authSubmit() {
  const username = document.getElementById('authUsername').value.trim();
  const password = document.getElementById('authPassword').value;
  const errEl = document.getElementById('authError');
  const btn = document.getElementById('authSubmitBtn');
  errEl.textContent = '';
  btn.disabled = true;
  btn.textContent = authIsRegister ? 'CREATING...' : 'SIGNING IN...';
  try {
    await window._authSubmit(username, password, authIsRegister);
  } catch (e) {
    let msg = e.message || 'Unknown error';
    if (msg.includes('auth/email-already-in-use')) msg = 'Username already taken';
    else if (msg.includes('auth/invalid-credential') || msg.includes('auth/wrong-password') || msg.includes('auth/user-not-found')) msg = 'Invalid username or password';
    else if (msg.includes('auth/too-many-requests')) msg = 'Too many attempts. Try again later';
    else if (msg.includes('auth/weak-password')) msg = 'Password must be at least 6 characters';
    errEl.textContent = msg;
  }
  btn.disabled = false;
  btn.textContent = authIsRegister ? 'CREATE ACCOUNT' : 'SIGN IN';
}

function authLogout() {
  firebaseSaveNow();
  isGuestMode = false;
  if (window._authLogout) window._authLogout();
  else window._onAuthLoggedOut(); // For guest mode (no Firebase auth to sign out of)
}

// Auth state callbacks (called from module)
// ============ PENDING REFUNDS CHECKER ============
async function checkPendingRefunds() {
  if (!window._checkPendingRefunds) return;
  try {
    const refunds = await window._checkPendingRefunds();
    if (!refunds || refunds.length === 0) return;
    let totalCash = 0;
    let itemsReceived = [];
    refunds.forEach(r => {
      if (r.cash > 0) { balance += r.cash; totalCash += r.cash; }
      if (r.item && r.item !== '_cash_' && r.item !== null) {
        addToInventory(r.item);
        const cat = ITEM_CATALOG[r.item];
        itemsReceived.push(cat ? cat.name : r.itemName || r.item);
      }
    });
    if (totalCash > 0 || itemsReceived.length > 0) {
      updateBalDisplay();
      renderInventory();
      firebaseSave();
      let msg = '📬 ';
      if (totalCash > 0) msg += '+$' + totalCash.toFixed(0);
      if (itemsReceived.length > 0) msg += (totalCash > 0 ? ' + ' : '') + itemsReceived.join(', ');
      const reasons = [...new Set(refunds.map(r => r.reason))];
      if (reasons.includes('trade_declined')) msg += ' (trade returned)';
      else if (reasons.includes('outbid')) msg += ' (outbid refund)';
      else if (reasons.includes('store_sale') || reasons.includes('auction_sold')) msg += ' (sale proceeds)';
      else if (reasons.includes('listing_cancelled')) msg += ' (listing cancelled)';
      else if (reasons.includes('auction_won')) msg += ' (auction won)';
      showToast(msg, true);
    }
  } catch(e) { /* silent */ }
}

window._onAuthReady = function(username, uid) {
  document.getElementById('loginScreen').style.display = 'none';
  document.getElementById('topNav').style.display = '';
  const uaInit = (username && username[0] || '?').toUpperCase();
  document.getElementById('userAvatar').innerHTML = `<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false"><defs><linearGradient id="avG" x1="0" x2="1"><stop offset="0" stop-color="#00f0ff"/><stop offset="1" stop-color="#6b2fd9"/></linearGradient></defs><circle cx="50" cy="50" r="48" fill="url(#avG)"/><text x="50" y="58" font-family="Orbitron,Inter,sans-serif" font-weight="900" font-size="48" fill="#fff" text-anchor="middle">${uaInit}</text></svg>`;
  document.getElementById('userNameDisplay').textContent = username;
  // Apply custom PFP if set
  if (typeof applyPfp === 'function' && selectedPfp) applyPfp();
  updateBalDisplay();
  checkDailyBonus();
  // Show chat button
  document.getElementById('chatToggleBtn').style.display = 'flex';
  // Auto-init chat
  if (!chatInitialized && window._initChat) {
    window._initChat();
    chatInitialized = true;
  }
  // Check for pending refunds (declined trades, outbid refunds, store payments)
  checkPendingRefunds();
  // Check refunds periodically (every 30s)
  if (!window._refundInterval) {
    window._refundInterval = setInterval(checkPendingRefunds, 30000);
  }
  // Listen for RR PvP challenges
  if (typeof rrListenForChallenges === 'function') rrListenForChallenges();
};

window._onAuthLoggedOut = function() {
  if (isGuestMode) return; // Don't show login if in guest mode
  document.getElementById('loginScreen').style.display = '';
  document.getElementById('topNav').style.display = 'none';
  document.querySelectorAll('.game-panel').forEach(p => p.classList.remove('active'));
  // Clear pending refund interval
  if (window._refundInterval) { clearInterval(window._refundInterval); window._refundInterval = null; }
  if (window._onlineStatusInterval) { clearInterval(window._onlineStatusInterval); window._onlineStatusInterval = null; }
  if (window._chatPresenceInterval) { clearInterval(window._chatPresenceInterval); window._chatPresenceInterval = null; }
  if (window._presenceCountInterval) { clearInterval(window._presenceCountInterval); window._presenceCountInterval = null; }
  if (typeof stockTickInterval !== 'undefined' && stockTickInterval) { clearInterval(stockTickInterval); stockTickInterval = null; }
  // Reset active game states to prevent cross-account leaks
  try {
    if (typeof crashRunning !== 'undefined') crashRunning = false;
    if (typeof bjActive !== 'undefined') bjActive = false;
    if (typeof minesActive !== 'undefined') minesActive = false;
    if (typeof towerActive !== 'undefined') towerActive = false;
    if (typeof hiloActive !== 'undefined') hiloActive = false;
    if (typeof pylGameActive !== 'undefined') pylGameActive = false;
    if (typeof autoDropping !== 'undefined') autoDropping = false;
    if (typeof rouletteSpinning !== 'undefined') rouletteSpinning = false;
    if (typeof limboRolling !== 'undefined') limboRolling = false;
    if (typeof pokerPhase !== 'undefined') pokerPhase = 'idle';
    // Reset balance and inventory
    if (typeof balance !== 'undefined') balance = 1000;
    if (typeof inventory !== 'undefined') inventory = [];
    if (typeof tradeHistory !== 'undefined') tradeHistory = [];
    if (typeof chatInitialized !== 'undefined') chatInitialized = false;
    updateBalDisplay();
  } catch(e) {}
};

// Enter key on login
document.getElementById('authPassword').addEventListener('keydown', function(e) {
  if (e.key === 'Enter') authSubmit();
});
document.getElementById('authUsername').addEventListener('keydown', function(e) {
  if (e.key === 'Enter') document.getElementById('authPassword').focus();
});

// ============ STATS TRACKING ============
let playerStats = { totalWagered: 0, totalWon: 0, totalProfit: 0, gamesPlayed: 0, biggestWin: 0 };
let gameStats = {
  slots: { played: 0, won: 0, biggestWin: 0 },
  crash: { played: 0, won: 0, biggestMultiplier: 0, biggestWin: 0 },
  roulette: { played: 0, won: 0, biggestWin: 0 },
  cases: { played: 0, opened: 0, bestItem: '' },
  plinko: { played: 0, won: 0, biggestWin: 0 },
  pyl: { played: 0, highScore: 0 },
  blackjack: { played: 0, won: 0, biggestWin: 0 },
  mines: { played: 0, won: 0, biggestWin: 0 },
  dice: { played: 0, won: 0, biggestWin: 0 },
  tower: { played: 0, won: 0, biggestWin: 0 },
  coinflip: { played: 0, won: 0, biggestWin: 0 },
  keno: { played: 0, won: 0, biggestWin: 0 },
  limbo: { played: 0, won: 0, biggestWin: 0 },
  poker: { played: 0, won: 0, biggestWin: 0 },
  horses: { played: 0, won: 0, biggestWin: 0 },
  scratch: { played: 0, won: 0, biggestWin: 0 },
  wheel: { played: 0, won: 0, biggestWin: 0 },
  baccarat: { played: 0, won: 0, biggestWin: 0 },
  hilo: { played: 0, won: 0, biggestWin: 0 },
  duels: { played: 0, won: 0, biggestWin: 0 },
  rusroulette: { played: 0, won: 0, biggestWin: 0 },
  mpbsr: { played: 0, won: 0, biggestWin: 0 },
  russianr: { played: 0, won: 0, biggestWin: 0 }
};
let dailyBonusData = { lastClaimed: 0, streak: 0 };

// Bet validation: max you can bet is what you have
function checkMaxBet(bet, game) {
  if (bet > balance) { showToast('Max bet is your balance: $' + Math.floor(balance).toLocaleString(), false); return false; }
  return true;
}

window._loadStats = (s) => { if (s) { Object.keys(s).forEach(k => { if(typeof s[k]==='number') s[k]=safeNum(s[k]); }); playerStats = { ...playerStats, ...s }; } };
window._loadGameStats = (gs) => { if (!gs) return; Object.keys(gs).forEach(g => { gameStats[g] = { ...(gameStats[g]||{}), ...gs[g] }; }); };
window._loadDailyBonus = (db) => { if (db) dailyBonusData = { ...dailyBonusData, ...db }; checkDailyBonus(); };
window._getStats = () => playerStats;
window._getGameStats = () => gameStats;
window._getDailyBonus = () => dailyBonusData;

function recordGame(game, wagered, won) {
  wagered = safeNum(wagered); won = safeNum(won);
  const profit = won - wagered;
  playerStats.totalWagered = safeNum(playerStats.totalWagered + wagered);
  playerStats.totalWon = safeNum(playerStats.totalWon + won);
  playerStats.totalProfit = safeNum(playerStats.totalProfit + profit);
  playerStats.gamesPlayed++;
  if (won > playerStats.biggestWin) playerStats.biggestWin = won;
  if (gameStats[game]) {
    gameStats[game].played = (gameStats[game].played || 0) + 1;
    if (won > wagered) gameStats[game].won = (gameStats[game].won || 0) + 1;
    if (won > (gameStats[game].biggestWin || 0)) gameStats[game].biggestWin = won;
  }
  if (window._recordGameResult) window._recordGameResult(game, wagered, won);
  firebaseSave();
  // Check achievements after recording
  checkCasinoAchievements(game, wagered, won);
}

function addResultDot(containerId,label,isWin){
  const c=document.getElementById(containerId);if(!c)return;
  const dot=document.createElement('span');dot.className='result-dot';
  dot.style.background=isWin?'var(--green)':'var(--red)';dot.textContent=label;
  c.appendChild(dot);if(c.children.length>20)c.removeChild(c.firstChild);
}

// ============ DAILY BONUS ============
function checkDailyBonus() {
  const btn = document.getElementById('dailyBonusBtn');
  if (!btn) return;
  const lastDate = new Date(dailyBonusData.lastClaimed).toDateString();
  const todayDate = new Date().toDateString();
  if (lastDate === todayDate) {
    btn.disabled = true;
    btn.textContent = '✓ CLAIMED';
  } else {
    btn.disabled = false;
    btn.textContent = '🎁 DAILY';
  }
}

async function claimDailyBonus() {
  const btn = document.getElementById('dailyBonusBtn');
  btn.disabled = true;
  btn.textContent = '...';
  try {
    const result = await window._claimDailyBonus();
    if (result) {
      balance = safeNum(balance + result.amount); updateBalDisplay(); firebaseSave();
      dailyBonusData.lastClaimed = Date.now();
      dailyBonusData.streak = result.streak;
      showToast('🎁 Daily Bonus: $' + result.amount + ' (Day ' + result.streak + ' streak!)', true);
      btn.textContent = '✓ CLAIMED';
    } else {
      showToast('Already claimed today!', false);
      btn.textContent = '✓ CLAIMED';
    }
  } catch (e) {
    btn.disabled = false;
    btn.textContent = '🎁 DAILY';
    showToast('Error claiming bonus', false);
  }
}

// ============ GLOBAL LEADERBOARD ============
let currentLBCategory = 'richest';

function switchLB(category, btn) {
  currentLBCategory = category;
  document.querySelectorAll('.lb-tab').forEach(b => b.classList.remove('active'));
  if (btn) btn.classList.add('active');
  loadLeaderboard(category);
}

async function loadLeaderboard(category) {
  const container = document.getElementById('lbTable');
  container.innerHTML = '<div class="lb-empty">Loading...</div>';
  
  if (!window._getLeaderboard) {
    container.innerHTML = '<div class="lb-empty">Not connected</div>';
    return;
  }

  try {
    const entries = await window._getLeaderboard(category);
    if (entries.length === 0) {
      container.innerHTML = '<div class="lb-empty">No entries yet. Start playing to get on the board!</div>';
      return;
    }
const myId = window._currentPlayerId || '';
const fmtBig = (v) => {
      const abs = Math.abs(v);
      if (abs >= 1e18) return '$' + (v/1e18).toFixed(2) + 'Qi';
      if (abs >= 1e15) return '$' + (v/1e15).toFixed(2) + 'Q';
      if (abs >= 1e12) return '$' + (v/1e12).toFixed(2) + 'T';
      if (abs >= 1e9)  return '$' + (v/1e9).toFixed(2) + 'B';
      if (abs >= 1e6)  return '$' + (v/1e6).toFixed(2) + 'M';
      if (abs >= 1e4)  return '$' + (v/1e3).toFixed(1) + 'K';
      return '$' + v.toLocaleString(undefined, {minimumFractionDigits:2, maximumFractionDigits:2});
    };
    const fmtProfit = (v) => {
      const sign = v >= 0 ? '+' : '-';
      const abs = Math.abs(v);
      if (abs >= 1e18) return sign + '$' + (abs/1e18).toFixed(2) + 'Qi';
      if (abs >= 1e15) return sign + '$' + (abs/1e15).toFixed(2) + 'Q';
      if (abs >= 1e12) return sign + '$' + (abs/1e12).toFixed(2) + 'T';
      if (abs >= 1e9)  return sign + '$' + (abs/1e9).toFixed(2) + 'B';
      if (abs >= 1e6)  return sign + '$' + (abs/1e6).toFixed(2) + 'M';
      if (abs >= 1e4)  return sign + '$' + (abs/1e3).toFixed(1) + 'K';
      return (v >= 0 ? '+$' : '-$') + abs.toLocaleString(undefined, {minimumFractionDigits:2, maximumFractionDigits:2});
    };
    const labels = {
      richest: { col: 'Balance', fmt: fmtBig },
      slots: { col: 'Biggest Win', fmt: fmtBig },
      crash: { col: 'Biggest Win', fmt: fmtBig },
      roulette: { col: 'Biggest Win', fmt: fmtBig },
      blackjack: { col: 'Biggest Win', fmt: fmtBig },
      cases: { col: 'Biggest Win', fmt: fmtBig },
      plinko: { col: 'Biggest Win', fmt: fmtBig },
      mines: { col: 'Biggest Win', fmt: fmtBig },
      dice: { col: 'Biggest Win', fmt: fmtBig },
      tower: { col: 'Biggest Win', fmt: fmtBig },
      coinflip: { col: 'Biggest Win', fmt: fmtBig },
      keno: { col: 'Biggest Win', fmt: fmtBig },
      limbo: { col: 'Biggest Win', fmt: fmtBig },
      poker: { col: 'Biggest Win', fmt: fmtBig },
      horses: { col: 'Biggest Win', fmt: fmtBig },
      scratch: { col: 'Biggest Win', fmt: fmtBig },
      wheel: { col: 'Biggest Win', fmt: fmtBig },
      baccarat: { col: 'Biggest Win', fmt: fmtBig },
      hilo: { col: 'Biggest Win', fmt: fmtBig },
      pyl: { col: 'High Score', fmt: v => v.toLocaleString() + ' pts' },
      profit: { col: 'Total Profit', fmt: fmtProfit },
      duels: { col: 'Biggest Win', fmt: fmtBig },
      prestige: { col: 'Prestige Level', fmt: v => '👑 ' + v },
    };
    const cfg = labels[category] || labels.richest;

    container.innerHTML = entries.map((e, i) => {
      const medal = i === 0 ? '🥇' : i === 1 ? '🥈' : i === 2 ? '🥉' : (i + 1) + '.';
      const isMe = e.uid === myId;
      return '<div class="lb-data-row' + (isMe ? ' me' : '') + '">' +
        '<span class="lb-col-rank">' + medal + '</span>' +
        '<span class="lb-col-name">' + escapeHtml(e.name) + (isMe ? ' (you)' : '') + '</span>' +
        '<span class="lb-col-val">' + cfg.fmt(e.value) + '</span>' +
        '</div>';
    }).join('');
  } catch (e) {
    container.innerHTML = '<div class="lb-empty">Error loading leaderboard</div>';
  }
}


// ============ NAV DROPDOWN HELPERS ============
let navCatCloseTimer = null;
function openCat(el){
  if(navCatCloseTimer) { clearTimeout(navCatCloseTimer); navCatCloseTimer = null; }
  document.querySelectorAll('.nav-cat').forEach(c=>{if(c!==el)c.classList.remove('open');});
  el.classList.add('open');
}
function closeCat(el){
  navCatCloseTimer = setTimeout(()=>{
    el.classList.remove('open');
    navCatCloseTimer = null;
  }, 120);
}
// Touch support: toggle nav categories on tap
function toggleCat(el){el.classList.toggle('open');document.querySelectorAll('.nav-cat').forEach(c=>{if(c!==el)c.classList.remove('open');});}
// Close dropdowns if clicking/tapping outside
document.addEventListener('click',function(e){if(!e.target.closest('.nav-cat'))document.querySelectorAll('.nav-cat').forEach(c=>c.classList.remove('open'));});
document.addEventListener('touchstart',function(e){if(!e.target.closest('.nav-cat'))document.querySelectorAll('.nav-cat').forEach(c=>c.classList.remove('open'));},{passive:true});

// ============ GAMES MENU ============
const gamesData = [
  { cat: '⭐ Classic', games: [
    { name: 'Plinko', icon: '⚡', id: 'plinko' },
    { name: 'Crash', icon: '📈', id: 'crash' },
    { name: 'Slots', icon: '🎰', id: 'slots' },
    { name: 'Mines', icon: '💣', id: 'mines' },
    { name: 'Roulette', icon: '🎡', id: 'roulette' }
  ]},
  { cat: '🃏 Card Games', games: [
    { name: 'Blackjack', icon: '🃏', id: 'blackjack' },
    { name: 'Video Poker', icon: '♠️', id: 'poker' },
    { name: 'Baccarat', icon: '🎴', id: 'baccarat' },
    { name: 'Hi-Lo', icon: '↕️', id: 'hilo' }
  ]},
  { cat: '🎡 Table Games', games: [
    { name: 'Wheel', icon: '💫', id: 'wheel' },
    { name: 'Keno', icon: '🔢', id: 'keno' },
    { name: 'Horse Racing', icon: '🏇', id: 'horses' },
    { name: 'Buckshot Roulette', icon: '🔫', id: 'rusroulette' },
    { name: 'MP Buckshot', icon: '💥', id: 'mpbsr' },
    { name: 'Russian Roulette', icon: '🎰', id: 'russianr' }
  ]},
  { cat: '⚡ Quick & Special', games: [
    { name: 'Dice', icon: '🎯', id: 'dice' },
    { name: 'Tower', icon: '🗼', id: 'tower' },
    { name: 'Scratch Cards', icon: '🎫', id: 'scratch' },
    { name: 'Limbo', icon: '🚀', id: 'limbo' },
    { name: 'Coin Flip', icon: '🪙', id: 'coinflip' },
    { name: 'Push Your Luck', icon: '🎲', id: 'luck' },
    { name: 'Cases', icon: '📦', id: 'cases' }
  ]},
  { cat: '💎 Pro Games', games: [
    { name: 'Stocks', icon: '📊', id: 'stocks' },
    { name: 'Crypto', icon: '₿', id: 'crypto' },
    { name: 'Duels', icon: '⚔️', id: 'duels' }
  ]}
];

function openGamesMenu(){
  const overlay = document.getElementById('gamesMenuOverlay');
  overlay.style.display = 'block';
  const container = document.getElementById('gamesCategoriesContainer');
  container.innerHTML = gamesData.map((cat, i) => {
    const games = cat.games.map(g => {
      return `<button class="game-btn" onclick="switchGame('${g.id}',this);closeGamesMenu();" style="border-color:var(--green);"><span class="game-icon">${g.icon}</span><div>${g.name}</div></button>`;
    }).join('');
    return `<div class="games-category"><div class="games-category-title"><span>${cat.cat}</span></div><div class="games-grid">${games}</div></div>`;
  }).join('');
  setTimeout(() => overlay.style.opacity = '1', 10);
}

function closeGamesMenu(){
  const overlay = document.getElementById('gamesMenuOverlay');
  overlay.style.display = 'none';
}

// Close games menu on backdrop click
document.getElementById('gamesMenuOverlay')?.addEventListener('click', (e) => {
  if(e.target.id === 'gamesMenuOverlay') closeGamesMenu();
});

// How-to-play toggle
function htpToggle(el){el.closest('.htp-box').classList.toggle('open');}
function showToast(msg,isWin=true){
  const t=document.getElementById('winToast');
  t.textContent=msg;t.className='win-toast'+(isWin?'':' loss');
  setTimeout(()=>t.classList.add('show'),10);
  setTimeout(()=>t.classList.remove('show'),2500);
}

// Big Win Celebration — triggered for wins >= threshold
function showBigWin(amount) {
  if (amount < 500) return;
  
  // Screen shake for big wins
  const intensity = Math.min(amount / 1000, 8);
  document.body.style.animation = `screenShake ${0.3 + Math.min(amount/5000, 0.4)}s ease-out`;
  setTimeout(() => { document.body.style.animation = ''; }, 800);
  
  // Mega win overlay for huge wins
  if (amount >= 2000) {
    const overlay = document.createElement('div');
    overlay.style.cssText = `position:fixed;top:0;left:0;right:0;bottom:0;z-index:999999;display:flex;flex-direction:column;align-items:center;justify-content:center;
      background:radial-gradient(circle,rgba(255,215,0,0.15),rgba(0,0,0,0.85));pointer-events:none;animation:fadeInOut 2.5s ease forwards;`;
    
    const tier = amount >= 50000 ? {label:'MEGA WIN',color:'#ff00e5',glow:'rgba(255,0,229,0.6)',icon:'👑'} 
      : amount >= 10000 ? {label:'HUGE WIN',color:'#ffd700',glow:'rgba(255,215,0,0.6)',icon:'💎'} 
      : amount >= 5000 ? {label:'BIG WIN',color:'#00f0ff',glow:'rgba(0,240,255,0.6)',icon:'🔥'}
      : {label:'NICE WIN',color:'#00ff88',glow:'rgba(0,255,136,0.5)',icon:'✨'};
    
    overlay.innerHTML = `
      <div style="font-size:60px;animation:bigWinBounce 0.6s ease-out;">${tier.icon}</div>
      <div style="font-family:'Orbitron';font-weight:900;font-size:${amount>=10000?'48':'36'}px;color:${tier.color};
        text-shadow:0 0 30px ${tier.glow},0 0 60px ${tier.glow};animation:bigWinBounce 0.6s ease-out 0.1s both;">${tier.label}</div>
      <div style="font-family:'Orbitron';font-weight:700;font-size:28px;color:#fff;margin-top:8px;
        animation:bigWinBounce 0.6s ease-out 0.2s both;">+$${amount.toFixed(2)}</div>
    `;
    document.body.appendChild(overlay);
    
    // Extra particles burst
    for (let i = 0; i < 5; i++) {
      setTimeout(() => spawnParticles(
        Math.random() * window.innerWidth, 
        Math.random() * window.innerHeight, 
        20 + Math.min(amount / 500, 40)
      ), i * 150);
    }
    
    setTimeout(() => { if (overlay.parentNode) overlay.parentNode.removeChild(overlay); }, 2600);
  }
}

function switchGame(game,btn){
  document.querySelectorAll('.game-panel').forEach(p=>p.classList.remove('active'));
  const targetPanel = document.getElementById(game+'Panel');
  if(targetPanel) targetPanel.classList.add('active'); else return;
  // hide catalog when a game is selected
  const catalog = document.getElementById('gameCatalog'); if(catalog) catalog.style.display = 'none';
  document.querySelectorAll('.nav-btn').forEach(b=>b.classList.remove('active'));
  if(btn)btn.classList.add('active');
  if(game==='plinko'&&!plinkoInitialized)initPlinko();
  if(game==='roulette'&&!rouletteDrawn)drawRouletteWheel(0);
  if(game==='crash')resizeCrashCanvas();
  if(game==='profile')renderProfile();
  if(game==='stocks')renderStocks();
  if(game==='leaderboard')loadLeaderboard(currentLBCategory);
  if(game==='duels')duelLoadLobby();
  if(game==='wheel'&&!wheelDrawn)drawWheel(0);
  if(game==='keno')kenoInit();
  if(game==='horses')horseInit();
  if(game==='mines')minesRenderGrid();
  if(game==='dice')diceUpdateSlider();
  if(game==='rusroulette')initBuckshotRoulette();
  if(game==='mpbsr')initMPBSR();
  if(game==='russianr')initRussianRoulette();
  if(game==='crypto')initCrypto();
  if(game==='luck'){
    let iframe=document.getElementById('pylIframe');
    if(!iframe){
      // Create iframe dynamically so it doesn't interfere before needed
      iframe=document.createElement('iframe');
      iframe.id='pylIframe';
      iframe.allow='autoplay';
      document.getElementById('luckPanel').insertBefore(iframe,document.getElementById('luckPanel').firstChild);
    }
    if(!iframe.src||!iframe.src.includes('push-your-luck')){
      // Delay loading so iframe has real layout dimensions before Phaser inits
      setTimeout(()=>{ iframe.src='push-your-luck/index.html'; }, 300);
    }
    pylLoadLeaderboard();
  }
  // firebaseSave handled by debounce timer — no need to save on every switch
}

function adjustBet(id,mult){
  const el=document.getElementById(id);
  let v=Math.max(1,Math.round(parseFloat(el.value||10)*mult));
  if(v>balance)v=Math.floor(balance);
  el.value=v;
}
function betAll(id){
  const el=document.getElementById(id);
  el.value=Math.max(1,Math.floor(balance));
  playClickSound();
}

// ============ PARTICLES ============
const pCanvas=document.getElementById('particles');
const pCtx=pCanvas.getContext('2d');
let particles=[];
function resizeParticles(){pCanvas.width=window.innerWidth;pCanvas.height=window.innerHeight;}
resizeParticles();window.addEventListener('resize',resizeParticles);

function spawnParticles(x,y,count=30,colors=['#ffd700','#ff8800','#00f0ff','#ff00e5','#00ff88']){
  // Cap total particles to prevent freezing from spam
  const MAX_PARTICLES = 200;
  if(particles.length >= MAX_PARTICLES) return;
  count = Math.min(count, MAX_PARTICLES - particles.length);
  for(let i=0;i<count;i++){
    const angle=Math.random()*Math.PI*2;
    const speed=Math.random()*10+3;
    particles.push({x,y,vx:Math.cos(angle)*speed,vy:Math.sin(angle)*speed-3,
      life:1,decay:Math.random()*.015+.008,size:Math.random()*5+2,
      color:colors[Math.floor(Math.random()*colors.length)]});
  }
  // Restart animation loop if it was idle
  if(particles.length===count) requestAnimationFrame(updateParticles);
}
function updateParticles(){
  pCtx.clearRect(0,0,pCanvas.width,pCanvas.height);
  particles=particles.filter(p=>{
    p.x+=p.vx;p.y+=p.vy;p.vy+=.12;p.life-=p.decay;p.vx*=.99;
    if(p.life<=0)return false;
    pCtx.globalAlpha=p.life;pCtx.fillStyle=p.color;
    pCtx.shadowColor=p.color;pCtx.shadowBlur=p.size*2;
    pCtx.beginPath();pCtx.arc(p.x,p.y,p.size*p.life,0,Math.PI*2);pCtx.fill();
    return true;
  });
  pCtx.globalAlpha=1;pCtx.shadowBlur=0;
  if(particles.length>0)requestAnimationFrame(updateParticles);
}
updateParticles();

// ============ SOUND ============
let soundMuted = false;
function toggleMute() {
  soundMuted = !soundMuted;
  const btn = document.getElementById('muteBtn');
  if (btn) btn.textContent = soundMuted ? '🔇' : '🔊';
}
let audioCtx=null;
function ensureAudioCtx(){if(!audioCtx){audioCtx=new(window.AudioContext||window.webkitAudioContext)();}if(audioCtx.state==='suspended')audioCtx.resume();return audioCtx;}
document.addEventListener('click',ensureAudioCtx,{once:true});
document.addEventListener('keydown',ensureAudioCtx,{once:true});
function playSound(freq,type='sine',dur=0.15,vol=0.1){
  try{
    if(!audioCtx)return;
    const o=audioCtx.createOscillator();const g=audioCtx.createGain();
    o.connect(g);g.connect(audioCtx.destination);o.type=type;o.frequency.value=freq;
    g.gain.setValueAtTime(vol,audioCtx.currentTime);g.gain.exponentialRampToValueAtTime(.001,audioCtx.currentTime+dur);
    o.start();o.stop(audioCtx.currentTime+dur);
  }catch(e){}
}
function playWinSound(){playSound(523,'sine',.1,.12);setTimeout(()=>playSound(659,'sine',.1,.12),80);
  setTimeout(()=>playSound(784,'sine',.15,.12),160);setTimeout(()=>playSound(1047,'sine',.25,.1),240);}
function playLoseSound(){playSound(200,'sawtooth',.25,.06);setTimeout(()=>playSound(150,'sawtooth',.3,.05),100);}
function playClickSound(){playSound(800,'sine',.04,.06);}
let _achievementsCache = {};
// Load from localStorage as fallback, Firebase is primary
try { _achievementsCache = JSON.parse(localStorage.getItem('casino_achievements') || '{}'); } catch(e) { _achievementsCache = {}; }

function getCasinoAch() {
  return _achievementsCache;
}
function saveCasinoAch(id) {
  if (_achievementsCache[id]) return false;
  _achievementsCache[id] = Date.now();
  // Fallback to localStorage
  try { localStorage.setItem('casino_achievements', JSON.stringify(_achievementsCache)); } catch(e) {}
  // Firebase sync happens via firebaseSave()
  return true;
}
// Firebase persistence accessors for achievements
window._getAchievements = () => _achievementsCache;
window._loadAchievements = (data) => {
  if (data && typeof data === 'object') {
    // Merge — keep whichever has more unlocked achievements
    Object.keys(data).forEach(k => {
      if (!_achievementsCache[k]) _achievementsCache[k] = data[k];
    });
    try { localStorage.setItem('casino_achievements', JSON.stringify(_achievementsCache)); } catch(e) {}
  }
};

const _origPlaySound = playSound;
playSound = function(freq, type, dur, vol) {
  if (soundMuted) return;
  _origPlaySound(freq, type, dur, vol);
};

// ============ CASINO ACHIEVEMENTS ============
const CASINO_ACHIEVEMENTS = [
  { id:'first_game', icon:'🎮', name:'FIRST SPIN', desc:'Play your first game' },
  { id:'first_win', icon:'🏆', name:'WINNER', desc:'Win your first bet' },
  { id:'high_roller', icon:'💰', name:'HIGH ROLLER', desc:'Wager $10,000 total' },
  { id:'whale', icon:'🐋', name:'WHALE', desc:'Wager $100,000 total' },
  { id:'big_win', icon:'💎', name:'BIG WIN', desc:'Win $5,000+ in a single bet' },
  { id:'mega_win', icon:'👑', name:'MEGA WIN', desc:'Win $50,000+ in a single bet' },
  { id:'broke', icon:'📉', name:'ROCK BOTTOM', desc:'Lose all your money (balance $0)' },
  { id:'comeback', icon:'🔥', name:'COMEBACK KID', desc:'Go from under $100 to over $10,000' },
  { id:'games_50', icon:'⭐', name:'REGULAR', desc:'Play 50 games' },
  { id:'games_500', icon:'🌟', name:'VETERAN', desc:'Play 500 games' },
  { id:'games_5000', icon:'✨', name:'LEGEND', desc:'Play 5,000 games' },
  { id:'slots_pro', icon:'🎰', name:'SLOTS PRO', desc:'Win 50 times at Slots' },
  { id:'crash_pro', icon:'📈', name:'CRASH MASTER', desc:'Win 50 times at Crash' },
  { id:'diversified', icon:'🎯', name:'DIVERSIFIED', desc:'Play 5+ different games' },
  { id:'collector', icon:'🎒', name:'COLLECTOR', desc:'Own 10+ inventory items' },
  { id:'daily_7', icon:'📅', name:'DEDICATED', desc:'Claim 7 daily bonuses (streak)' },
  { id:'profit_10k', icon:'📊', name:'PROFITABLE', desc:'Reach $10,000 total profit' },
  { id:'inv_value', icon:'💼', name:'PORTFOLIO', desc:'Inventory worth $10,000+' }
];

function checkCasinoAchievements(game, wagered, won) {
  const newAchs = [];
  function tryAward(id) {
    if (saveCasinoAch(id)) {
      const a = CASINO_ACHIEVEMENTS.find(x => x.id === id);
      if (a) { newAchs.push(a); showAchToast(a); }
    }
  }
  // First game
  tryAward('first_game');
  // First win
  if (won > 0) tryAward('first_win');
  // Big wins
  if (won >= 5000) tryAward('big_win');
  if (won >= 50000) tryAward('mega_win');
  // Wagering milestones
  if (playerStats.totalWagered >= 10000) tryAward('high_roller');
  if (playerStats.totalWagered >= 100000) tryAward('whale');
  // Games played
  if (playerStats.gamesPlayed >= 50) tryAward('games_50');
  if (playerStats.gamesPlayed >= 500) tryAward('games_500');
  if (playerStats.gamesPlayed >= 5000) tryAward('games_5000');
  // Game-specific
  if (gameStats.slots && gameStats.slots.won >= 50) tryAward('slots_pro');
  if (gameStats.crash && gameStats.crash.won >= 50) tryAward('crash_pro');
  // Diversified
  const gamesPlayed = Object.values(gameStats).filter(g => g.played > 0).length;
  if (gamesPlayed >= 5) tryAward('diversified');
  // Broke
  if (balance <= 0) tryAward('broke');
  // Profit
  if (playerStats.totalProfit >= 10000) tryAward('profit_10k');
  // Collector
  if (inventory.length >= 10) tryAward('collector');
  // Inventory value
  if (typeof getInventoryValue === 'function' && getInventoryValue() >= 10000) tryAward('inv_value');
  // Daily streak
  if (dailyBonusData.streak >= 7) tryAward('daily_7');
  // Comeback
  if (balance >= 10000 && (getCasinoAch()['broke'])) tryAward('comeback');
  return newAchs;
}
function showAchToast(ach) {
  showToast(ach.icon + ' Achievement: ' + ach.name + ' — ' + ach.desc, true);
}

// Firebase persistence accessors for trade history
window._getTradeHistory = () => tradeHistory.slice(0, 50);
window._loadTradeHistory = (data) => {
  if (Array.isArray(data)) {
    const existing = new Set(tradeHistory.map(t => t.ts));
    data.forEach(t => { if (t.ts && !existing.has(t.ts)) tradeHistory.push(t); });
    tradeHistory.sort((a, b) => b.ts - a.ts);
    if (tradeHistory.length > 50) tradeHistory = tradeHistory.slice(0, 50);
    try { localStorage.setItem('casino_trade_history', JSON.stringify(tradeHistory)); } catch(e) {}
  }
};

// ============ PROFILE RENDER ============
// ============ CUSTOM PROFILE PICTURES ============
const PFP_OPTIONS = [
  '👤','😎','🤑','🎰','🃏','👑','🔥','💎','⚡','🌟',
  '🐉','🦊','🐺','🦅','🐲','🦁','🐯','🦈','🐙','🦇',
  '💀','👻','🤖','👽','🎭','🥷','🧙','🧛','🧟','🏴‍☠️',
  '🎲','🎯','🎪','🏆','🎸','🎮','⚔️','🛡️','🗡️','💣',
  '🌊','🌋','❄️','☄️','🌙','☀️','🌈','🍀','💰','🏝️'
];
let selectedPfp = localStorage.getItem('casino_pfp') || '';
let customPfpUrl = localStorage.getItem('casino_pfp_url') || '';
const UPLOAD_WORKER_URL = 'https://chatra.modmojheh.workers.dev';

function openPfpPicker() {
  const overlay = document.getElementById('pfpPickerOverlay');
  overlay.style.display = 'flex';
  const grid = document.getElementById('pfpGrid');
  grid.innerHTML = '';
  
  // Upload custom button
  const uploadDiv = document.createElement('div');
  uploadDiv.style.cssText = 'width:48px;height:48px;display:flex;align-items:center;justify-content:center;font-size:20px;border-radius:10px;cursor:pointer;border:2px dashed var(--neon);background:rgba(0,240,255,.05);transition:all .15s;';
  uploadDiv.innerHTML = '📷';
  uploadDiv.title = 'Upload custom image';
  uploadDiv.onmouseover = function(){ this.style.transform='scale(1.15)'; };
  uploadDiv.onmouseout = function(){ this.style.transform='scale(1)'; };
  uploadDiv.onclick = function(){ document.getElementById('pfpFileInput').click(); };
  grid.appendChild(uploadDiv);
  
  // Show current custom pic if exists
  if (customPfpUrl) {
    const customDiv = document.createElement('div');
    customDiv.style.cssText = 'width:48px;height:48px;display:flex;align-items:center;justify-content:center;border-radius:10px;cursor:pointer;border:2px solid ' + (!selectedPfp && customPfpUrl ? 'var(--gold)' : 'var(--border)') + ';background:var(--bg);transition:all .15s;overflow:hidden;';
    customDiv.innerHTML = '<img src="' + customPfpUrl + '" style="width:100%;height:100%;object-fit:cover;border-radius:8px;">';
    customDiv.title = 'Your custom avatar';
    customDiv.onmouseover = function(){ this.style.transform='scale(1.15)'; };
    customDiv.onmouseout = function(){ this.style.transform='scale(1)'; };
    customDiv.onclick = function(){ selectCustomPfp(customPfpUrl); };
    grid.appendChild(customDiv);
  }
  
  PFP_OPTIONS.forEach((emoji) => {
    const isSelected = emoji === selectedPfp;
    const div = document.createElement('div');
    div.style.cssText = 'width:48px;height:48px;display:flex;align-items:center;justify-content:center;font-size:28px;border-radius:10px;cursor:pointer;border:2px solid ' + (isSelected ? 'var(--gold)' : 'var(--border)') + ';background:' + (isSelected ? 'rgba(255,215,0,.15)' : 'var(--bg)') + ';transition:all .15s;';
    div.textContent = emoji;
    div.onmouseover = function(){ this.style.transform='scale(1.15)'; };
    div.onmouseout = function(){ this.style.transform='scale(1)'; };
    div.onclick = function(){ selectPfp(emoji); };
    grid.appendChild(div);
  });
}
function closePfpPicker() { document.getElementById('pfpPickerOverlay').style.display = 'none'; }
function selectPfp(emoji) {
  selectedPfp = emoji;
  customPfpUrl = ''; // clear custom pic when picking emoji
  localStorage.setItem('casino_pfp', emoji);
  localStorage.removeItem('casino_pfp_url');
  if(window._firebaseSave) firebaseSave();
  applyPfp();
  closePfpPicker();
  showToast('Avatar updated! ' + emoji, true);
}

function selectCustomPfp(url) {
  selectedPfp = '';
  customPfpUrl = url;
  localStorage.setItem('casino_pfp_url', url);
  localStorage.setItem('casino_pfp', '');
  if(window._firebaseSave) firebaseSave();
  applyPfp();
  closePfpPicker();
  showToast('Custom avatar set!', true);
}

async function handlePfpUpload(input) {
  const file = input.files[0];
  if (!file) return;
  
  if (!file.type.startsWith('image/') && file.type !== 'image/gif') {
    showToast('❌ Please select an image or GIF file', false);
    return;
  }
  
  if (file.size > 5 * 1024 * 1024) {
    showToast('❌ Image too large (max 5MB)', false);
    return;
  }
  
  showToast('⏳ Uploading avatar...', true);
  closePfpPicker();
  
  try {
    const formData = new FormData();
    formData.append('file', file);
    
    const res = await fetch(UPLOAD_WORKER_URL + '/upload', {
      method: 'POST',
      body: formData
    });
    
    const data = await res.json();
    
    if (!res.ok || !data.url) {
      throw new Error(data.error || 'Upload failed');
    }
    
    customPfpUrl = data.url;
    selectedPfp = '';
    localStorage.setItem('casino_pfp_url', customPfpUrl);
    localStorage.setItem('casino_pfp', '');
    
    // Save to Firebase player data
    if (window._currentPlayerId) {
      await window._fbUpdate('casino/players/' + window._currentPlayerId, { profilePicUrl: customPfpUrl });
    }
    if(window._firebaseSave) firebaseSave();
    applyPfp();
    showToast('✅ Custom avatar uploaded!', true);
  } catch(err) {
    console.error('PFP upload error:', err);
    showToast('❌ Upload failed: ' + err.message, false);
  }
  
  input.value = ''; // reset file input
}
function applyPfp() {
  const name = window._currentUsername || 'Guest';
  const init = name.charAt(0).toUpperCase();
  if (customPfpUrl) {
    document.getElementById('userAvatar').innerHTML = '<img src="' + customPfpUrl + '" style="width:100%;height:100%;object-fit:cover;border-radius:50%;">';
    document.getElementById('profileAvatar').innerHTML = '<img src="' + customPfpUrl + '" style="width:100%;height:100%;object-fit:cover;border-radius:50%;">';
  } else if (selectedPfp) {
    document.getElementById('userAvatar').innerHTML = '<div style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;font-size:24px;">' + selectedPfp + '</div>';
    document.getElementById('profileAvatar').innerHTML = '<div style="width:100%;height:100%;display:flex;align-items:center;justify-content:center;font-size:48px;">' + selectedPfp + '</div>';
  } else {
    document.getElementById('userAvatar').innerHTML = `<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><defs><linearGradient id="avG" x1="0" x2="1"><stop offset="0" stop-color="#00f0ff"/><stop offset="1" stop-color="#6b2fd9"/></linearGradient></defs><circle cx="50" cy="50" r="48" fill="url(#avG)"/><text x="50" y="58" font-family="Orbitron,Inter,sans-serif" font-weight="900" font-size="48" fill="#fff" text-anchor="middle">${init}</text></svg>`;
    document.getElementById('profileAvatar').innerHTML = `<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"><defs><linearGradient id="profG" x1="0" x2="1"><stop offset="0" stop-color="#ffb86b"/><stop offset="1" stop-color="#ff6b6b"/></linearGradient></defs><circle cx="50" cy="50" r="48" fill="url(#profG)"/><text x="50" y="60" font-family="Orbitron,Inter,sans-serif" font-weight="900" font-size="42" fill="#071028" text-anchor="middle">${init}</text></svg>`;
  }
}

function renderProfile() {
  const name = document.getElementById('userNameDisplay').textContent || 'PLAYER';
  document.getElementById('profileName').textContent = name;
  applyPfp();
  document.getElementById('profBalance').textContent = '$' + formatBalance(balance);
  document.getElementById('profGames').textContent = playerStats.gamesPlayed.toLocaleString();
  const profit = playerStats.totalProfit;
  const profEl = document.getElementById('profProfit');
  profEl.textContent = (profit >= 0 ? '+$' : '-$') + formatBalance(Math.abs(profit));
  profEl.style.color = profit >= 0 ? 'var(--green)' : 'var(--red)';
  document.getElementById('profWagered').textContent = '$' + formatBalance(playerStats.totalWagered);
  document.getElementById('profBiggest').textContent = '$' + formatBalance(playerStats.biggestWin);
  if (typeof getInventoryValue === 'function') {
    document.getElementById('profInvValue').textContent = '$' + getInventoryValue().toFixed(2);
  }
  // Achievements
  const achs = getCasinoAch();
  const count = Object.keys(achs).length;
  document.getElementById('casinoAchCount').textContent = '(' + count + '/' + CASINO_ACHIEVEMENTS.length + ')';
  document.getElementById('casinoAchGrid').innerHTML = CASINO_ACHIEVEMENTS.map(a => {
    const done = !!achs[a.id];
    return `<div style="display:flex;align-items:center;gap:8px;padding:8px;background:var(--surface);border:1px solid ${done?'var(--gold)':'var(--border)'};border-radius:6px;opacity:${done?1:0.35}">
      <span style="font-size:18px">${a.icon}</span>
      <div style="flex:1;min-width:0"><div style="font-size:11px;font-weight:bold;color:${done?'var(--gold)':'var(--text)'};letter-spacing:1px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis">${a.name}</div>
      <div style="font-size:9px;color:var(--text2)">${a.desc}</div></div>
      ${done ? '<span style="color:var(--green)">✓</span>' : ''}
    </div>`;
  }).join('');
  // Game stats
  document.getElementById('profGameStats').innerHTML = Object.entries(gameStats).map(([name, s]) => {
    if (!s.played) return '';
    const wr = s.played > 0 ? Math.round((s.won / s.played) * 100) : 0;
    return `<div style="background:var(--surface);border:1px solid var(--border);border-radius:6px;padding:8px;">
      <div style="font-size:10px;color:var(--text2);letter-spacing:1px;text-transform:uppercase">${name}</div>
      <div style="font-size:13px;color:var(--text);margin-top:2px">${s.played} played · ${wr}% WR</div>
      <div style="font-size:10px;color:var(--green)">Best: $${(s.biggestWin||0).toFixed(0)}</div>
    </div>`;
  }).filter(Boolean).join('');
  // Prestige
  renderPrestige();
  // Admin panel (mojheh + co-owners)
  const adminPanel = document.getElementById('adminPanel');
  const lowerName = name.toLowerCase();
  if (lowerName === 'mojheh' || lowerName === 'terpez') {
    adminPanel.style.display = 'block';
  } else {
    adminPanel.style.display = 'none';
  }
}

// ============ PRESTIGE SYSTEM ============
let prestigeLevel = 0;
const PRESTIGE_REQS = [10000, 50000, 250000, 1000000, 10000000]; // Balance needed to prestige at each level
const PRESTIGE_NAMES = ['Bronze','Silver','Gold','Diamond','Legendary'];
const PRESTIGE_COLORS = ['prestige-1','prestige-2','prestige-3','prestige-4','prestige-5'];

window._loadPrestige = (val) => { prestigeLevel = val || 0; };
window._getPrestige = () => prestigeLevel;

window._loadProfilePicUrl = (url) => { customPfpUrl = url || ''; localStorage.setItem('casino_pfp_url', customPfpUrl); if (customPfpUrl) { selectedPfp = ''; localStorage.setItem('casino_pfp', ''); } applyPfp(); };
window._getProfilePicUrl = () => customPfpUrl || null;

function getPrestigeReq() {
  if (prestigeLevel >= PRESTIGE_REQS.length) return PRESTIGE_REQS[PRESTIGE_REQS.length - 1] * Math.pow(5, prestigeLevel - PRESTIGE_REQS.length + 1);
  return PRESTIGE_REQS[prestigeLevel];
}

// ============ ADMIN FUNCTIONS ============
async function adminGiveMoney() {
  const _aName = (window._currentUsername||'').toLowerCase();
  if (_aName !== 'mojheh' && _aName !== 'terpez') {
    showToast('Admin only!', false);
    return;
  }
  const username = document.getElementById('adminUsername').value.trim();
  const amount = parseFloat(document.getElementById('adminAmount').value);
  if (!username || !amount || amount <= 0) {
    showToast('Invalid input!', false);
    return;
  }
  try {
    showToast('⏳ Processing...', true);
    // Find user by username
    const usersSnap = await window._fbGet('casino/usernames/' + username.toLowerCase());
    if (!usersSnap.exists()) {
      showToast('❌ User "' + username + '" not found!', false);
      return;
    }
    const userId = usersSnap.val();
    console.log('Found user:', userId);
    
    // Get current balance
    const playerSnap = await window._fbGet('casino/players/' + userId);
    const currentData = playerSnap.exists() ? playerSnap.val() : {};
    const currentBal = parseFloat(currentData.balance || 0);
    const newBal = currentBal + amount;
    
    console.log('Current balance:', currentBal, 'Adding:', amount, 'New balance:', newBal);
    
    // Update balance using UPDATE to avoid overwriting concurrent changes
    await window._fbUpdate('casino/players/' + userId, {
      balance: newBal,
      lastAdminGift: {
        from: window._currentUsername,
        amount: amount,
        time: Date.now()
      }
    });
    
    console.log('Balance updated successfully for', username);
    showToast('✅ Gave $' + formatBalance(amount) + ' to ' + username + ' (' + newBal.toFixed(2) + ')', true);
    document.getElementById('adminUsername').value = '';
    document.getElementById('adminAmount').value = '';
  } catch(e) {
    console.error('Admin give money error:', e);
    showToast('❌ Error: ' + (e.message || 'Unknown error'), false);
  }
}

async function adminSetSelfBalance() {
  const _aName2 = (window._currentUsername||'').toLowerCase();
  if (_aName2 !== 'mojheh' && _aName2 !== 'terpez') {
    showToast('Admin only!', false);
    return;
  }
  const amount = parseFloat(document.getElementById('adminSelfBalance').value);
  if (isNaN(amount) || amount < 0) {
    showToast('Invalid amount!', false);
    return;
  }
  try {
    showToast('⏳ Setting balance...', true);
    balance = amount;
    updateBalDisplay();
    
    // Update with new balance
    await window._fbUpdate('casino/players/' + window._currentPlayerId, {
      balance: amount,
      lastBalanceSet: Date.now()
    });
    
    console.log('Self balance set to:', amount);
    showToast('✅ Balance set to $' + formatBalance(amount), true);
    document.getElementById('adminSelfBalance').value = '';
    renderProfile();
  } catch(e) {
    console.error('Admin set balance error:', e);
    showToast('❌ Error: ' + (e.message || 'Unknown'), false);
  }
}

function getPrestigeBadgeHTML(level) {
  if (!level || level <= 0) return '';
  const tier = Math.min(level, 5);
  const name = tier <= PRESTIGE_NAMES.length ? PRESTIGE_NAMES[tier - 1] : PRESTIGE_NAMES[PRESTIGE_NAMES.length - 1];
  const cls = tier <= PRESTIGE_COLORS.length ? PRESTIGE_COLORS[tier - 1] : PRESTIGE_COLORS[PRESTIGE_COLORS.length - 1];
  return `<span class="prestige-badge ${cls}">P${level} ${name}</span>`;
}

function renderPrestige() {
  const el = document.getElementById('profPrestigeLevel');
  if (el) el.textContent = prestigeLevel;
  const badge = document.getElementById('profilePrestigeBadge');
  if (badge) badge.innerHTML = prestigeLevel > 0 ? getPrestigeBadgeHTML(prestigeLevel) : '<span style="font-size:11px;color:var(--text2);">Not yet prestiged</span>';
  const req = getPrestigeReq();
  const reqEl = document.getElementById('prestigeReqText');
  if (reqEl) reqEl.textContent = 'Requires $' + formatBalance(req) + ' balance to prestige.';
  const btn = document.getElementById('prestigeBtn');
  if (btn) btn.disabled = balance < req;
}

function prestigeConfirm() {
  const req = getPrestigeReq();
  const currentBal = Number(balance) || 0;
  console.log('Prestige check - Current balance:', currentBal, 'Requirement:', req, 'Prestige level:', prestigeLevel);
  if (currentBal < req) { 
    showToast('Need $' + formatBalance(req) + ' to prestige! You have $' + formatBalance(currentBal), false); 
    return; 
  }
  // Show confirmation overlay
  const overlay = document.createElement('div');
  overlay.className = 'prestige-confirm-overlay';
  overlay.innerHTML = `<div class="prestige-confirm-box">
    <div style="font-size:36px;margin-bottom:8px;">👑</div>
    <div style="font-family:'Orbitron';font-size:18px;color:var(--gold);margin-bottom:8px;">PRESTIGE UP?</div>
    <div style="font-size:12px;color:var(--text2);margin-bottom:12px;">
      Your balance will reset to <b style="color:var(--gold);">$1,000</b><br>
      You'll go from <b>Prestige ${prestigeLevel}</b> → <b style="color:var(--gold);">Prestige ${prestigeLevel + 1}</b><br>
      <span style="color:var(--text2);font-size:10px;">Your inventory, stats and achievements are kept.</span>
    </div>
    <div style="display:flex;gap:8px;justify-content:center;">
      <button onclick="this.closest('.prestige-confirm-overlay').remove()" style="padding:10px 20px;background:var(--surface2);border:1px solid var(--border);border-radius:8px;color:var(--text);cursor:pointer;font-family:'Orbitron';font-size:11px;">CANCEL</button>
      <button onclick="prestigeExecute();this.closest('.prestige-confirm-overlay').remove()" style="padding:10px 20px;background:linear-gradient(135deg,var(--gold),#ff8800);border:none;border-radius:8px;color:#1a1a2e;cursor:pointer;font-family:'Orbitron';font-size:11px;font-weight:900;">👑 PRESTIGE</button>
    </div>
  </div>`;
  document.body.appendChild(overlay);
}

function prestigeExecute() {
  const req = getPrestigeReq();
  const currentBal = Number(balance) || 0;
  if (currentBal < req) {
    showToast('Not enough balance! Need $' + formatBalance(req) + ', have $' + formatBalance(currentBal), false);
    return;
  }
  try {
    prestigeLevel++;
    balance = 1000;
    updateBalDisplay();
    console.log('Prestige executed! New level:', prestigeLevel, 'New balance:', balance);
    showToast('👑 PRESTIGE ' + prestigeLevel + '! Welcome to ' + (PRESTIGE_NAMES[Math.min(prestigeLevel, PRESTIGE_NAMES.length) - 1] || 'Legendary') + '!');
    playWinSound();
    spawnParticles(window.innerWidth / 2, window.innerHeight / 2, 50);
    // Update leaderboard
    if (window._currentPlayerId && window._currentUsername) {
      window._fbSet('casino/leaderboards/prestige/' + window._currentPlayerId, {
        name: window._currentUsername,
        value: prestigeLevel,
        updated: Date.now()
      }).catch((err) => { console.error('Prestige leaderboard update failed:', err); });
    }
    firebaseSave();
    renderProfile();
    renderPrestige();
  } catch(e) {
    console.error('Prestige execute error:', e);
    showToast('❌ Error: ' + (e.message || 'Unknown'), false);
  }
}

// ============ COINFLIP DUELS ============
let duelRoomUnsub = null;
let duelLobbyUnsub = null;
let currentDuelRoom = null;
let duelHistory = [];
try { duelHistory = JSON.parse(localStorage.getItem('casino_duel_history') || '[]'); } catch(e) { duelHistory = []; }

function duelGenCode() { return 'D' + Math.random().toString(36).substr(2, 6).toUpperCase(); }

async function duelCreate() {
  if (!window._currentPlayerId) { showToast('Login required!', false); return; }
  const wager = parseFloat(document.getElementById('duelWagerInput').value) || 100;
  if (wager < 10) { showToast('Minimum wager is $10', false); return; }
  if (wager > balance) { showToast('Not enough balance!', false); return; }
  const code = duelGenCode();
  balance -= wager;
  updateBalDisplay();
  try {
    await window._fbSet('casino/duelRooms/' + code, {
      host: window._currentPlayerId,
      hostName: window._currentUsername,
      hostPrestige: prestigeLevel,
      wager: wager,
      status: 'waiting',
      created: Date.now()
    });
    // Auto-cleanup if host disconnects
    window._fbOnDisconnect('casino/duelRooms/' + code).remove();
    showToast('Duel created! Waiting for opponent...', true);
    playClickSound();
    duelWatchGame(code, wager);
  } catch(e) {
    balance += wager;
    updateBalDisplay();
    showToast('Failed to create duel: ' + (e.message || 'Unknown error'), false);
  }
}

async function duelJoin(code) {
  if (!window._currentPlayerId) { showToast('Login required!', false); return; }
  try {
    const snap = await window._fbGet('casino/duelRooms/' + code);
    if (!snap.exists()) { showToast('Duel not found!', false); return; }
    const room = snap.val();
    if (room.status !== 'waiting') { showToast('Duel already started!', false); return; }
    if (room.host === window._currentPlayerId) { showToast("Can't join your own duel!", false); return; }
    if (room.wager > balance) { showToast('Not enough balance!', false); return; }
    balance -= room.wager;
    updateBalDisplay();
    await window._fbUpdate('casino/duelRooms/' + code, {
      challenger: window._currentPlayerId,
      challengerName: window._currentUsername,
      challengerPrestige: prestigeLevel,
      status: 'playing'
    });
    playClickSound();
    // Both players watch for result
    duelWatchGame(code, room.wager);
  } catch(e) {
    balance += room.wager; updateBalDisplay();
    showToast('Failed to join duel: ' + (e.message || 'Unknown error'), false);
  }
}

let _duelAnimating = false;
let _duelResolved = false;

function duelPlayTick() { playSound(800, 'sine', .15, .04); }
function duelPlayBoom() { playSound(100, 'sawtooth', .5, .15); setTimeout(() => playSound(80, 'square', .4, .2), 80); }
function duelPlayDrum() { playSound(150, 'triangle', .3, .08); }
function duelPlaySuspense(i) {
  // Rising pitch tension ticks
  const freq = 300 + i * 60;
  playSound(freq, 'sine', .12, .06);
}

function duelWatchGame(code, wager) {
  currentDuelRoom = code;
  _duelAnimating = false;
  _duelResolved = false;
  const overlay = document.getElementById('duelGameOverlay');
  overlay.style.display = 'flex';
  document.getElementById('duelCloseBtn').style.display = 'none';
  document.getElementById('duelResultText').style.display = 'none';
  document.getElementById('duelCoin').style.display = 'none';
  document.getElementById('duelCoin').style.animation = 'none';
  document.getElementById('duelCountdown').style.display = 'none';
  document.getElementById('duelTensionBar').style.display = 'none';
  document.getElementById('duelStatusText').textContent = 'WAITING FOR OPPONENT...';
  document.getElementById('duelWagerText').textContent = '⚔️ $' + formatBalance(wager) + ' ON THE LINE ⚔️';
  document.getElementById('duelVsText').textContent = 'VS';
  document.getElementById('duelInner').classList.remove('duel-overlay-shake');

  if (duelRoomUnsub) { duelRoomUnsub(); duelRoomUnsub = null; }
  
  duelRoomUnsub = window._fbOnValue('casino/duelRooms/' + code, (snap) => {
    if (!snap.exists()) return;
    const room = snap.val();
    document.getElementById('duelP1Name').textContent = room.hostName || 'Host';
    document.getElementById('duelP2Name').textContent = room.challengerName || 'Waiting...';
    
    if (room.status === 'playing' && !room.result && !_duelAnimating) {
      _duelAnimating = true;
      document.getElementById('duelStatusText').textContent = 'OPPONENT FOUND!';
      // Host resolves after a delay to allow animation sync
      if (room.host === window._currentPlayerId) {
        setTimeout(() => duelResolve(code), 7500);
      }
      // Fallback: challenger also attempts resolve after 12s in case host disconnected
      if (room.challenger === window._currentPlayerId) {
        setTimeout(() => duelResolve(code), 12000);
      }
      // Absolute timeout: if still no result after 20s, force-resolve and refund
      setTimeout(async () => {
        const checkSnap = await window._fbGet('casino/duelRooms/' + code);
        if (checkSnap.exists() && !checkSnap.val().result) {
          // Try to resolve one more time
          duelResolve(code);
          // If still stuck after 3 more seconds, refund and close
          setTimeout(async () => {
            const finalSnap = await window._fbGet('casino/duelRooms/' + code);
            if (finalSnap.exists() && !finalSnap.val().result) {
              balance += wager; updateBalDisplay();
              showToast('Duel timed out — wager refunded!', false);
              document.getElementById('duelGameOverlay').style.display = 'none';
              if (duelRoomUnsub) { duelRoomUnsub(); duelRoomUnsub = null; }
              window._fbRemove('casino/duelRooms/' + code).catch(()=>{});
            }
          }, 3000);
        }
      }, 20000);
      // Start the dramatic sequence
      duelDramaticSequence(room);
    }
    
    if (room.result && !_duelResolved) {
      _duelResolved = true;
      duelShowResult(room);
    }
  });
}

function duelDramaticSequence(room) {
  const countdownEl = document.getElementById('duelCountdown');
  const coinEl = document.getElementById('duelCoin');
  const statusEl = document.getElementById('duelStatusText');
  const tensionBar = document.getElementById('duelTensionBar');
  const tensionFill = document.getElementById('duelTensionFill');
  
  // Phase 1: Countdown 3... 2... 1...
  countdownEl.style.display = 'block';
  let count = 3;
  countdownEl.textContent = count;
  countdownEl.style.animation = 'none';
  void countdownEl.offsetWidth;
  countdownEl.style.animation = 'duelCountPulse .5s ease-out';
  duelPlayTick();
  
  const countInterval = setInterval(() => {
    count--;
    if (count > 0) {
      countdownEl.textContent = count;
      countdownEl.style.animation = 'none';
      void countdownEl.offsetWidth;
      countdownEl.style.animation = 'duelCountPulse .5s ease-out';
      duelPlayTick();
    } else if (count === 0) {
      countdownEl.textContent = '⚔️';
      countdownEl.style.animation = 'none';
      void countdownEl.offsetWidth;
      countdownEl.style.animation = 'duelCountPulse .5s ease-out';
      duelPlayBoom();
      
      // Flash
      const flash = document.getElementById('duelFlash');
      flash.style.background = 'white';
      flash.style.animation = 'duelFlashBang .4s ease-out forwards';
      setTimeout(() => { flash.style.animation = 'none'; }, 500);
      
      // Phase 2: Coin spinning with pure visual drama
      setTimeout(() => {
        countdownEl.style.display = 'none';
        coinEl.style.display = 'flex';
        coinEl.style.animation = 'duelCoinSpin .12s linear infinite';
        tensionBar.style.display = 'block';
        
        // Create fog/atmosphere overlay
        const gameOverlay = document.getElementById('duelGameOverlay');
        const fogTint = document.createElement('div');
        fogTint.style.position = 'absolute';
        fogTint.style.top = '0';
        fogTint.style.left = '0';
        fogTint.style.width = '100%';
        fogTint.style.height = '100%';
        fogTint.style.pointerEvents = 'none';
        fogTint.style.background = 'radial-gradient(ellipse at center, transparent 0%, rgba(30,58,138,0.3) 100%)';
        fogTint.style.opacity = '0';
        gameOverlay.appendChild(fogTint);
        
        duelPlayDrum();
        
        // Phase 3: Tension build — coin exponentially slows with visual atmosphere
        let tensionStep = 0;
        const tensionTotal = 40;
        const tensionInterval = setInterval(() => {
          tensionStep++;
          const pct = Math.min((tensionStep / tensionTotal) * 100, 100);
          tensionFill.style.width = pct + '%';
          
          // Exponential slowdown: easing formula for more dramatic pause
          const eased = (tensionStep / tensionTotal);
          const speed = 0.12 + eased * eased * 2.0; // Accelerates slowdown
          coinEl.style.animation = 'duelCoinSpin ' + speed.toFixed(3) + 's linear infinite';
          
          // Coin glow pulses with tension
          const glowIntensity = 8 + Math.sin(tensionStep / 8) * 6;
          coinEl.style.filter = 'drop-shadow(0 0 ' + glowIntensity + 'px rgba(255, 200, 0, 0.7)) saturate(1.2)';
          
          // Screen saturation pulses during tension (visual energy)
          if (tensionStep < tensionTotal - 5) {
            const saturation = 0.9 + Math.sin(tensionStep / 4) * 0.15;
            gameOverlay.style.filter = 'saturate(' + saturation + ') brightness(1.05)';
          }
          
          // Fog intensity builds toward end
          fogTint.style.opacity = (pct / 100 * 0.6).toFixed(3);
          
          // Suspense ticks get higher pitch
          if (tensionStep % 3 === 0) duelPlaySuspense(tensionStep / 3);
          
          // Final dramatic pause — ultra-slow spin
          if (tensionStep >= tensionTotal - 7) {
            coinEl.style.animation = 'duelCoinSpin 3s linear infinite';
          }
          
          if (tensionStep >= tensionTotal) {
            clearInterval(tensionInterval);
            // Hide tension bar and coin — result will be shown by duelShowResult
            tensionBar.style.display = 'none';
            gameOverlay.style.filter = 'saturate(1) brightness(1)';
            fogTint.style.opacity = '0';
            setTimeout(()=>{ fogTint.remove(); }, 500);
          }
        }, 85);
      }, 600);
      
      clearInterval(countInterval);
    }
  }, 1000);
}

async function duelResolve(code) {
  const snap = await window._fbGet('casino/duelRooms/' + code);
  if (!snap.exists()) return;
  const room = snap.val();
  if (room.result) return; // Already resolved
  
  // Coinflip: 50/50
  const flip = Math.random() < 0.5 ? 'heads' : 'tails';
  const winnerId = flip === 'heads' ? room.host : room.challenger;
  const winnerName = flip === 'heads' ? room.hostName : room.challengerName;
  const loserId = flip === 'heads' ? room.challenger : room.host;
  const loserName = flip === 'heads' ? room.challengerName : room.hostName;
  const pot = room.wager * 2;
  
  await window._fbUpdate('casino/duelRooms/' + code, {
    result: flip,
    winner: winnerId,
    winnerName: winnerName,
    loserId: loserId,
    loserName: loserName,
    pot: pot,
    status: 'finished',
    finishedAt: Date.now()
  });
}

function duelShowResult(room) {
  const coin = document.getElementById('duelCoin');
  const inner = document.getElementById('duelInner');
  const flash = document.getElementById('duelFlash');
  const statusEl = document.getElementById('duelStatusText');
  const resultEl = document.getElementById('duelResultText');
  const isWinner = room.winner === window._currentPlayerId;
  const isLoser = room.loserId === window._currentPlayerId;
  
  // SLAM — screen shake + flash
  duelPlayBoom();
  inner.classList.remove('duel-overlay-shake');
  void inner.offsetWidth;
  inner.classList.add('duel-overlay-shake');
  
  // Flash the screen in winner's color
  flash.style.background = isWinner ? '#00e676' : isLoser ? '#ff1744' : '#ffd700';
  flash.style.animation = 'duelFlashBang .6s ease-out forwards';
  setTimeout(() => { flash.style.animation = 'none'; }, 700);
  
  // Reveal the coin — snap to result
  coin.style.animation = room.result === 'heads' ? 'duelCoinRevealHeads .8s ease-out forwards' : 'duelCoinRevealTails .8s ease-out forwards';
  
  // Show result text with dramatic slam animation
  setTimeout(() => {
    resultEl.style.display = 'block';
    resultEl.className = 'duel-result duel-result-reveal';
    statusEl.textContent = room.result === 'heads' ? '🟡 HEADS! 🟡' : '⚫ TAILS! ⚫';
    
    if (isWinner) {
      resultEl.textContent = '💰 YOU WIN! 💰';
      resultEl.style.color = '#00e676';
      resultEl.classList.add('duel-win-glow');
      // Huge boom sound
      setTimeout(() => {
        playSound(200, 'square', .4, .1);
        setTimeout(() => playSound(300, 'square', .4, .1), 100);
        setTimeout(() => playSound(400, 'square', .4, .1), 200);
        setTimeout(() => playSound(600, 'square', .5, .15), 300);
        setTimeout(() => playSound(800, 'sine', .3, .2), 400);
      }, 100);
      // Massive particles
      balance += room.pot;
      updateBalDisplay();
      showBigWin(room.pot);
      spawnParticles(window.innerWidth / 2, window.innerHeight / 2, 60);
      setTimeout(() => spawnParticles(window.innerWidth / 3, window.innerHeight / 2, 30), 200);
      setTimeout(() => spawnParticles(window.innerWidth * 2 / 3, window.innerHeight / 2, 30), 400);
      showToast('🎉 +$' + formatBalance(room.pot) + ' from duel!');
      recordGame('duels', room.wager, room.pot);
      // Flash green multiple times
      let flashCount = 0;
      const flashInterval = setInterval(() => {
        flash.style.background = '#00e676';
        flash.style.animation = 'duelFlashBang .3s ease-out forwards';
        setTimeout(() => { flash.style.animation = 'none'; }, 350);
        flashCount++;
        if (flashCount >= 3) clearInterval(flashInterval);
      }, 400);
    } else if (isLoser) {
      resultEl.textContent = '💀 YOU LOSE 💀';
      resultEl.style.color = '#ff1744';
      playLoseSound();
      recordGame('duels', room.wager, 0);
    } else {
      resultEl.textContent = room.winnerName + ' WINS!';
      resultEl.style.color = 'var(--gold)';
    }
    
    // Show pot amount
    document.getElementById('duelWagerText').textContent = room.winnerName + ' takes $' + formatBalance(room.pot) + '!';
  }, 400);
  
  document.getElementById('duelCloseBtn').style.display = '';
  
  // Save to local history
  duelHistory.unshift({ winner: room.winnerName, loser: room.loserName, pot: room.pot, time: Date.now() });
  if (duelHistory.length > 20) duelHistory.length = 20;
  localStorage.setItem('casino_duel_history', JSON.stringify(duelHistory));
  
  // Broadcast big wins
  if (isWinner && room.pot >= 500 && window._broadcastWin) {
    window._broadcastWin(window._currentUsername, 'Duel', room.pot);
  }
  
  // Cleanup room after 10 seconds
  if (room.host === window._currentPlayerId) {
    setTimeout(() => {
      window._fbRemove('casino/duelRooms/' + currentDuelRoom).catch(() => {});
    }, 10000);
  }
  
  if (duelRoomUnsub) { duelRoomUnsub(); duelRoomUnsub = null; }
  firebaseSave();
}

function duelCloseOverlay() {
  document.getElementById('duelGameOverlay').style.display = 'none';
  currentDuelRoom = null;
  duelLoadLobby();
}

function duelLoadLobby() {
  // Poll for open duels every 5s instead of real-time listener (saves bandwidth)
  if (duelLobbyUnsub) { clearInterval(duelLobbyUnsub); duelLobbyUnsub = null; }
  async function _pollDuels() {
    try {
      const snap = await window._fbGet('casino/duelRooms');
      const list = document.getElementById('duelList');
      if (!list) return;
      if (!snap.exists()) {
        list.innerHTML = '<div style="text-align:center;color:var(--text2);font-size:12px;padding:20px;">No open duels. Create one!</div>';
        return;
      }
      const rooms = snap.val();
      let html = '';
      let hasOpen = false;
      Object.entries(rooms).forEach(([code, room]) => {
        if (room.status !== 'waiting') return;
        if (Date.now() - room.created > 300000) return;
        hasOpen = true;
        const isHost = room.host === window._currentPlayerId;
        const badge = room.hostPrestige > 0 ? getPrestigeBadgeHTML(room.hostPrestige) : '';
        html += `<div class="duel-card">
          <div>
            <div class="duel-host">${escapeHtml(room.hostName || 'Unknown')} ${badge}</div>
            <div style="font-size:10px;color:var(--text2);">${isHost ? 'Your duel — waiting...' : 'Open duel'}</div>
          </div>
          <div class="duel-wager">$${formatBalance(room.wager)}</div>
          ${isHost
            ? `<button class="duel-join" style="background:var(--red);" onclick="duelCancel('${code}')">CANCEL</button>`
            : `<button class="duel-join" onclick="duelJoin('${code}')">JOIN ⚔️</button>`}
        </div>`;
      });
      if (!hasOpen) {
        html = '<div style="text-align:center;color:var(--text2);font-size:12px;padding:20px;">No open duels. Create one!</div>';
      }
      list.innerHTML = html;
    } catch(e) {}
  }
  _pollDuels();
  duelLobbyUnsub = setInterval(_pollDuels, 5000);
  
  // Render local duel history
  renderDuelHistory();
}

async function duelCancel(code) {
  const snap = await window._fbGet('casino/duelRooms/' + code);
  if (snap.exists()) {
    const room = snap.val();
    if (room.host === window._currentPlayerId && room.status === 'waiting') {
      balance += room.wager; // Refund
      updateBalDisplay();
      await window._fbRemove('casino/duelRooms/' + code);
      showToast('Duel cancelled, wager refunded.', true);
    }
  }
}

function renderDuelHistory() {
  const el = document.getElementById('duelHistory');
  if (!el) return;
  if (duelHistory.length === 0) {
    el.innerHTML = '<div style="text-align:center;color:var(--text2);font-size:11px;padding:8px;">No duels yet.</div>';
    return;
  }
  el.innerHTML = duelHistory.slice(0, 10).map(d => {
    const ago = Math.floor((Date.now() - d.time) / 60000);
    const timeStr = ago < 1 ? 'just now' : ago + 'm ago';
    return `<div class="duel-history-item">
      <span style="color:var(--green);">${escapeHtml(d.winner)}</span>
      <span style="color:var(--text2);">beat</span>
      <span style="color:var(--red);">${escapeHtml(d.loser)}</span>
      <span style="color:var(--gold);font-family:'Orbitron';">$${formatBalance(d.pot)}</span>
      <span style="color:var(--text2);">${timeStr}</span>
    </div>`;
  }).join('');
}

// ============ TRADING SYSTEM (Multi-Step) ============
let tradeHistory = [];
try { tradeHistory = JSON.parse(localStorage.getItem('casino_trade_history') || '[]'); } catch(e) { tradeHistory = []; }
let _tradeRequestUnsub = null;
let _tradePartner = '';

function openTradeOverlay() {
  playClickSound();
  document.getElementById('tradeOverlay').style.display = 'block';
  tradeGoToStep(1);
  loadIncomingTrades();
  loadTradeRequests();
}
function closeTradeOverlay() {
  document.getElementById('tradeOverlay').style.display = 'none';
  if (_tradeRequestUnsub) { _tradeRequestUnsub(); _tradeRequestUnsub = null; }
}
// legacy aliases
function showTradePanel() { openTradeOverlay(); }

function openStoreOverlay() {
  playClickSound();
  document.getElementById('storeOverlay').style.display = 'block';
  storePopulateListSelect();
  loadStoreListings();
}
function closeStoreOverlay() {
  document.getElementById('storeOverlay').style.display = 'none';
}
function showStorePanel() { openStoreOverlay(); }

function tradeGoToStep(n) {
  document.getElementById('tradeStep1').style.display = n === 1 ? 'block' : 'none';
  document.getElementById('tradeStep2').style.display = n === 2 ? 'block' : 'none';
  document.getElementById('tradeStep3').style.display = n === 3 ? 'block' : 'none';
  if (n === 1) {
    document.getElementById('tradeRecipient').value = '';
    document.getElementById('tradeUserStatus').textContent = '';
    document.getElementById('tradeRequestBtn').disabled = true;
    document.getElementById('tradeRequestBtn').style.opacity = '0.5';
    if (_tradeRequestUnsub) { _tradeRequestUnsub(); _tradeRequestUnsub = null; }
  }
}

// Username validation on input
(function() {
  const inp = document.getElementById('tradeRecipient');
  if (!inp) return;
  let debounce;
  inp.addEventListener('input', () => {
    const btn = document.getElementById('tradeRequestBtn');
    const st = document.getElementById('tradeUserStatus');
    clearTimeout(debounce);
    const u = inp.value.trim().toLowerCase();
    if (u.length < 2) { btn.disabled = true; btn.style.opacity = '0.5'; st.textContent = ''; return; }
    st.textContent = 'Checking...';
    st.style.color = 'var(--text2)';
    debounce = setTimeout(async () => {
      if (!window._sendTradeRequest) { st.textContent = 'Login first'; st.style.color = 'var(--red)'; return; }
      try {
        // Just check if user exists
        const nameSnap = await window._checkUsernameExists(u);
        if (nameSnap) {
          st.innerHTML = '✅ <strong style="color:var(--neon);">' + u + '</strong> found';
          st.style.color = 'var(--green)';
          btn.disabled = false;
          btn.style.opacity = '1';
        } else {
          st.textContent = '❌ Player not found';
          st.style.color = 'var(--red)';
          btn.disabled = true;
          btn.style.opacity = '0.5';
        }
      } catch(e) { st.textContent = 'Error checking'; st.style.color = 'var(--red)'; }
    }, 500);
  });
})();

async function tradeRequestSend() {
  const u = document.getElementById('tradeRecipient').value.trim().toLowerCase();
  const st = document.getElementById('tradeUserStatus');
  if (!u) return;
  if (!window._sendTradeRequest) { st.textContent = 'Login first'; st.style.color = 'var(--red)'; return; }
  st.textContent = '⏳ Sending request...';
  try {
    const res = await window._sendTradeRequest(u);
    if (res.error) { st.textContent = '❌ ' + res.error; st.style.color = 'var(--red)'; return; }
    _tradePartner = u;
    document.getElementById('tradeWaitingFor').textContent = u;
    tradeGoToStep(2);
    // Animate waiting dots
    let dots = 0;
    const dotsEl = document.getElementById('tradeWaitDots');
    const dotsI = setInterval(() => { dots = (dots + 1) % 4; dotsEl.textContent = '.'.repeat(dots + 1); }, 600);
    // Listen for response
    _tradeRequestUnsub = window._listenTradeRequestResponse(res.recipientUid, res.requestId,
      async () => { // accepted
        clearInterval(dotsI);
        document.getElementById('tradePartnerName').textContent = u;
        // Create live trade session
        const tradeId = await window._createLiveTrade(res.recipientUid, u);
        if (tradeId) {
          _liveTradeId = tradeId;
          _liveTradeIsHost = true;
          _liveTradePartner = u;
          tradeGoToStep(3);
          populateTradeSelect();
          startLiveTradeListener(tradeId);
        }
        showToast('🤝 ' + u + ' accepted! Live trade started!', true);
      },
      () => { // declined
        clearInterval(dotsI);
        showToast('❌ ' + u + ' declined your trade request', false);
        tradeGoToStep(1);
      }
    );
  } catch(e) { st.textContent = '❌ Error'; st.style.color = 'var(--red)'; }
}

function tradeCancelRequest() {
  if (_tradeRequestUnsub) { _tradeRequestUnsub(); _tradeRequestUnsub = null; }
  tradeGoToStep(1);
  showToast('Trade request cancelled');
}

function tradeCancelSession() {
  if (_tradeRequestUnsub) { _tradeRequestUnsub(); _tradeRequestUnsub = null; }
  if (_liveTradeUnsub) { try { _liveTradeUnsub(); } catch(e) {} _liveTradeUnsub = null; }
  if (_liveTradeId) { window._fbUpdate('casino/liveTrades/' + _liveTradeId, { status: 'cancelled' }); }
  _liveTradeId = null;
  tradeGoToStep(1);
}

// ============ LIVE TRADE FUNCTIONS ============
let _liveTradeId = null;
let _liveTradeIsHost = false;
let _liveTradePartner = '';
let _liveTradeUnsub = null;
let _liveTradeMyItems = []; // array of itemIds currently offered
let _liveTradeReady = false;

function startLiveTradeListener(tradeId) {
  if (_liveTradeUnsub) { try { _liveTradeUnsub(); } catch(e) {} }
  _liveTradeMyItems = [];
  _liveTradeReady = false;
  
  _liveTradeUnsub = window._fbOnValue('casino/liveTrades/' + tradeId, snap => {
    const t = snap.val();
    if (!t) return;
    
    if (t.status === 'cancelled') {
      showToast('Trade was cancelled', false);
      if (_liveTradeUnsub) { try { _liveTradeUnsub(); } catch(e) {} _liveTradeUnsub = null; }
      tradeGoToStep(1);
      return;
    }
    
    if (t.status === 'completed') {
      showToast('🤝 Trade completed successfully!', true);
      if (_liveTradeUnsub) { try { _liveTradeUnsub(); } catch(e) {} _liveTradeUnsub = null; }
      // Refresh balance and inventory
      if (typeof checkPendingRefunds === 'function') setTimeout(checkPendingRefunds, 1000);
      tradeGoToStep(1);
      return;
    }
    
    // Update "their offer" display
    const isHost = _liveTradeIsHost;
    const theirOffer = isHost ? t.guestOffer : t.hostOffer;
    const theirReady = isHost ? t.guestReady : t.hostReady;
    const myReady = isHost ? t.hostReady : t.guestReady;
    
    // Their items
    const theirItemsEl = document.getElementById('liveTradeTheirItems');
    const theirItems = (theirOffer?.items || '').split(',').filter(Boolean);
    if (theirItems.length === 0) {
      theirItemsEl.textContent = 'No items offered';
    } else {
      theirItemsEl.innerHTML = theirItems.map(id => {
        const cat = (typeof ITEM_CATALOG !== 'undefined') ? ITEM_CATALOG[id] : null;
        return cat ? `<span style="margin-right:4px;">${cat.icon} ${cat.name}</span>` : id;
      }).join('<br>');
    }
    
    // Their cash
    document.getElementById('liveTradeTheirCash').textContent = '$' + Math.floor(theirOffer?.cash || 0).toLocaleString();
    
    // Their ready status
    document.getElementById('liveTradeTheirReadyStatus').innerHTML = theirReady ? 
      '<span style="color:var(--green);">✅ LOCKED IN</span>' : 
      '<span style="color:var(--text2);">⏳ Not locked in</span>';
    
    // Show confirm button if both ready
    document.getElementById('liveTradeConfirmArea').style.display = (myReady && theirReady) ? 'block' : 'none';
  });
}

function liveTradeAddItem() {
  if (_liveTradeReady) return; // Can't modify after lock-in
  const sel = document.getElementById('tradeItemSelect');
  const invId = parseInt(sel.value);
  if (!invId) return;
  
  const item = inventory.find(x => x.id === invId);
  if (!item) return;
  
  // Check if already added
  if (_liveTradeMyItems.includes(item.itemId)) {
    showToast('Item already in offer', false);
    return;
  }
  
  _liveTradeMyItems.push(item.itemId);
  sel.value = '';
  liveTradeUpdateMyDisplay();
  liveTradeSync();
}

function liveTradeRemoveItem(idx) {
  if (_liveTradeReady) return;
  _liveTradeMyItems.splice(idx, 1);
  liveTradeUpdateMyDisplay();
  liveTradeSync();
}

function liveTradeUpdateMyDisplay() {
  const el = document.getElementById('liveTradeMyItems');
  if (_liveTradeMyItems.length === 0) {
    el.textContent = 'No items added';
    return;
  }
  el.innerHTML = _liveTradeMyItems.map((id, i) => {
    const cat = (typeof ITEM_CATALOG !== 'undefined') ? ITEM_CATALOG[id] : null;
    const name = cat ? `${cat.icon} ${cat.name}` : id;
    return `<div style="display:flex;align-items:center;gap:6px;margin-bottom:2px;">${name} <button onclick="liveTradeRemoveItem(${i})" style="padding:1px 6px;background:var(--red);border:none;border-radius:4px;color:#fff;cursor:pointer;font-size:9px;">✕</button></div>`;
  }).join('');
}

function liveTradeUpdateCash() {
  if (_liveTradeReady) return;
  liveTradeSync();
}

async function liveTradeSync() {
  if (!_liveTradeId) return;
  const offerKey = _liveTradeIsHost ? 'hostOffer' : 'guestOffer';
  const cash = Math.max(0, parseInt(document.getElementById('tradeCashAmount').value) || 0);
  await window._fbUpdate('casino/liveTrades/' + _liveTradeId, {
    [offerKey]: {
      items: _liveTradeMyItems.join(','),
      cash: cash
    },
    [_liveTradeIsHost ? 'hostReady' : 'guestReady']: false
  });
  _liveTradeReady = false;
  document.getElementById('liveTradeReadyBtn').textContent = '✅ LOCK IN';
  document.getElementById('liveTradeReadyBtn').style.background = 'linear-gradient(135deg,#00cc66,#009944)';
}

async function liveTradeToggleReady() {
  if (!_liveTradeId) return;
  _liveTradeReady = !_liveTradeReady;
  const key = _liveTradeIsHost ? 'hostReady' : 'guestReady';
  await window._fbUpdate('casino/liveTrades/' + _liveTradeId, { [key]: _liveTradeReady });
  
  if (_liveTradeReady) {
    document.getElementById('liveTradeReadyBtn').textContent = '🔓 UNLOCK';
    document.getElementById('liveTradeReadyBtn').style.background = 'linear-gradient(135deg,#ff4444,#cc0000)';
  } else {
    document.getElementById('liveTradeReadyBtn').textContent = '✅ LOCK IN';
    document.getElementById('liveTradeReadyBtn').style.background = 'linear-gradient(135deg,#00cc66,#009944)';
  }
}

async function liveTradeExecute() {
  if (!_liveTradeId) return;
  const statusEl = document.getElementById('tradeStatus');
  statusEl.textContent = '⏳ Executing trade...';
  
  // Remove items from local inventory before executing
  const myItemsCopy = [..._liveTradeMyItems];
  for (const itemId of myItemsCopy) {
    const idx = inventory.findIndex(x => x.itemId === itemId);
    if (idx >= 0) inventory.splice(idx, 1);
  }
  
  // Deduct cash
  const cash = Math.max(0, parseInt(document.getElementById('tradeCashAmount').value) || 0);
  if (cash > 0) { balance -= cash; updateBalDisplay(); }
  
  const res = await window._executeLiveTrade(_liveTradeId);
  if (res.error) {
    statusEl.textContent = '❌ ' + res.error;
    statusEl.style.color = 'var(--red)';
    // Restore items on error
    return;
  }
  
  statusEl.textContent = '✅ Trade completed!';
  statusEl.style.color = 'var(--green)';
  firebaseSave();
  // Listener will handle cleanup via status=completed
}

async function loadTradeRequests() {
  if (!window._loadTradeRequests) return;
  try {
    const reqs = await window._loadTradeRequests();
    // Show as part of inbox
    const div = document.getElementById('incomingTrades');
    if (reqs.length > 0) {
      const reqHtml = reqs.map((r, idx) => {
        const dataId = 'tradeReq_' + idx;
        window[dataId] = { requestId: r.id, fromName: r.from, fromUid: r.fromUid };
        return `<div style="background:var(--bg);border:1px solid rgba(0,230,118,.4);border-radius:10px;padding:12px;display:flex;align-items:center;gap:10px;">
          <div style="font-size:28px;">🤝</div>
          <div style="flex:1;min-width:0;">
            <div style="font-weight:700;font-size:13px;color:var(--green);">Trade Request</div>
            <div style="font-size:11px;color:var(--text2);">From <strong style="color:var(--neon);">${r.from}</strong></div>
            <div style="font-size:10px;color:var(--text2);margin-top:2px;">${new Date(r.ts).toLocaleString()}</div>
          </div>
          <div style="display:flex;flex-direction:column;gap:4px;">
            <button onclick="handleTradeResponse('${dataId}', true)" style="padding:6px 14px;background:linear-gradient(135deg,#00cc66,#009944);border:none;border-radius:6px;color:#fff;cursor:pointer;font-size:11px;font-weight:700;font-family:'Orbitron';">ACCEPT</button>
            <button onclick="handleTradeResponse('${dataId}', false)" style="padding:4px 12px;background:transparent;border:1px solid var(--red);border-radius:6px;color:var(--red);cursor:pointer;font-size:10px;">DECLINE</button>
          </div>
        </div>`;
      }).join('');
      // Prepend to inbox
      const existing = div.innerHTML;
      if (existing.includes('No pending')) div.innerHTML = reqHtml;
      else div.innerHTML = reqHtml + existing;
    }
  } catch(e) {}
}

async function handleTradeResponse(dataId, accepted) {
  const data = window[dataId];
  if (!data) return;
  await respondTradeRequest(data.requestId, data.fromName, data.fromUid, accepted);
}

async function respondTradeRequest(reqId, fromName, fromUid, accepted) {
  if (!window._respondTradeRequest) return;
  await window._respondTradeRequest(reqId, accepted);
  if (accepted) {
    showToast('✅ Accepted! Starting live trade with ' + fromName, true);
    _liveTradePartner = fromName;
    _liveTradeIsHost = false;
    // The host will create the live trade — guest must poll for it
    switchTradeTab('send', document.getElementById('tradeSendTab'));
    document.getElementById('tradePartnerName').textContent = fromName;
    tradeGoToStep(3);
    populateTradeSelect();
    // Poll for the live trade ID that the host creates
    let pollCount = 0;
    const pollForLive = setInterval(async () => {
      pollCount++;
      if (pollCount > 60) { clearInterval(pollForLive); showToast('Trade session timeout', false); tradeGoToStep(1); return; }
      try {
        const snap = await window._fbGet('casino/liveTrades');
        if (!snap.exists()) return;
        const trades = snap.val();
        for (const [tid, t] of Object.entries(trades)) {
          if (t.guest === window._currentPlayerId && t.host !== window._currentPlayerId && t.status === 'active' && Date.now() - t.created < 60000) {
            clearInterval(pollForLive);
            _liveTradeId = tid;
            startLiveTradeListener(tid);
            return;
          }
        }
      } catch(e) {}
    }, 1000);
  } else {
    showToast('Declined trade request from ' + fromName, false);
  }
  loadIncomingTrades();
  loadTradeRequests();
}

function switchTradeTab(tab, btn) {
  document.querySelectorAll('#tradePanel .inv-tab').forEach(b => b.classList.remove('active'));
  if(btn) btn.classList.add('active');
  document.getElementById('tradeSendView').style.display = tab === 'send' ? 'block' : 'none';
  document.getElementById('tradeInboxView').style.display = tab === 'inbox' ? 'block' : 'none';
  document.getElementById('tradeHistoryView').style.display = tab === 'history' ? 'block' : 'none';
  document.getElementById('giftView').style.display = tab === 'gift' ? 'block' : 'none';
  if (tab === 'send') tradeGoToStep(1);
  if (tab === 'inbox') { loadIncomingTrades(); loadTradeRequests(); }
  if (tab === 'history') renderTradeHistory();
  if (tab === 'gift') { document.getElementById('giftUsername').focus(); }
}

// ============ GIFT SYSTEM UI ============
function quickGiftAmount(amt) {
  document.getElementById('giftAmount').value = amt;
}

async function sendGift() {
  const statusEl = document.getElementById('giftStatus');
  const usernameEl = document.getElementById('giftUsername');
  const amountEl = document.getElementById('giftAmount');
  
  const username = usernameEl.value.trim();
  const amount = parseFloat(amountEl.value);
  
  if (!username) {
    statusEl.textContent = '❌ Please enter a username';
    statusEl.style.color = 'var(--red)';
    return;
  }
  
  if (!amount || amount < 1) {
    statusEl.textContent = '❌ Invalid amount (minimum $1)';
    statusEl.style.color = 'var(--red)';
    return;
  }
  
  statusEl.textContent = '⏳ Processing gift...';
  statusEl.style.color = 'var(--text2)';
  
  const result = await window._giftMoney(username, amount);
  
  if (result.error) {
    statusEl.textContent = '❌ ' + result.error;
    statusEl.style.color = 'var(--red)';
  } else {
    statusEl.textContent = '✅ Gift sent! Your balance: $' + Math.floor(result.newBalance);
    statusEl.style.color = 'var(--green)';
    usernameEl.value = '';
    amountEl.value = '';
    showToast('💝 Sent $' + Math.floor(amount) + ' to ' + username + '!', true);
    // Update player balance display
    balance = result.newBalance; updateBalDisplay(); firebaseSave();
    setTimeout(() => {
      statusEl.textContent = '';
    }, 3000);
  }
}

// ============ LOAN SYSTEM (REMOVED) ============
function openLoanOverlay() { showToast('Loans have been removed!', false); }
function closeLoanOverlay() {}
function switchLoanTab() {}
function takeBankLoan() { showToast('Loans have been removed!', false); }
function enforceBankLoanRepayment() {}
function repayLoan() {}
function sendPlayerLoan() {}
function loadMyLoans() {}

function populateTradeSelect() {
  const sel = document.getElementById('tradeItemSelect');
  if (!sel) return;
  sel.innerHTML = '<option value="">Select an item...</option>';
  inventory.forEach(item => {
    const cat = ITEM_CATALOG ? ITEM_CATALOG[item.itemId] : null;
    const name = cat ? (cat.icon + ' ' + cat.name) : item.itemId;
    const val = typeof getItemMarketValue === 'function' ? getItemMarketValue(item.itemId) : 0;
    sel.innerHTML += '<option value="' + item.id + '">' + name + ' ($' + val.toFixed(0) + ')</option>';
  });
  sel.onchange = updateTradePreview;
}

function updateTradePreview() {
  const sel = document.getElementById('tradeItemSelect');
  const preview = document.getElementById('tradeItemPreview');
  const invId = parseInt(sel.value);
  if (!invId) { preview.innerHTML = '<div style="color:var(--text2);font-size:12px;">Select an item above</div>'; updateTradeSummary(); return; }
  const item = inventory.find(x => x.id === invId);
  if (!item) { preview.innerHTML = '<div style="color:var(--red);font-size:12px;">Item not found</div>'; return; }
  const cat = ITEM_CATALOG[item.itemId];
  if (!cat) { preview.innerHTML = '<div style="color:var(--text2);">Unknown</div>'; return; }
  const val = typeof getItemMarketValue === 'function' ? getItemMarketValue(item.itemId) : cat.baseValue;
  const rar = RARITY[cat.rarity];
  preview.innerHTML = '<div style="font-size:36px;">' + cat.icon + '</div>'
    + '<div style="font-weight:700;font-size:14px;color:' + rar.color + ';">' + cat.name + '</div>'
    + '<div style="font-size:10px;color:' + rar.color + ';letter-spacing:1px;">' + rar.label.toUpperCase() + '</div>'
    + '<div style="font-family:Orbitron;font-size:16px;color:var(--gold);margin-top:4px;">$' + val.toFixed(2) + '</div>'
    + '<div style="height:3px;width:100%;background:' + rar.color + ';border-radius:2px;margin-top:4px;opacity:.6;"></div>';
  updateTradeSummary();
}

function updateTradeSummary() {
  const summary = document.getElementById('tradeSummary');
  if (!summary) return;
  const invId = parseInt((document.getElementById('tradeItemSelect') || {}).value || '0');
  const cash = parseFloat((document.getElementById('tradeCashAmount') || {}).value || '0') || 0;
  if (!invId && cash <= 0) { summary.innerHTML = '<div style="color:var(--text2);font-size:11px;text-align:center;">Select items above</div>'; return; }
  let html = '<div style="font-size:11px;color:var(--text2);margin-bottom:6px;">TRADE SUMMARY</div>';
  if (invId) {
    const item = inventory.find(x => x.id === invId);
    const cat = item ? ITEM_CATALOG[item.itemId] : null;
    if (cat) {
      const val = typeof getItemMarketValue === 'function' ? getItemMarketValue(item.itemId) : cat.baseValue;
      html += '<div style="display:flex;align-items:center;gap:6px;margin-bottom:4px;"><span style="font-size:16px;">' + cat.icon + '</span><span style="font-size:12px;font-weight:600;">' + cat.name + '</span><span style="font-size:11px;color:var(--gold);margin-left:auto;">$' + val.toFixed(0) + '</span></div>';
    }
  }
  if (cash > 0) html += '<div style="display:flex;align-items:center;gap:6px;margin-bottom:4px;"><span style="font-size:16px;">💵</span><span style="font-size:12px;font-weight:600;">Cash</span><span style="font-size:11px;color:var(--gold);margin-left:auto;">$' + cash.toFixed(0) + '</span></div>';
  html += '<div style="font-size:11px;color:var(--text2);margin-top:6px;border-top:1px solid var(--border);padding-top:6px;">To: <strong style="color:var(--neon);">' + _tradePartner + '</strong></div>';
  summary.innerHTML = html;
}

// Attach live updates for trade summary
setTimeout(() => {
  ['tradeCashAmount'].forEach(id => {
    const el = document.getElementById(id);
    if (el) el.addEventListener('input', updateTradeSummary);
  });
}, 100);

async function sendTrade() {
  const invId = parseInt(document.getElementById('tradeItemSelect').value);
  const cash = parseFloat(document.getElementById('tradeCashAmount').value) || 0;
  const message = (document.getElementById('tradeMessage') || {}).value || '';
  const status = document.getElementById('tradeStatus');
  if (!_tradePartner) { status.textContent = '⚠ No trade partner'; status.style.color = 'var(--red)'; return; }
  if (!invId && cash <= 0) { status.textContent = '⚠ Select an item or add cash'; status.style.color = 'var(--red)'; return; }
  if (cash > balance) { status.textContent = '⚠ Not enough balance'; status.style.color = 'var(--red)'; return; }
  if (!window._sendTradeOffer) { status.textContent = '⚠ Not logged in'; status.style.color = 'var(--red)'; return; }
  status.textContent = '⏳ Sending...';
  try {
    const item = invId ? inventory.find(x => x.id === invId) : null;
    if (invId && !item) throw new Error('Item not found');
    const res = await window._sendTradeOffer(_tradePartner, item || { itemId: '_cash_' }, cash, message.trim());
    if (res.error) throw new Error(res.error);
    if (item) removeFromInventory(invId);
    if (cash > 0) { balance -= cash; updateBalDisplay(); }
    const cat = item ? ITEM_CATALOG[item.itemId] : null;
    tradeHistory.unshift({ type: 'sent', to: _tradePartner, itemName: cat ? cat.name : (cash > 0 ? 'Cash' : 'Unknown'), itemIcon: cat ? cat.icon : '💵', cash, message: message.trim(), ts: Date.now() });
    if (tradeHistory.length > 50) tradeHistory = tradeHistory.slice(0, 50);
    try { localStorage.setItem('casino_trade_history', JSON.stringify(tradeHistory)); } catch(e) {}
    renderInventory(); populateTradeSelect();
    status.textContent = '✅ Sent to ' + _tradePartner + '!';
    status.style.color = 'var(--green)';
    showToast('📦 Trade sent to ' + _tradePartner, true);
    firebaseSave();
    // Reset after 2s
    setTimeout(() => { tradeGoToStep(1); }, 2000);
  } catch(e) { status.textContent = '❌ ' + (e.message || 'Failed'); status.style.color = 'var(--red)'; }
}

async function loadIncomingTrades() {
  const div = document.getElementById('incomingTrades');
  const countBadge = document.getElementById('tradeInboxCount');
  if (!window._loadPendingTrades) { div.innerHTML = '<div style="color:var(--text2);font-size:12px;text-align:center;padding:20px;">Login to see trades</div>'; return; }
  try {
    const trades = await window._loadPendingTrades();
    if (!trades || trades.length === 0) {
      div.innerHTML = '<div style="color:var(--text2);font-size:12px;text-align:center;padding:20px;">No pending trades</div>';
      if (countBadge) countBadge.style.display = 'none';
      return;
    }
    if (countBadge) { countBadge.style.display = 'inline'; countBadge.textContent = trades.length; }
    div.innerHTML = trades.map(t => {
      const cat = ITEM_CATALOG[t.itemId];
      const icon = cat ? cat.icon : '📦';
      const itemName = cat ? cat.name : (t.itemName || t.itemId);
      const rar = cat ? RARITY[cat.rarity] : null;
      const val = cat && typeof getItemMarketValue === 'function' ? getItemMarketValue(t.itemId) : 0;
      const cashPart = t.cash ? ' + $' + t.cash.toFixed(0) + ' cash' : '';
      const safeName = escapeHtml(t.from || 'Unknown');
      const safeMsg = t.message ? escapeHtml(t.message) : '';
      return '<div style="background:var(--bg);border:1px solid ' + (rar ? rar.color : 'var(--border)') + ';border-radius:10px;padding:12px;display:flex;align-items:center;gap:10px;">'
        + '<div style="font-size:28px;">' + icon + '</div>'
        + '<div style="flex:1;min-width:0;"><div style="font-weight:700;font-size:13px;color:' + (rar ? rar.color : 'var(--text)') + ';">' + escapeHtml(itemName) + cashPart + '</div>'
        + '<div style="font-size:11px;color:var(--text2);">From <strong style="color:var(--neon);">' + safeName + '</strong></div>'
        + (safeMsg ? '<div style="font-size:10px;color:var(--text2);font-style:italic;margin-top:2px;">"' + safeMsg + '"</div>' : '')
        + '<div style="font-size:10px;color:var(--text2);margin-top:2px;">' + (val > 0 ? 'Value: $' + val.toFixed(0) : '') + ' · ' + new Date(t.timestamp).toLocaleString() + '</div></div>'
        + '<div style="display:flex;flex-direction:column;gap:4px;">'
        + '<button onclick="acceptTrade(\'' + t.id + '\',\'' + t.itemId + '\',' + (t.cash || 0) + ')" style="padding:6px 14px;background:linear-gradient(135deg,#00cc66,#009944);border:none;border-radius:6px;color:#fff;cursor:pointer;font-size:11px;font-weight:700;font-family:Orbitron;">ACCEPT</button>'
        + '<button onclick="declineTrade(\'' + t.id + '\')" style="padding:4px 12px;background:transparent;border:1px solid var(--red);border-radius:6px;color:var(--red);cursor:pointer;font-size:10px;">DECLINE</button></div></div>';
    }).join('');
  } catch(e) { div.innerHTML = '<div style="color:var(--red);font-size:12px;text-align:center;padding:20px;">Error loading trades</div>'; }
}

async function acceptTrade(tradeId, itemId, cash) {
  if (!window._acceptTradeOffer) return;
  try {
    await window._acceptTradeOffer(tradeId);
    if (itemId && itemId !== '_cash_') addToInventory(itemId);
    if (cash > 0) { balance += cash; updateBalDisplay(); }
    const cat = ITEM_CATALOG[itemId];
    tradeHistory.unshift({ type: 'received', itemName: cat ? cat.name : (cash > 0 ? 'Cash' : 'Unknown'), itemIcon: cat ? cat.icon : '💵', cash: cash || 0, ts: Date.now() });
    if (tradeHistory.length > 50) tradeHistory = tradeHistory.slice(0, 50);
    try { localStorage.setItem('casino_trade_history', JSON.stringify(tradeHistory)); } catch(e) {}
    renderInventory(); loadIncomingTrades();
    showToast('📦 Trade accepted!' + (cash > 0 ? ' +$' + cash.toFixed(0) : ''), true);
    firebaseSave();
  } catch(e) { showToast('Error accepting trade', false); }
}

async function declineTrade(tradeId) {
  if (!window._declineTradeOffer && !window._acceptTradeOffer) return;
  try {
    if (window._declineTradeOffer) {
      await window._declineTradeOffer(tradeId);
    } else {
      showToast('Decline function unavailable', false);
      return;
    }
    loadIncomingTrades();
    showToast('Trade declined — items returned to sender', false);
  } catch(e) { showToast('Error declining trade', false); }
}

function renderTradeHistory() {
  const div = document.getElementById('tradeHistoryList');
  if (!tradeHistory.length) { div.innerHTML = '<div style="color:var(--text2);font-size:12px;text-align:center;padding:20px;">No trade history yet</div>'; return; }
  div.innerHTML = tradeHistory.slice(0, 30).map(t => {
    const isSent = t.type === 'sent';
    return '<div style="display:flex;align-items:center;gap:8px;padding:8px;background:var(--bg);border:1px solid var(--border);border-radius:8px;">'
      + '<span style="font-size:16px;">' + (isSent ? '📤' : '📥') + '</span>'
      + '<span style="font-size:16px;">' + (t.itemIcon || '📦') + '</span>'
      + '<div style="flex:1;min-width:0;"><div style="font-size:12px;font-weight:600;">' + escapeHtml(t.itemName) + (t.cash > 0 ? ' + $' + t.cash.toFixed(0) : '') + '</div>'
      + '<div style="font-size:10px;color:var(--text2);">' + (isSent ? 'Sent to ' + escapeHtml(t.to || '?') : 'Received') + ' · ' + new Date(t.ts).toLocaleDateString() + '</div></div>'
      + '<span style="font-size:10px;color:' + (isSent ? 'var(--red)' : 'var(--green)') + ';font-weight:700;">' + (isSent ? 'SENT' : 'RECEIVED') + '</span></div>';
  }).join('');
}

// ============ STORE / MARKETPLACE ============
let storeListType = 'fixed';

function switchStoreTab(tab, btn) {
  document.querySelectorAll('#storePanel .inv-tab').forEach(b => b.classList.remove('active'));
  if (btn) btn.classList.add('active');
  ['Browse', 'List', 'My', 'Sales'].forEach(v => {
    const el = document.getElementById('store' + v + 'View');
    if (el) el.style.display = 'none';
  });
  const target = document.getElementById('store' + tab.charAt(0).toUpperCase() + tab.slice(1) + 'View');
  if (target) target.style.display = 'block';
  if (tab === 'browse') loadStoreListings();
  if (tab === 'list') storePopulateListSelect();
  if (tab === 'my') loadMyListings();
  if (tab === 'sales') loadStoreSales();
}

function storeSetType(type) {
  storeListType = type;
  document.getElementById('storeTypeFixed').className = 'inv-tab' + (type === 'fixed' ? ' active' : '');
  document.getElementById('storeTypeAuction').className = 'inv-tab' + (type === 'auction' ? ' active' : '');
  document.getElementById('storeFixedFields').style.display = type === 'fixed' ? 'block' : 'none';
  document.getElementById('storeAuctionFields').style.display = type === 'auction' ? 'block' : 'none';
}

function storePopulateListSelect() {
  const sel = document.getElementById('storeListItemSelect');
  if (!sel) return;
  sel.innerHTML = '<option value="">Select an item...</option>';
  inventory.forEach(item => {
    const cat = ITEM_CATALOG ? ITEM_CATALOG[item.itemId] : null;
    const name = cat ? (cat.icon + ' ' + cat.name) : item.itemId;
    const val = typeof getItemMarketValue === 'function' ? getItemMarketValue(item.itemId) : 0;
    sel.innerHTML += '<option value="' + item.id + '">' + name + ' ($' + val.toFixed(0) + ')</option>';
  });
}

function storeUpdateListPreview() {
  const sel = document.getElementById('storeListItemSelect');
  const preview = document.getElementById('storeListItemPreview');
  const mRef = document.getElementById('storeMarketRef');
  const invId = parseInt(sel.value);
  if (!invId) { preview.innerHTML = '<div style="color:var(--text2);font-size:12px;">Select an item from your inventory</div>'; if (mRef) mRef.textContent = 'Market value: —'; return; }
  const item = inventory.find(x => x.id === invId);
  if (!item) return;
  const cat = ITEM_CATALOG[item.itemId];
  if (!cat) return;
  const val = typeof getItemMarketValue === 'function' ? getItemMarketValue(item.itemId) : cat.baseValue;
  const rar = RARITY[cat.rarity];
  preview.innerHTML = '<div style="font-size:40px;">' + cat.icon + '</div><div style="font-weight:700;font-size:14px;color:' + rar.color + ';">' + cat.name + '</div><div style="font-size:10px;color:' + rar.color + ';">' + rar.label + '</div><div style="font-family:Orbitron;font-size:14px;color:var(--gold);margin-top:4px;">$' + val.toFixed(0) + '</div>';
  if (mRef) mRef.textContent = 'Market value: $' + val.toFixed(0);
  document.getElementById('storeAskPrice').value = Math.round(val);
  document.getElementById('storeStartBid').value = Math.round(val * 0.7);
}

async function storeListItem() {
  const st = document.getElementById('storeListStatus');
  const invId = parseInt(document.getElementById('storeListItemSelect').value);
  if (!invId) { st.textContent = '⚠ Select an item'; st.style.color = 'var(--red)'; return; }
  const item = inventory.find(x => x.id === invId);
  if (!item) { st.textContent = '⚠ Item not found'; st.style.color = 'var(--red)'; return; }
  if (!window._storeListItem) { st.textContent = '⚠ Not logged in'; st.style.color = 'var(--red)'; return; }
  const cat = ITEM_CATALOG[item.itemId];
  const price = storeListType === 'fixed' ? parseFloat(document.getElementById('storeAskPrice').value) : parseFloat(document.getElementById('storeStartBid').value);
  if (!price || price < 1) { st.textContent = '⚠ Enter a valid price'; st.style.color = 'var(--red)'; return; }
  st.textContent = '⏳ Listing...';
  try {
    const duration = storeListType === 'auction' ? parseInt(document.getElementById('storeAuctionDuration').value) : 0;
    const res = await window._storeListItem({
      itemId: item.itemId,
      itemName: cat ? cat.name : item.itemId,
      rarity: cat ? cat.rarity : 'consumer',
      type: storeListType,
      price: price,
      duration: duration
    });
    if (res.error) throw new Error(res.error);
    removeFromInventory(invId);
    renderInventory(); storePopulateListSelect();
    st.textContent = '✅ Listed on store!';
    st.style.color = 'var(--green)';
    showToast('🏪 Item listed on store!', true);
    firebaseSave();
  } catch(e) { st.textContent = '❌ ' + (e.message || 'Failed'); st.style.color = 'var(--red)'; }
}

async function loadStoreListings() {
  const grid = document.getElementById('storeListingsGrid');
  if (!window._storeGetListings) { grid.innerHTML = '<div style="grid-column:1/-1;color:var(--text2);font-size:12px;text-align:center;padding:30px;">Login to browse</div>'; return; }
  grid.innerHTML = '<div style="grid-column:1/-1;color:var(--text2);font-size:12px;text-align:center;padding:30px;">Loading...</div>';
  try {
    let listings = await window._storeGetListings();
    // Filter
    const rarFilter = document.getElementById('storeFilterRarity').value;
    if (rarFilter !== 'all') listings = listings.filter(l => l.rarity === rarFilter);
    // Sort
    const sort = document.getElementById('storeSortBy').value;
    if (sort === 'newest') listings.sort((a, b) => b.listedAt - a.listedAt);
    else if (sort === 'priceAsc') listings.sort((a, b) => (a.type === 'auction' ? a.currentBid : a.price) - (b.type === 'auction' ? b.currentBid : b.price));
    else if (sort === 'priceDesc') listings.sort((a, b) => (b.type === 'auction' ? b.currentBid : b.price) - (a.type === 'auction' ? a.currentBid : a.price));
    else if (sort === 'ending') listings = listings.filter(l => l.type === 'auction').sort((a, b) => a.endsAt - b.endsAt);
    if (listings.length === 0) { grid.innerHTML = '<div style="grid-column:1/-1;text-align:center;padding:40px;"><div style="font-size:48px;margin-bottom:12px;">🏪</div><div style="font-size:14px;font-weight:700;color:var(--text);margin-bottom:6px;">Marketplace is Empty</div><div style="font-size:12px;color:var(--text2);margin-bottom:16px;">No items listed yet. Be the first to sell something!</div><button onclick="switchStoreTab(\'list\',document.getElementById(\'storeListTab\'))" style="padding:10px 20px;background:linear-gradient(135deg,#00cc66,#009944);border:none;border-radius:8px;color:#fff;cursor:pointer;font-family:Orbitron;font-size:12px;font-weight:700;">📦 List an Item</button></div>'; return; }
    grid.innerHTML = listings.map(l => {
      const cat = ITEM_CATALOG[l.itemId];
      const rar = cat ? RARITY[cat.rarity] : null;
      const icon = cat ? cat.icon : '📦';
      const isAuction = l.type === 'auction';
      const displayPrice = isAuction ? l.currentBid : l.price;
      const timeLeft = isAuction ? Math.max(0, l.endsAt - Date.now()) : 0;
      const timeStr = isAuction ? (timeLeft > 0 ? Math.floor(timeLeft / 60000) + 'm left' : 'ENDED') : '';
      const ended = isAuction && timeLeft <= 0;
      return '<div style="background:var(--bg);border:1px solid ' + (rar ? rar.color : 'var(--border)') + ';border-radius:10px;padding:12px;display:flex;flex-direction:column;align-items:center;gap:6px;position:relative;">'
        + (isAuction ? '<div style="position:absolute;top:6px;right:6px;font-size:9px;padding:2px 6px;background:rgba(136,71,255,.25);border:1px solid rgba(136,71,255,.5);border-radius:4px;color:#8847ff;">🔨 AUCTION</div>' : '')
        + '<div style="font-size:32px;">' + icon + '</div>'
        + '<div style="font-weight:700;font-size:12px;color:' + (rar ? rar.color : 'var(--text)') + ';text-align:center;">' + escapeHtml(l.itemName || l.itemId) + '</div>'
        + (rar ? '<div style="font-size:9px;color:' + rar.color + ';">' + rar.label + '</div>' : '')
        + '<div style="font-family:Orbitron;font-size:14px;color:var(--gold);">$' + formatBalance(displayPrice) + '</div>'
        + '<div style="font-size:10px;color:var(--text2);">by ' + escapeHtml(l.seller) + '</div>'
        + (isAuction && l.highBidder ? '<div style="font-size:9px;color:var(--neon);">High bid: ' + l.highBidder + '</div>' : '')
        + (timeStr ? '<div style="font-size:9px;color:' + (ended ? 'var(--red)' : 'var(--green)') + ';">' + timeStr + '</div>' : '')
        + '<div style="width:100%;margin-top:4px;">'
        + (isAuction && !ended
          ? '<div style="display:flex;gap:4px;"><input type="number" id="bid_' + l.id + '" placeholder="Bid..." min="' + (displayPrice + 1) + '" style="flex:1;padding:6px;background:var(--surface);border:1px solid var(--border);border-radius:4px;color:var(--gold);font-size:11px;font-family:Orbitron;"><button onclick="storeBid(\'' + l.id + '\')" style="padding:6px 10px;background:linear-gradient(135deg,#8847ff,#6b2fd9);border:none;border-radius:4px;color:#fff;cursor:pointer;font-size:10px;font-weight:700;">BID</button></div>'
          : (isAuction && ended
            ? '<button onclick="storeClaim(\'' + l.id + '\')" style="width:100%;padding:8px;background:linear-gradient(135deg,#ffd700,#ff9900);border:none;border-radius:6px;color:#000;cursor:pointer;font-size:11px;font-weight:700;">CLAIM</button>'
            : '<button onclick="storeBuy(\'' + l.id + '\','+l.price+')" style="width:100%;padding:8px;background:linear-gradient(135deg,#00cc66,#009944);border:none;border-radius:6px;color:#fff;cursor:pointer;font-size:11px;font-weight:700;font-family:Orbitron;">BUY NOW</button>'))
        + '</div></div>';
    }).join('');
  } catch(e) {
    console.error('Store load error:', e);
    const isPermErr = (e.message || '').toLowerCase().includes('permission');
    grid.innerHTML = '<div style="grid-column:1/-1;text-align:center;padding:30px;">'
      + '<div style="font-size:36px;margin-bottom:8px;">' + (isPermErr ? '🔒' : '⚠️') + '</div>'
      + '<div style="color:var(--red);font-size:14px;font-weight:700;margin-bottom:8px;">' + (isPermErr ? 'Database Rules Need Updating' : 'Error Loading Marketplace') + '</div>'
      + '<div style="color:var(--text2);font-size:11px;margin-bottom:12px;">' + (e.message || 'Unknown error') + '</div>'
      + (isPermErr ? '<div style="text-align:left;background:var(--bg);border:1px solid var(--border);border-radius:8px;padding:12px;margin:0 auto;max-width:400px;margin-bottom:12px;">'
        + '<div style="font-size:11px;font-weight:700;color:var(--gold);margin-bottom:6px;">Go to Firebase Console → Realtime Database → Rules</div>'
        + '<div style="font-size:11px;color:var(--text2);margin-bottom:6px;">Set your rules to:</div>'
        + '<pre style="background:#111;border:1px solid #333;border-radius:4px;padding:8px;color:#00e676;font-size:10px;overflow-x:auto;white-space:pre;">{\n  "rules": {\n    "casino": {\n      ".read": true,\n      ".write": "auth != null"\n    }\n  }\n}</pre>'
        + '<div style="font-size:10px;color:var(--text2);margin-top:4px;">This allows anyone to read game data, but only logged-in users can write.</div></div>' : '')
      + '<button onclick="loadStoreListings()" style="padding:8px 16px;background:var(--surface2);border:1px solid var(--border);border-radius:6px;color:var(--neon);cursor:pointer;font-size:11px;font-family:Orbitron;">🔄 Retry</button>'
      + '</div>';
  }
}
function renderStoreListings() { loadStoreListings(); }

async function storeBuy(listingId, price) {
  if (!confirm('Buy this item for $' + formatBalance(price) + '?')) return;
  if(price > balance){ showToast('Not enough balance!', false); return; }
  try {
    const res = await window._storeBuyItem(listingId);
    if (res.error) { showToast(res.error, false); return; }
    const actualPrice = res.item.price || price;
    balance -= actualPrice; updateBalDisplay();
    addToInventory(res.item.itemId);
    showToast('🛒 Purchased ' + (res.item.itemName || 'item') + '!', true);
    loadStoreListings(); renderInventory(); firebaseSave();
  } catch(e) { showToast('Purchase failed', false); }
}

async function storeBid(listingId) {
  const bidInput = document.getElementById('bid_' + listingId);
  const amount = parseFloat(bidInput ? bidInput.value : 0);
  if (!amount || amount < 1) { showToast('Enter a valid bid', false); return; }
  if (amount > balance) { showToast('Not enough balance!', false); return; }
  try {
    const res = await window._storePlaceBid(listingId, amount);
    if (res.error) { showToast(res.error, false); return; }
    balance -= amount; updateBalDisplay();
    // Refund old bid if it was us (shouldn't happen but safety)
    if (res.oldBid > 0 && res.oldBidderUid === (window._currentPlayerId || '')) {
      balance += res.oldBid; updateBalDisplay();
    }
    showToast('🔨 Bid placed: $' + amount.toLocaleString(), true);
    loadStoreListings(); firebaseSave();
  } catch(e) { showToast('Bid failed', false); }
}

async function storeClaim(listingId) {
  try {
    const res = await window._storeClaimAuction(listingId);
    if (res.error) { showToast(res.error, false); return; }
    if (res.noBids) {
      addToInventory(res.item.itemId);
      showToast('No bids — item returned to inventory', true);
    } else {
      // Credits are handled via pendingRefunds system for both buyer and seller
      // Just show appropriate message
      if (res.item.sellerUid === (window._currentPlayerId || '')) {
        showToast('💰 Auction sold for $' + res.item.currentBid.toLocaleString() + '! Payment pending.', true);
      } else {
        showToast('🎉 Won auction: ' + (res.item.itemName || 'item') + '! Item pending.', true);
      }
      // Trigger refund check immediately
      checkPendingRefunds();
    }
    loadStoreListings(); renderInventory(); firebaseSave();
  } catch(e) { showToast('Claim failed', false); }
}

async function loadMyListings() {
  const div = document.getElementById('storeMyListings');
  if (!window._storeGetListings) { div.innerHTML = '<div style="color:var(--text2);font-size:12px;text-align:center;padding:20px;">Login first</div>'; return; }
  try {
    const all = await window._storeGetListings();
    const mine = all.filter(l => l.sellerUid === (window._currentPlayerId || ''));
    if (mine.length === 0) { div.innerHTML = '<div style="color:var(--text2);font-size:12px;text-align:center;padding:20px;">No active listings</div>'; return; }
    div.innerHTML = mine.map(l => {
      const cat = ITEM_CATALOG[l.itemId];
      const rar = cat ? RARITY[cat.rarity] : null;
      const isAuction = l.type === 'auction';
      const ended = isAuction && Date.now() > l.endsAt;
      return '<div style="background:var(--bg);border:1px solid ' + (rar ? rar.color : 'var(--border)') + ';border-radius:10px;padding:12px;display:flex;align-items:center;gap:10px;">'
        + '<div style="font-size:28px;">' + (cat ? cat.icon : '📦') + '</div>'
        + '<div style="flex:1;min-width:0;"><div style="font-weight:700;font-size:13px;color:' + (rar ? rar.color : 'var(--text)') + ';">' + escapeHtml(l.itemName || l.itemId) + '</div>'
        + '<div style="font-size:11px;color:var(--text2);">' + (isAuction ? '🔨 Auction' : '💰 Fixed') + ' — $' + (isAuction ? l.currentBid : l.price) + '</div>'
        + (isAuction && l.highBidder ? '<div style="font-size:10px;color:var(--neon);">High bid: ' + l.highBidder + '</div>' : '')
        + (ended ? '<div style="font-size:10px;color:var(--gold);">Auction ended</div>' : '') + '</div>'
        + (ended && isAuction
          ? '<button onclick="storeClaim(\'' + l.id + '\')" style="padding:6px 14px;background:linear-gradient(135deg,#ffd700,#ff9900);border:none;border-radius:6px;color:#000;cursor:pointer;font-size:11px;font-weight:700;">CLAIM</button>'
          : '<button onclick="storeCancelListing(\'' + l.id + '\')" style="padding:6px 14px;background:transparent;border:1px solid var(--red);border-radius:6px;color:var(--red);cursor:pointer;font-size:10px;">CANCEL</button>')
        + '</div>';
    }).join('');
  } catch(e) { div.innerHTML = '<div style="color:var(--red);font-size:12px;text-align:center;padding:20px;">Error</div>'; }
}

async function storeCancelListing(listingId) {
  try {
    const res = await window._storeCancelListing(listingId);
    if (res.error) { showToast(res.error, false); return; }
    addToInventory(res.item.itemId);
    showToast('Listing cancelled — item returned', true);
    loadMyListings(); renderInventory(); firebaseSave();
  } catch(e) { showToast('Cancel failed', false); }
}

async function loadStoreSales() {
  const div = document.getElementById('storeSalesLog');
  if (!window._storeGetSales) { div.innerHTML = '<div style="color:var(--text2);font-size:12px;text-align:center;padding:20px;">Login first</div>'; return; }
  try {
    const sales = await window._storeGetSales();
    if (sales.length === 0) { div.innerHTML = '<div style="color:var(--text2);font-size:12px;text-align:center;padding:20px;">No sales yet</div>'; return; }
    div.innerHTML = sales.map(s => {
      const cat = ITEM_CATALOG[s.itemId];
      const rar = cat ? RARITY[cat.rarity] : null;
      return '<div style="display:flex;align-items:center;gap:8px;padding:8px;background:var(--bg);border:1px solid ' + (rar ? rar.color : 'var(--border)') + ';border-radius:8px;">'
        + '<span style="font-size:16px;">' + (cat ? cat.icon : '📦') + '</span>'
        + '<div style="flex:1;min-width:0;"><div style="font-size:12px;font-weight:600;color:' + (rar ? rar.color : 'var(--text)') +';">' + (s.itemName || s.itemId) + '</div>'
        + '<div style="font-size:10px;color:var(--text2);">' + s.seller + ' → ' + s.buyer + (s.auction ? ' (auction)' : '') + ' · ' + new Date(s.ts).toLocaleDateString() + '</div></div>'
        + '<div style="font-family:Orbitron;font-size:12px;color:var(--gold);">$' + formatBalance(s.price) + '</div></div>';
    }).join('');
  } catch(e) { div.innerHTML = '<div style="color:var(--red);font-size:12px;text-align:center;padding:20px;">Error</div>'; }
}

// ============ FRIENDS SYSTEM ============
let _dmUnsub = null;
let _dmPartnerUid = '';
let _dmPartnerName = '';

function showFriendsPanel() {
  playClickSound();
  document.getElementById('friendsOverlay').style.display = 'block';
  loadFriendsList();
  loadFriendRequests();
  // Set online
  if (window._setOnlineStatus) window._setOnlineStatus(true);
}
function hideFriendsPanel() {
  document.getElementById('friendsOverlay').style.display = 'none';
  if (_dmUnsub) { _dmUnsub(); _dmUnsub = null; }
}

function switchFriendsTab(tab, btn) {
  document.querySelectorAll('#friendsOverlay .inv-tab').forEach(b => b.classList.remove('active'));
  if (btn) btn.classList.add('active');
  ['Friends','Requests','Add','Blocked','Dm','Privacy'].forEach(v => {
    const el = document.getElementById('frView' + v);
    if (el) el.style.display = 'none';
  });
  const target = document.getElementById('frView' + tab.charAt(0).toUpperCase() + tab.slice(1));
  if (target) target.style.display = 'block';
  if (tab === 'friends') loadFriendsList();
  if (tab === 'requests') loadFriendRequests();
  if (tab === 'blocked') loadBlockedList();
  if (tab === 'dm') loadDMContacts();
  if (tab === 'privacy') loadPrivacySettings();
}

async function loadFriendsList() {
  const div = document.getElementById('frFriendsList');
  const countEl = document.getElementById('frFriendCount');
  if (!window._loadFriendsList) { div.innerHTML = '<div style="color:var(--text2);font-size:12px;text-align:center;padding:20px;">Login to see friends</div>'; return; }
  try {
    const friends = await window._loadFriendsList();
    if (countEl) countEl.textContent = '(' + friends.length + ')';
    if (friends.length === 0) { div.innerHTML = '<div style="color:var(--text2);font-size:12px;text-align:center;padding:20px;">No friends yet — add some!</div>'; return; }
    // Get presence
    const presences = await window._getPresenceBatch(friends.map(f => f.uid));
    div.innerHTML = friends.map(f => {
      const p = presences[f.uid] || { online: false, lastSeen: 0 };
      const online = p.online && (Date.now() - (p.lastSeen || 0) < 120000);
      const statusDot = '<span style="display:inline-block;width:8px;height:8px;border-radius:50%;background:' + (online ? '#00e676' : '#555') + ';margin-right:6px;"></span>';
      const lastSeen = !online && p.lastSeen ? 'Last seen ' + timeAgo(p.lastSeen) : (online ? 'Online now' : 'Offline');
      return '<div style="background:var(--bg);border:1px solid ' + (online ? 'rgba(0,230,118,.3)' : 'var(--border)') + ';border-radius:10px;padding:10px 14px;display:flex;align-items:center;gap:10px;">'
        + '<div style="font-size:24px;">👤</div>'
        + '<div style="flex:1;min-width:0;"><div style="font-weight:700;font-size:13px;color:var(--text);">' + statusDot + escapeHtml(f.username) + '</div>'
        + '<div style="font-size:10px;color:' + (online ? 'var(--green)' : 'var(--text2)') + ';">' + lastSeen + '</div></div>'
        + '<div style="display:flex;gap:4px;">'
        + '<button onclick="dmOpenChat(\'' + f.uid + '\',\'' + f.username + '\')" style="padding:5px 10px;background:var(--surface2);border:1px solid var(--border);border-radius:6px;color:var(--neon);cursor:pointer;font-size:10px;" title="Message">💬</button>'
        + '<button onclick="friendGetMutuals(\'' + f.uid + '\',\'' + f.username + '\')" style="padding:5px 10px;background:var(--surface2);border:1px solid var(--border);border-radius:6px;color:var(--text);cursor:pointer;font-size:10px;" title="Mutual friends">👥</button>'
        + '<button onclick="friendRemove(\'' + f.uid + '\',\'' + f.username + '\')" style="padding:5px 10px;background:transparent;border:1px solid var(--red);border-radius:6px;color:var(--red);cursor:pointer;font-size:10px;" title="Remove">✕</button>'
        + '</div></div>';
    }).join('');
  } catch(e) { div.innerHTML = '<div style="color:var(--red);font-size:12px;text-align:center;padding:20px;">Error loading friends</div>'; }
}

function timeAgo(ts) {
  const diff = Date.now() - ts;
  if (diff < 60000) return 'just now';
  if (diff < 3600000) return Math.floor(diff / 60000) + 'm ago';
  if (diff < 86400000) return Math.floor(diff / 3600000) + 'h ago';
  return Math.floor(diff / 86400000) + 'd ago';
}

async function loadFriendRequests() {
  const div = document.getElementById('frRequestsList');
  const badge = document.getElementById('friendReqBadge');
  const countEl = document.getElementById('frReqCount');
  if (!window._loadFriendRequests) { div.innerHTML = '<div style="color:var(--text2);font-size:12px;text-align:center;padding:20px;">Login first</div>'; return; }
  try {
    const reqs = await window._loadFriendRequests();
    if (badge) { if (reqs.length > 0) { badge.style.display = 'inline'; badge.textContent = reqs.length; } else badge.style.display = 'none'; }
    if (countEl) { if (reqs.length > 0) { countEl.style.display = 'inline'; countEl.textContent = reqs.length; } else countEl.style.display = 'none'; }
    if (reqs.length === 0) { div.innerHTML = '<div style="color:var(--text2);font-size:12px;text-align:center;padding:20px;">No pending requests</div>'; return; }
    div.innerHTML = reqs.map(r => {
      return '<div style="background:var(--bg);border:1px solid rgba(0,230,118,.3);border-radius:10px;padding:10px 14px;display:flex;align-items:center;gap:10px;">'
        + '<div style="font-size:24px;">📩</div>'
        + '<div style="flex:1;"><div style="font-weight:700;font-size:13px;color:var(--neon);">' + escapeHtml(r.from) + '</div>'
        + '<div style="font-size:10px;color:var(--text2);">' + new Date(r.ts).toLocaleString() + '</div></div>'
        + '<button onclick="friendAcceptReq(\'' + r.uid + '\',\'' + r.from + '\')" style="padding:6px 14px;background:linear-gradient(135deg,#00cc66,#009944);border:none;border-radius:6px;color:#fff;cursor:pointer;font-size:11px;font-weight:700;">ACCEPT</button>'
        + '<button onclick="friendDeclineReq(\'' + r.uid + '\')" style="padding:5px 10px;background:transparent;border:1px solid var(--red);border-radius:6px;color:var(--red);cursor:pointer;font-size:10px;">✕</button>'
        + '</div>';
    }).join('');
  } catch(e) { div.innerHTML = '<div style="color:var(--red);font-size:12px;text-align:center;padding:20px;">Error</div>'; }
}

async function friendAcceptReq(fromUid, fromName) {
  await window._acceptFriendRequest(fromUid, fromName);
  showToast('👥 Now friends with ' + fromName + '!', true);
  loadFriendRequests(); loadFriendsList();
}
async function friendDeclineReq(fromUid) {
  await window._declineFriendRequest(fromUid);
  showToast('Request declined');
  loadFriendRequests();
}

async function friendSendRequest() {
  const inp = document.getElementById('frAddInput');
  const st = document.getElementById('frAddStatus');
  const u = inp.value.trim().toLowerCase();
  if (!u) { st.textContent = 'Enter a username'; st.style.color = 'var(--red)'; return; }
  if (!window._sendFriendRequest) { st.textContent = 'Login first'; st.style.color = 'var(--red)'; return; }
  st.textContent = '⏳ Sending...';
  try {
    const res = await window._sendFriendRequest(u);
    if (res.error) { st.textContent = '❌ ' + res.error; st.style.color = 'var(--red)'; return; }
    st.textContent = '✅ Request sent to ' + u + '!';
    st.style.color = 'var(--green)';
    inp.value = '';
  } catch(e) { st.textContent = '❌ Error'; st.style.color = 'var(--red)'; }
}

async function friendBlockPlayer() {
  const inp = document.getElementById('frBlockInput');
  const st = document.getElementById('frBlockStatus');
  const u = inp.value.trim().toLowerCase();
  if (!u) { st.textContent = 'Enter a username'; st.style.color = 'var(--red)'; return; }
  if (!window._blockPlayer) { st.textContent = 'Login first'; st.style.color = 'var(--red)'; return; }
  if (!confirm('Block ' + u + '? This will also remove them as a friend.')) return;
  st.textContent = '⏳ Blocking...';
  try {
    const res = await window._blockPlayer(u);
    if (res.error) { st.textContent = '❌ ' + res.error; st.style.color = 'var(--red)'; return; }
    st.textContent = '✅ Blocked ' + u;
    st.style.color = 'var(--green)';
    inp.value = '';
    loadFriendsList();
  } catch(e) { st.textContent = '❌ Error'; st.style.color = 'var(--red)'; }
}

async function friendRemove(uid, name) {
  if (!confirm('Remove ' + name + ' from friends?')) return;
  await window._removeFriend(uid);
  showToast('Removed ' + name + ' from friends');
  loadFriendsList();
}

async function friendGetMutuals(uid, name) {
  if (!window._getMutualFriends) return;
  try {
    const mutuals = await window._getMutualFriends(uid);
    if (mutuals.length === 0) { showToast('No mutual friends with ' + name); return; }
    const names = mutuals.map(m => m.username).join(', ');
    showToast('👥 Mutual friends with ' + name + ': ' + names, true);
  } catch(e) { showToast('Error checking mutuals'); }
}

async function loadBlockedList() {
  const div = document.getElementById('frBlockedList');
  if (!window._loadBlockedList) { div.innerHTML = '<div style="color:var(--text2);font-size:12px;text-align:center;padding:20px;">Login first</div>'; return; }
  try {
    const blocked = await window._loadBlockedList();
    if (blocked.length === 0) { div.innerHTML = '<div style="color:var(--text2);font-size:12px;text-align:center;padding:20px;">No blocked players</div>'; return; }
    div.innerHTML = blocked.map(b => {
      return '<div style="background:var(--bg);border:1px solid rgba(255,55,95,.3);border-radius:10px;padding:10px 14px;display:flex;align-items:center;gap:10px;">'
        + '<div style="font-size:20px;">🚫</div>'
        + '<div style="flex:1;"><div style="font-weight:600;font-size:13px;color:var(--text);">' + b.username + '</div>'
        + '<div style="font-size:10px;color:var(--text2);">Blocked ' + new Date(b.ts).toLocaleDateString() + '</div></div>'
        + '<button onclick="friendUnblock(\'' + b.uid + '\',\'' + b.username + '\')" style="padding:5px 12px;background:transparent;border:1px solid var(--green);border-radius:6px;color:var(--green);cursor:pointer;font-size:10px;">Unblock</button>'
        + '</div>';
    }).join('');
  } catch(e) { div.innerHTML = '<div style="color:var(--red);font-size:12px;text-align:center;padding:20px;">Error</div>'; }
}

async function friendUnblock(uid, name) {
  await window._unblockPlayer(uid);
  showToast('Unblocked ' + name, true);
  loadBlockedList();
}

// ===== DIRECT MESSAGES =====
async function loadDMContacts() {
  const list = document.getElementById('dmContactList');
  const chatView = document.getElementById('dmChatView');
  chatView.style.display = 'none';
  list.style.display = 'flex';
  if (!window._loadFriendsList) { list.innerHTML = '<div style="color:var(--text2);font-size:12px;text-align:center;padding:20px;">Login first</div>'; return; }
  try {
    const friends = await window._loadFriendsList();
    if (friends.length === 0) { list.innerHTML = '<div style="color:var(--text2);font-size:12px;text-align:center;padding:20px;">Add friends to message them</div>'; return; }
    const presences = await window._getPresenceBatch(friends.map(f => f.uid));
    list.innerHTML = friends.map(f => {
      const p = presences[f.uid] || {};
      const online = p.online && (Date.now() - (p.lastSeen || 0) < 120000);
      return '<div onclick="dmOpenChat(\'' + f.uid + '\',\'' + f.username + '\')" style="background:var(--bg);border:1px solid var(--border);border-radius:8px;padding:10px 14px;display:flex;align-items:center;gap:10px;cursor:pointer;transition:border-color .2s;" onmouseover="this.style.borderColor=\'var(--neon)\'" onmouseout="this.style.borderColor=\'var(--border)\'">'
        + '<span style="display:inline-block;width:8px;height:8px;border-radius:50%;background:' + (online ? '#00e676' : '#555') + ';"></span>'
        + '<div style="font-weight:600;font-size:13px;color:var(--text);">' + escapeHtml(f.username) + '</div>'
        + '<div style="margin-left:auto;font-size:10px;color:var(--text2);">' + (online ? '🟢 Online' : 'Offline') + '</div>'
        + '<div style="font-size:14px;">💬</div>'
        + '</div>';
    }).join('');
  } catch(e) { list.innerHTML = '<div style="color:var(--red);font-size:12px;text-align:center;padding:20px;">Error</div>'; }
}

function dmOpenChat(uid, name) {
  _dmPartnerUid = uid;
  _dmPartnerName = name;
  // Switch to DM tab first (in case we're on Friends tab)
  const dmTab = document.getElementById('frTabDM');
  if (dmTab) switchFriendsTab('dm', dmTab);
  document.getElementById('dmContactList').style.display = 'none';
  document.getElementById('dmChatView').style.display = 'block';
  document.getElementById('dmChatPartner').textContent = name;
  document.getElementById('dmMessages').innerHTML = '<div style="color:var(--text2);font-size:12px;text-align:center;">Loading...</div>';
  // Check online status
  if (window._getPresence) {
    window._getPresence(uid).then(p => {
      const online = p.online && (Date.now() - (p.lastSeen || 0) < 120000);
      document.getElementById('dmPartnerStatus').innerHTML = '<span style="display:inline-block;width:8px;height:8px;border-radius:50%;background:' + (online ? '#00e676' : '#555') + ';margin-right:4px;"></span>' + (online ? 'Online' : 'Offline');
    });
  }
  // Listen to messages
  if (_dmUnsub) _dmUnsub();
  if (window._listenDirectMessages) {
    _dmUnsub = window._listenDirectMessages(uid, (msgs) => {
      const div = document.getElementById('dmMessages');
      const myId = window._currentPlayerId || '';
      if (msgs.length === 0) { div.innerHTML = '<div style="color:var(--text2);font-size:12px;text-align:center;padding:20px;">No messages yet. Say hi!</div>'; return; }
      div.innerHTML = msgs.slice(-100).map(m => {
        const isMe = m.fromUid === myId;
        return '<div style="display:flex;justify-content:' + (isMe ? 'flex-end' : 'flex-start') + ';">'
          + '<div style="max-width:75%;padding:8px 12px;border-radius:' + (isMe ? '12px 12px 2px 12px' : '12px 12px 12px 2px') + ';background:' + (isMe ? 'linear-gradient(135deg,#00cc66,#009944)' : 'var(--surface2)') + ';color:' + (isMe ? '#fff' : 'var(--text)') + ';font-size:12px;">'
          + '<div>' + escapeHtml(m.text) + '</div>'
          + '<div style="font-size:9px;color:' + (isMe ? 'rgba(255,255,255,.6)' : 'var(--text2)') + ';margin-top:3px;">' + (isMe ? 'You' : escapeHtml(m.from)) + ' · ' + new Date(m.ts).toLocaleTimeString() + '</div>'
          + '</div></div>';
      }).join('');
      div.scrollTop = div.scrollHeight;
    });
  }
  // Enter key
  const inp = document.getElementById('dmInput');
  inp.onkeydown = (e) => { if (e.key === 'Enter') dmSendMessage(); };
  inp.focus();
}

function dmBackToList() {
  if (_dmUnsub) { _dmUnsub(); _dmUnsub = null; }
  document.getElementById('dmChatView').style.display = 'none';
  document.getElementById('dmContactList').style.display = 'flex';
  loadDMContacts();
}

async function dmSendMessage() {
  const inp = document.getElementById('dmInput');
  const text = inp.value.trim();
  if (!text) return;
  if (!window._sendDirectMessage) { showToast('Not logged in', false); return; }
  inp.value = '';
  try {
    const res = await window._sendDirectMessage(_dmPartnerUid, _dmPartnerName, text);
    if (res.error) showToast(res.error, false);
  } catch(e) { showToast('Message failed', false); }
}

// ===== PRIVACY SETTINGS =====
async function loadPrivacySettings() {
  if (!window._loadPrivacySettings) return;
  try {
    const p = await window._loadPrivacySettings();
    document.getElementById('privFriendRequests').value = p.friendRequests || 'everyone';
    document.getElementById('privDirectMessages').value = p.directMessages || 'friends';
    document.getElementById('privOnlineStatus').value = p.onlineStatus || 'everyone';
    document.getElementById('privTradeRequests').value = p.tradeRequests || 'everyone';
  } catch(e) {}
}

async function savePrivacySettings() {
  const st = document.getElementById('privSaveStatus');
  if (!window._savePrivacySettings) { st.textContent = 'Login first'; st.style.color = 'var(--red)'; return; }
  const settings = {
    friendRequests: document.getElementById('privFriendRequests').value,
    directMessages: document.getElementById('privDirectMessages').value,
    onlineStatus: document.getElementById('privOnlineStatus').value,
    tradeRequests: document.getElementById('privTradeRequests').value
  };
  try {
    await window._savePrivacySettings(settings);
    st.textContent = '✅ Settings saved!';
    st.style.color = 'var(--green)';
    showToast('🔒 Privacy settings saved', true);
  } catch(e) { st.textContent = '❌ Error saving'; st.style.color = 'var(--red)'; }
}

// Set online status on page load/unload
window.addEventListener('load', () => { if (window._setOnlineStatus) window._setOnlineStatus(true); });
window.addEventListener('beforeunload', () => { if (window._setOnlineStatus) window._setOnlineStatus(false); });
// Removed redundant 60s presence heartbeat — _chatPresenceInterval handles it

// ============ SLOTS ============
const SYMBOLS=['🍒','🍋','🔔','💎','7️⃣','🍀','⭐','👑'];
const SYMBOL_VALUES={'👑':100,'7️⃣':50,'💎':30,'⭐':20,'🔔':15,'🍀':10,'🍋':6,'🍒':4};
const REEL_COUNT=5;
const SYM_H=93;
const VISIBLE=3;
let slotsSpinning=false;

function slotsJackpotAnimation(winAmount, symbol, bet) {
  // Create a fullscreen jackpot overlay with epic animation
  const overlay = document.createElement('div');
  overlay.id = 'slotsJackpotOverlay';
  overlay.style.cssText = 'position:fixed;inset:0;z-index:99999;background:rgba(0,0,0,0);display:flex;align-items:center;justify-content:center;flex-direction:column;pointer-events:auto;transition:background 0.5s;';
  document.body.appendChild(overlay);
  requestAnimationFrame(() => { overlay.style.background = 'rgba(4,8,20,.95)'; });

  // Sound: epic win chord
  playSound(523, 'sine', 0.5, 0.2); // C
  setTimeout(() => playSound(659, 'sine', 0.5, 0.18), 150); // E
  setTimeout(() => playSound(784, 'sine', 0.5, 0.15), 300); // G
  setTimeout(() => playSound(1047, 'sine', 0.8, 0.2), 500); // C high

  // Phase 1: Giant symbol (0-1.5s)
  const symEl = document.createElement('div');
  symEl.textContent = symbol;
  symEl.style.cssText = 'font-size:20px;opacity:0;transition:all 0.8s cubic-bezier(.2,1,.3,1);transform:scale(0.1);filter:blur(10px);';
  overlay.appendChild(symEl);
  requestAnimationFrame(() => {
    symEl.style.fontSize = '120px';
    symEl.style.opacity = '1';
    symEl.style.transform = 'scale(1)';
    symEl.style.filter = 'blur(0) drop-shadow(0 0 40px rgba(255,215,0,.8))';
  });

  // Phase 2: "JACKPOT!" text (1s)
  setTimeout(() => {
    const txt = document.createElement('div');
    txt.textContent = '★ JACKPOT ★';
    txt.style.cssText = 'font-family:Orbitron;font-size:0px;font-weight:900;background:linear-gradient(135deg,#ffd700,#ff8c00,#ffd700);-webkit-background-clip:text;-webkit-text-fill-color:transparent;text-shadow:none;opacity:0;transition:all 0.6s cubic-bezier(.2,1,.3,1);letter-spacing:6px;';
    overlay.appendChild(txt);
    requestAnimationFrame(() => {
      txt.style.fontSize = '48px';
      txt.style.opacity = '1';
    });
  }, 1000);

  // Phase 3: 1000x multiplier counter (1.5s)
  setTimeout(() => {
    const multEl = document.createElement('div');
    multEl.style.cssText = 'font-family:Orbitron;font-size:36px;font-weight:900;color:#ff4444;margin-top:8px;';
    overlay.appendChild(multEl);
    // Count up from 1x to 1000x
    let count = 1;
    const target = 1000;
    const startT = Date.now();
    const dur = 2000;
    function tick() {
      const elapsed = Date.now() - startT;
      const prog = Math.min(elapsed / dur, 1);
      // Eased progress (ease-out)
      const eased = 1 - Math.pow(1 - prog, 3);
      count = Math.max(1, Math.floor(eased * target));
      multEl.textContent = count + '× YOUR BET';
      if (prog < 1) requestAnimationFrame(tick);
      else {
        multEl.textContent = '1000× YOUR BET';
        multEl.style.color = '#ffd700';
        multEl.style.textShadow = '0 0 20px rgba(255,215,0,.6)';
        // Play final boom sound
        playSound(200, 'sawtooth', 0.4, 0.25);
        setTimeout(() => playSound(150, 'square', 0.3, 0.15), 100);
      }
    }
    tick();
  }, 1500);

  // Phase 4: Win amount (3.5s)
  setTimeout(() => {
    const winEl = document.createElement('div');
    winEl.style.cssText = 'font-family:Orbitron;font-size:42px;font-weight:900;color:var(--green);margin-top:16px;opacity:0;transform:scale(0.5);transition:all 0.5s cubic-bezier(.2,1,.3,1);';
    winEl.textContent = '+$' + winAmount.toLocaleString();
    overlay.appendChild(winEl);
    requestAnimationFrame(() => {
      winEl.style.opacity = '1';
      winEl.style.transform = 'scale(1)';
    });
    // Particles burst
    for (let i = 0; i < 8; i++) {
      setTimeout(() => {
        const x = window.innerWidth * (0.2 + Math.random() * 0.6);
        const y = window.innerHeight * (0.2 + Math.random() * 0.6);
        spawnParticles(x, y, 30);
      }, i * 200);
    }
  }, 3500);

  // Phase 5: Close button (5s)
  setTimeout(() => {
    const btn = document.createElement('button');
    btn.textContent = 'COLLECT WINNINGS';
    btn.style.cssText = 'margin-top:24px;padding:16px 40px;font-family:Orbitron;font-size:16px;font-weight:700;background:linear-gradient(135deg,#ffd700,#ff8c00);border:none;border-radius:12px;color:#000;cursor:pointer;letter-spacing:2px;transition:all .2s;opacity:0;transform:translateY(20px);';
    btn.onmouseenter = () => { btn.style.transform = 'scale(1.05)'; btn.style.boxShadow = '0 0 30px rgba(255,215,0,.5)'; };
    btn.onmouseleave = () => { btn.style.transform = 'scale(1)'; btn.style.boxShadow = 'none'; };
    btn.onclick = () => {
      overlay.style.opacity = '0';
      overlay.style.transition = 'opacity 0.3s';
      setTimeout(() => overlay.remove(), 300);
    };
    overlay.appendChild(btn);
    requestAnimationFrame(() => {
      btn.style.opacity = '1';
      btn.style.transform = 'translateY(0)';
    });
    playWinSound();
    showBigWin(winAmount);
  }, 5000);
}

function initSlots(){
  const container=document.getElementById('reelsContainer');
  for(let r=0;r<REEL_COUNT;r++){
    const win=document.createElement('div');win.className='reel-window';
    const strip=document.createElement('div');strip.className='reel-strip';strip.id='reel'+r;
    for(let i=0;i<60;i++){
      const sym=document.createElement('div');sym.className='reel-symbol';
      sym.textContent=SYMBOLS[Math.floor(Math.random()*SYMBOLS.length)];
      strip.appendChild(sym);
    }
    win.appendChild(strip);container.appendChild(win);
    strip.style.transform='translateY(-'+(28*SYM_H)+'px)';
  }
}

function spinSlots(){
  if(slotsSpinning)return;
  const bet=parseFloat(document.getElementById('slotsBet').value)||10;
  if(bet<=0)return;
  if(!checkMaxBet(bet,'Slots'))return;
  if(bet>balance){showToast('Not enough balance!',false);return;}
  slotsSpinning=true;
  // Shield potion: refund half on loss (applied at bet time, settled after result)
  const slotsShielded = typeof isShieldActive==='function' && isShieldActive();
  balance-=bet;updateBalDisplay();
  document.getElementById('spinBtn').disabled=true;
  playClickSound();

  // Determine results
  const results=[];
  for(let r=0;r<REEL_COUNT;r++) results.push(SYMBOLS[Math.floor(Math.random()*SYMBOLS.length)]);

  for(let r=0;r<REEL_COUNT;r++){
    const strip=document.getElementById('reel'+r);
    const children=strip.children;
    // Randomize all symbols
    for(let i=0;i<children.length;i++){
      children[i].textContent=SYMBOLS[Math.floor(Math.random()*SYMBOLS.length)];
    }
    // Place result at target position (center of view = index 1 of visible 3)
    const targetIdx=42+r*2;
    children[targetIdx].textContent=results[r];

    setTimeout(()=>{
      // Reset to top
      strip.style.transition='none';
      strip.style.transform='translateY(0px)';
      void strip.offsetWidth;
      // Animate to target
      strip.style.transition='transform '+(1.2+r*0.25)+'s cubic-bezier(.15,.72,.12,1)';
      strip.style.transform='translateY(-'+((targetIdx-1)*SYM_H)+'px)';
      playSound(300+r*50,'square',.04,.03);
    },r*120);
  }

  const totalDuration=1200+REEL_COUNT*250+300;
  setTimeout(()=>{
    // Count matches
    const counts={};
    results.forEach(s=>{counts[s]=(counts[s]||0)+1;});
    let maxCount=0,maxSym='';
    for(const[s,c]of Object.entries(counts)){if(c>maxCount){maxCount=c;maxSym=s;}}

    let winAmount=0;
    const isJackpot = maxCount===5;
    if(maxCount>=3){
      const mult=SYMBOL_VALUES[maxSym]||4;
      if(maxCount===3)winAmount=bet*mult;
      else if(maxCount===4)winAmount=bet*mult*5;
      else winAmount=bet*1000; // JACKPOT: 1000x bet for all 5 matching!
      // Apply luck potion bonus
      if(typeof getLuckBonus==='function') winAmount*=getLuckBonus();
      winAmount=Math.round(winAmount*100)/100;
    }

    if(winAmount>0){
      balance+=winAmount;updateBalDisplay();
      if(isJackpot){
        slotsJackpotAnimation(winAmount, maxSym, bet);
      } else {
        showBigWin(winAmount);
        showToast('WIN $'+winAmount.toFixed(2)+'!');
        playWinSound();
        const rect=document.querySelector('.slots-machine').getBoundingClientRect();
        spawnParticles(rect.left+rect.width/2,rect.top+rect.height/2,40+winAmount/10);
      }
    }else{
      // Shield potion: refund half of bet on loss
      if(slotsShielded){ const refund=Math.floor(bet*0.5); balance+=refund; updateBalDisplay(); showToast('🛡️ Shield! -$'+(bet-refund).toFixed(2),false); }
      else{ showToast('-$'+bet.toFixed(2),false); }
      playLoseSound();
    }

    recordGame('slots', bet, winAmount);
    firebaseSave();
    slotsSpinning=false;
    document.getElementById('spinBtn').disabled=false;

    // Reset strips for next spin
    setTimeout(()=>{
      for(let r=0;r<REEL_COUNT;r++){
        const strip=document.getElementById('reel'+r);
        for(let i=0;i<strip.children.length;i++){
          strip.children[i].textContent=SYMBOLS[Math.floor(Math.random()*SYMBOLS.length)];
        }
        strip.style.transition='none';
        strip.style.transform='translateY(-'+(28*SYM_H)+'px)';
      }
    },400);
  },totalDuration);
}

// ============ CRASH ============
let crashRunning=false,crashBetAmount=0,crashCashedOut=false;
let crashMultVal=1,crashPoint=0,crashStartTime=0,crashHistory=[];

function resizeCrashCanvas(){
  const c=document.getElementById('crashCanvas');
  if(!c)return;
  c.width=c.offsetWidth*2;c.height=c.offsetHeight*2;
  if(!crashRunning)drawCrashGraph();
}

function drawCrashGraph(){
  const c=document.getElementById('crashCanvas');if(!c)return;
  const ctx=c.getContext('2d');
  const w=c.width,h=c.height;
  ctx.clearRect(0,0,w,h);

  // Grid lines
  ctx.strokeStyle='rgba(255,255,255,.04)';ctx.lineWidth=1;
  for(let i=1;i<10;i++){
    const y=h*(1-i/10);
    ctx.beginPath();ctx.moveTo(0,y);ctx.lineTo(w,y);ctx.stroke();
  }

  if(crashHistory.length<2)return;

  const maxMult=Math.max(...crashHistory.map(p=>p.m),2);

  // Gradient fill
  ctx.beginPath();
  crashHistory.forEach((p,i)=>{
    const x=(i/(crashHistory.length-1||1))*w;
    const y=h-((p.m-1)/Math.max(maxMult-1,.1))*(h*0.82)-h*0.06;
    if(i===0)ctx.moveTo(x,y);else ctx.lineTo(x,y);
  });
  const lastX=w,lastY=h-((crashHistory[crashHistory.length-1].m-1)/Math.max(maxMult-1,.1))*(h*0.82)-h*0.06;
  ctx.lineTo(lastX,h);ctx.lineTo(0,h);ctx.closePath();
  const grad=ctx.createLinearGradient(0,0,0,h);
  const col=crashRunning&&!crashCashedOut?'0,240,255':(crashCashedOut?'0,255,136':'255,51,85');
  grad.addColorStop(0,'rgba('+col+',.2)');grad.addColorStop(1,'rgba('+col+',0)');
  ctx.fillStyle=grad;ctx.fill();

  // Line
  ctx.beginPath();
  const lineColor=crashRunning&&!crashCashedOut?'#00f0ff':(crashCashedOut?'#00ff88':'#ff3355');
  ctx.strokeStyle=lineColor;ctx.lineWidth=4;ctx.shadowColor=lineColor;ctx.shadowBlur=12;
  crashHistory.forEach((p,i)=>{
    const x=(i/(crashHistory.length-1||1))*w;
    const y=h-((p.m-1)/Math.max(maxMult-1,.1))*(h*0.82)-h*0.06;
    if(i===0)ctx.moveTo(x,y);else ctx.lineTo(x,y);
  });
  ctx.stroke();
  ctx.shadowBlur=0;

  // Dot at end
  if(crashHistory.length>1){
    const lp=crashHistory[crashHistory.length-1];
    const dx=(1)*w;
    const dy=h-((lp.m-1)/Math.max(maxMult-1,.1))*(h*0.82)-h*0.06;
    ctx.beginPath();ctx.arc(dx,dy,6,0,Math.PI*2);ctx.fillStyle=lineColor;ctx.fill();
    ctx.beginPath();ctx.arc(dx,dy,10,0,Math.PI*2);ctx.strokeStyle=lineColor;ctx.lineWidth=2;
    ctx.globalAlpha=.4;ctx.stroke();ctx.globalAlpha=1;
  }
}

function startCrash(){
  if(crashRunning)return;
  // 2-second cooldown between crash games
  if(Date.now() - (window._lastCrashEnd||0) < 2000){showToast('Cooldown! Wait...',false);return;}
  const bet=parseFloat(document.getElementById('crashBet').value)||10;
  if(bet<=0)return;
  if(!checkMaxBet(bet,'Crash'))return;
  if(bet>balance){showToast('Not enough balance!',false);return;}
  crashBetAmount=bet;balance-=bet;updateBalDisplay();
  crashCashedOut=false;crashRunning=true;
  window._crashCashoutReady=false; // prevent instant cashout
  setTimeout(()=>{window._crashCashoutReady=true;},1250); // 1.25s min before cashout
  crashMultVal=1;crashHistory=[{t:0,m:1}];
  // House edge ~8% — clamp random to avoid division by zero
  let rnd = Math.random();
  if (rnd >= 0.99999) rnd = 0.99999; // prevent Infinity
  crashPoint=1+(0.92/(1-rnd))-0.92;
  // Apply luck potion: nudge crash point slightly higher
  if(typeof getLuckBonus==='function'){ const lb=getLuckBonus(); if(lb>1) crashPoint*=lb; }
  if(crashPoint<1.02)crashPoint=1.02;
  if(crashPoint>100)crashPoint=100;
  if(!isFinite(crashPoint))crashPoint=1.02;

  document.getElementById('crashStartBtn').style.display='none';
  document.getElementById('cashoutBtn').style.display='';
  document.getElementById('crashStatus').textContent='Multiplier rising...';
  document.getElementById('crashMultiplier').className='crash-multiplier';

  crashStartTime=performance.now();
  playClickSound();
  animateCrash();
}

function animateCrash(){
  if(!crashRunning)return;
  const elapsed=(performance.now()-crashStartTime)/1000;
  crashMultVal=Math.pow(Math.E,0.06*elapsed*elapsed+0.04*elapsed);
  crashMultVal=Math.round(crashMultVal*100)/100;
  if(crashMultVal<1)crashMultVal=1;
  crashHistory.push({t:elapsed,m:crashMultVal});
  if(crashHistory.length>500)crashHistory.splice(0,crashHistory.length-500);

  document.getElementById('crashMultiplier').textContent=crashMultVal.toFixed(2)+'×';
  drawCrashGraph();

  if(crashMultVal>=crashPoint){
    crashRunning=false;
    window._lastCrashEnd=Date.now();
    document.getElementById('crashMultiplier').textContent=crashPoint.toFixed(2)+'×';
    document.getElementById('crashMultiplier').className='crash-multiplier crashed';
    document.getElementById('crashStatus').textContent='CRASHED at '+crashPoint.toFixed(2)+'×';
    document.getElementById('crashStartBtn').style.display='';
    document.getElementById('cashoutBtn').style.display='none';

    if(!crashCashedOut){
      const crashShielded = typeof isShieldActive==='function' && isShieldActive();
      if(crashShielded){ const refund=Math.floor(crashBetAmount*0.5); balance+=refund; updateBalDisplay(); showToast('🛡️ Shield! -$'+(crashBetAmount-refund).toFixed(2),false); }
      else{ showToast('CRASHED! -$'+crashBetAmount.toFixed(2),false); }
      playLoseSound();
      recordGame('crash', crashBetAmount, 0);
    }
    drawCrashGraph();return;
  }
  requestAnimationFrame(animateCrash);
}

function cashOut(){
  if(!crashRunning||crashCashedOut)return;
  if(!window._crashCashoutReady){showToast('Wait...',false);return;}
  crashCashedOut=true;
  const winnings=crashBetAmount*crashMultVal;
  balance+=winnings;updateBalDisplay();
  crashRunning=false;
  window._lastCrashEnd=Date.now();

  document.getElementById('crashStatus').textContent='Cashed out at '+crashMultVal.toFixed(2)+'× — Won $'+winnings.toFixed(2);
  document.getElementById('crashStartBtn').style.display='';
  document.getElementById('cashoutBtn').style.display='none';

  showBigWin(winnings);
  showToast('WIN $'+winnings.toFixed(2)+'!');
  playWinSound();
  spawnParticles(window.innerWidth/2,window.innerHeight/2,40);
  recordGame('crash', crashBetAmount, winnings);
  if (crashMultVal > (gameStats.crash.biggestMultiplier || 0)) gameStats.crash.biggestMultiplier = crashMultVal;
  drawCrashGraph();
}

// ============ ROULETTE ============
const ROUL_NUMS=[0,32,15,19,4,21,2,25,17,34,6,27,13,36,11,30,8,23,10,5,24,16,33,1,20,14,31,9,22,18,29,7,28,12,35,3,26];
const RED_NUMS=new Set([1,3,5,7,9,12,14,16,18,19,21,23,25,27,30,32,34,36]);
let rouletteSpinning=false,rouletteAngle=0,selectedRoulBet=null,rouletteDrawn=false;

function selectRoulBet(type,btn){
  selectedRoulBet=type;playClickSound();
  document.querySelectorAll('.roul-bet-btn').forEach(b=>b.classList.remove('selected'));
  if(btn)btn.classList.add('selected');
}

function drawRouletteWheel(angle){
  rouletteDrawn=true;
  const c=document.getElementById('rouletteCanvas');const ctx=c.getContext('2d');
  const cx=c.width/2,cy=c.height/2,r=c.width/2-10;
  ctx.clearRect(0,0,c.width,c.height);

  const n=ROUL_NUMS.length;
  const sliceAngle=Math.PI*2/n;

  ROUL_NUMS.forEach((num,i)=>{
    const start=angle+i*sliceAngle;const end=start+sliceAngle;
    ctx.beginPath();ctx.moveTo(cx,cy);ctx.arc(cx,cy,r,start,end);ctx.closePath();
    if(num===0)ctx.fillStyle='#00884a';
    else if(RED_NUMS.has(num))ctx.fillStyle='#cc2233';
    else ctx.fillStyle='#1a1a1a';
    ctx.fill();
    ctx.strokeStyle='rgba(255,255,255,.15)';ctx.lineWidth=1;ctx.stroke();

    // Number
    const ta=start+sliceAngle/2;
    const tx=cx+Math.cos(ta)*(r*0.78);const ty=cy+Math.sin(ta)*(r*0.78);
    ctx.save();ctx.translate(tx,ty);ctx.rotate(ta+Math.PI/2);
    ctx.fillStyle='#fff';ctx.font='bold 11px Inter';ctx.textAlign='center';ctx.textBaseline='middle';
    ctx.fillText(num.toString(),0,0);ctx.restore();
  });

  // Inner ring
  ctx.beginPath();ctx.arc(cx,cy,r*0.15,0,Math.PI*2);
  const cg=ctx.createRadialGradient(cx,cy,0,cx,cy,r*0.15);
  cg.addColorStop(0,'#2a2a5e');cg.addColorStop(1,'#15153a');
  ctx.fillStyle=cg;ctx.fill();
  ctx.strokeStyle='rgba(255,215,0,.5)';ctx.lineWidth=2;ctx.stroke();

  // Outer ring
  ctx.beginPath();ctx.arc(cx,cy,r+3,0,Math.PI*2);
  ctx.strokeStyle='rgba(255,215,0,.25)';ctx.lineWidth=5;ctx.stroke();
  ctx.beginPath();ctx.arc(cx,cy,r-1,0,Math.PI*2);
  ctx.strokeStyle='rgba(255,215,0,.15)';ctx.lineWidth=1;ctx.stroke();
}

function spinRoulette(){
  if(rouletteSpinning)return;
  if(!selectedRoulBet){showToast('Select a bet type first!',false);return;}
  const bet=parseFloat(document.getElementById('roulBetInput').value)||10;
  if(bet<=0)return;
  if(!checkMaxBet(bet,'Roulette'))return;
  if(bet>balance){showToast('Not enough balance!',false);return;}

  rouletteSpinning=true;balance-=bet;updateBalDisplay();
  document.getElementById('roulSpinBtn').disabled=true;
  document.getElementById('rouletteResult').textContent='';
  playClickSound();

  // Select random number THEN verify its actual color
  const n=ROUL_NUMS.length;
  const winIdx=Math.floor(Math.random()*n);
  const winNum=ROUL_NUMS[winIdx];
  // Verify color from RED_NUMS set (prevents any color mismatch)
  const isActuallyRed=RED_NUMS.has(winNum);
  const isActuallyGreen=winNum===0;
  const sliceAngle=Math.PI*2/n;

  // Target: winning slice at top (angle = -PI/2)
  const targetCenter=winIdx*sliceAngle+sliceAngle/2;
  const targetAngle=-Math.PI/2-targetCenter+Math.PI*2*(6+Math.random()*3);
  const startAngle=rouletteAngle;
  const totalRot=targetAngle-startAngle;

  const duration=4500;const st=performance.now();
  let lastTickAngle=startAngle;

  function animWheel(now){
    const elapsed=now-st;const prog=Math.min(elapsed/duration,1);
    const eased=1-Math.pow(1-prog,4);
    const cur=startAngle+totalRot*eased;
    drawRouletteWheel(cur);

    // Tick sound when passing slot boundaries
    const angleDiff=Math.abs(cur-lastTickAngle);
    if(angleDiff>sliceAngle){
      lastTickAngle=cur;
      if(prog<0.85)playSound(400+Math.random()*200,'sine',.02,.025);
    }

    if(prog<1){requestAnimationFrame(animWheel);}
    else{
      rouletteAngle=cur%(Math.PI*2);
      rouletteSpinning=false;
      document.getElementById('roulSpinBtn').disabled=false;

      // Read back which slice the pointer (top, -PI/2) is actually over
      const pointerAngle=((-Math.PI/2-rouletteAngle)%(Math.PI*2)+Math.PI*4)%(Math.PI*2);
      const visualIdx=Math.floor(pointerAngle/sliceAngle)%n;
      const visualNum=ROUL_NUMS[visualIdx];
      // Use the visual number for display (should match winNum, but this guarantees it)
      const fNum=visualNum;
      const fRed=RED_NUMS.has(fNum);
      const fGreen=fNum===0;

      const colorLabel=fGreen?'💚 Green':(fRed?'🔴 Red':'⚫ Black');
      const colorCSS=fGreen?'var(--green)':(fRed?'#ff5555':'#ccc');
      document.getElementById('rouletteResult').innerHTML=
        '<span style="color:'+colorCSS+'">'+fNum+' — '+colorLabel+'</span>';

      let won=false;
      if(selectedRoulBet==='red'&&fRed)won=true;
      if(selectedRoulBet==='black'&&!fRed&&!fGreen)won=true;
      if(selectedRoulBet==='green'&&fGreen)won=true;
      if(selectedRoulBet==='odd'&&fNum>0&&fNum%2===1)won=true;
      if(selectedRoulBet==='even'&&fNum>0&&fNum%2===0)won=true;
      if(selectedRoulBet==='1-18'&&fNum>=1&&fNum<=18)won=true;
      if(selectedRoulBet==='19-36'&&fNum>=19&&fNum<=36)won=true;

      if(won){
        let payout=selectedRoulBet==='green'?bet*36:bet*2;
        // Apply luck potion bonus
        if(typeof getLuckBonus==='function') payout=Math.round(payout*getLuckBonus()*100)/100;
        balance+=payout;updateBalDisplay();
        showBigWin(payout);
        showToast('WIN $'+payout.toFixed(2)+'!');playWinSound();
        const rect=document.getElementById('rouletteCanvas').getBoundingClientRect();
        spawnParticles(rect.left+rect.width/2,rect.top+rect.height/2,40);
        recordGame('roulette', bet, payout);
      }else{
        const roulShielded = typeof isShieldActive==='function' && isShieldActive();
        if(roulShielded){ const refund=Math.floor(bet*0.5); balance+=refund; updateBalDisplay(); showToast('🛡️ Shield! -$'+(bet-refund).toFixed(2),false); }
        else{ showToast('-$'+bet.toFixed(2),false); }
        playLoseSound();
        recordGame('roulette', bet, 0);
      }
    }
  }
  requestAnimationFrame(animWheel);
}

// ============ CASES (CSGO-STYLE) ============
const RARITY={
  consumer:  {label:'Consumer Grade', color:'#b0c3d9',cls:'rarity-consumer',  tier:0},
  industrial:{label:'Industrial Grade',color:'#5e98d9',cls:'rarity-industrial',tier:1},
  milspec:   {label:'Mil-Spec',       color:'#4b69ff',cls:'rarity-milspec',   tier:2},
  restricted:{label:'Restricted',     color:'#8847ff',cls:'rarity-restricted',tier:3},
  classified:{label:'Classified',     color:'#d32ce6',cls:'rarity-classified',tier:4},
  covert:    {label:'Covert',         color:'#eb4b4b',cls:'rarity-covert',    tier:5},
  legendary: {label:'★ Legendary',    color:'#ffd700',cls:'rarity-legendary', tier:6},
  mythic:    {label:'★★ Mythic',      color:'#ff4500',cls:'rarity-legendary', tier:7},
};

// Full item catalog — each item is a unique collectible
const ITEM_CATALOG={
  // Consumer Grade
  rustedCoin:      {id:'rustedCoin',      name:'Rusted Coin',        icon:'🪙', rarity:'consumer',  baseValue:15},
  brokenCompass:   {id:'brokenCompass',   name:'Broken Compass',     icon:'🧭', rarity:'consumer',  baseValue:20},
  driftwood:       {id:'driftwood',       name:'Driftwood Charm',    icon:'🪵', rarity:'consumer',  baseValue:12},
  seaGlass:        {id:'seaGlass',        name:'Sea Glass',          icon:'💠', rarity:'consumer',  baseValue:18},
  coconutShell:    {id:'coconutShell',    name:'Coconut Shell',      icon:'🥥', rarity:'consumer',  baseValue:10},
  // Industrial Grade
  bronzeMedallion: {id:'bronzeMedallion', name:'Bronze Medallion',   icon:'🏅', rarity:'industrial',baseValue:60},
  pearlFragment:   {id:'pearlFragment',   name:'Pearl Fragment',     icon:'⚪', rarity:'industrial',baseValue:80},
  corkedBottle:    {id:'corkedBottle',    name:'Corked Bottle',      icon:'🍾', rarity:'industrial',baseValue:70},
  ancientMap:      {id:'ancientMap',      name:'Ancient Map',        icon:'🗺️', rarity:'industrial', baseValue:90},
  // Mil-Spec Grade
  silverDagger:    {id:'silverDagger',    name:'Silver Dagger',      icon:'🗡️', rarity:'milspec',   baseValue:200},
  crystalOrb:      {id:'crystalOrb',      name:'Crystal Orb',        icon:'🔮', rarity:'milspec',   baseValue:250},
  enchantedRing:   {id:'enchantedRing',   name:'Enchanted Ring',     icon:'💍', rarity:'milspec',   baseValue:300},
  stormLantern:    {id:'stormLantern',    name:'Storm Lantern',      icon:'🏮', rarity:'milspec',   baseValue:220},
  // Restricted
  goldenCompass:   {id:'goldenCompass',   name:'Golden Compass',     icon:'🧭', rarity:'restricted',baseValue:600},
  dragonScale:     {id:'dragonScale',     name:'Dragon Scale',       icon:'🐉', rarity:'restricted',baseValue:750},
  phoenixFeather:  {id:'phoenixFeather',  name:'Phoenix Feather',    icon:'🪶', rarity:'restricted',baseValue:700},
  moonstone:       {id:'moonstone',       name:'Moonstone Gem',      icon:'🌙', rarity:'restricted',baseValue:650},
  // Classified
  voidShard:       {id:'voidShard',       name:'Void Shard',         icon:'♠️', rarity:'classified',baseValue:1500},
  starforgedBlade: {id:'starforgedBlade', name:'Starforged Blade',   icon:'⚔️', rarity:'classified',baseValue:2000},
  abyssalPearl:    {id:'abyssalPearl',    name:'Abyssal Pearl',      icon:'⚫', rarity:'classified',baseValue:1800},
  // Covert
  dragonheart:     {id:'dragonheart',     name:'Dragonheart',        icon:'❤️‍🔥', rarity:'covert', baseValue:5000},
  etherealCrown:   {id:'etherealCrown',   name:'Ethereal Crown',     icon:'👑', rarity:'covert',    baseValue:6000},
  cosmicDust:      {id:'cosmicDust',      name:'Cosmic Dust',        icon:'✨', rarity:'covert',    baseValue:5500},
  // Legendary
  infinityGem:     {id:'infinityGem',     name:'Infinity Gem',       icon:'💎', rarity:'legendary', baseValue:15000},
  islandRelic:     {id:'islandRelic',     name:'Island Relic',       icon:'🏝️', rarity:'legendary', baseValue:25000},
  casinoChip:      {id:'casinoChip',      name:'Casino Royale Chip', icon:'🎰', rarity:'legendary', baseValue:30000},
  // ----- NEW HIGH-VALUE ITEMS -----
  // Mega tier items (for whale cases)
  obsidianCrown:   {id:'obsidianCrown',   name:'Obsidian Crown',     icon:'🖤', rarity:'legendary', baseValue:100000},
  solarFlare:      {id:'solarFlare',      name:'Solar Flare',        icon:'☀️', rarity:'legendary', baseValue:200000},
  voidEngine:      {id:'voidEngine',      name:'Void Engine',        icon:'⚙️', rarity:'legendary', baseValue:500000},
  // Mythic tier (ultra rare, whale bait)
  worldEater:      {id:'worldEater',      name:'World Eater',        icon:'🌍', rarity:'mythic',    baseValue:2000000},
  tidalForce:      {id:'tidalForce',      name:'Tidal Force',        icon:'🌊', rarity:'mythic',    baseValue:5000000},
  cosmicTear:      {id:'cosmicTear',      name:'Cosmic Tear',        icon:'💧', rarity:'mythic',    baseValue:15000000},
  galaxyHeart:     {id:'galaxyHeart',     name:'Galaxy Heart',       icon:'🫀', rarity:'mythic',    baseValue:50000000},
  infinityCascade: {id:'infinityCascade', name:'Infinity Cascade',   icon:'♾️', rarity:'mythic',    baseValue:250000000},
  bigBang:         {id:'bigBang',         name:'Big Bang',           icon:'💥', rarity:'mythic',    baseValue:1000000000},
};

// Case definitions — each references items from ITEM_CATALOG
// RTP target: ~90-95% per case
const CASES = [
  { name:'Starter Crate', icon:'📦', price:50, items:[
    {id:'rustedCoin',w:20},{id:'brokenCompass',w:18},{id:'driftwood',w:18},{id:'seaGlass',w:16},
    {id:'coconutShell',w:18},{id:'bronzeMedallion',w:10},{id:'pearlFragment',w:8},{id:'corkedBottle',w:8},
    {id:'ancientMap',w:6},{id:'silverDagger',w:3},{id:'crystalOrb',w:2},{id:'enchantedRing',w:1}
  ]},
  { name:'Explorer Chest', icon:'🧰', price:200, items:[
    {id:'bronzeMedallion',w:15},{id:'pearlFragment',w:14},{id:'corkedBottle',w:14},{id:'ancientMap',w:12},
    {id:'silverDagger',w:10},{id:'crystalOrb',w:8},{id:'enchantedRing',w:7},{id:'stormLantern',w:7},
    {id:'goldenCompass',w:4},{id:'dragonScale',w:3},{id:'phoenixFeather',w:3},{id:'moonstone',w:3}
  ]},
  { name:'Mystic Vault', icon:'🔮', price:500, items:[
    {id:'silverDagger',w:10},{id:'crystalOrb',w:10},{id:'enchantedRing',w:9},{id:'stormLantern',w:9},
    {id:'goldenCompass',w:8},{id:'dragonScale',w:7},{id:'phoenixFeather',w:7},{id:'moonstone',w:7},
    {id:'voidShard',w:4},{id:'starforgedBlade',w:3},{id:'abyssalPearl',w:3.5},
    {id:'dragonheart',w:1.2},{id:'etherealCrown',w:0.8},{id:'cosmicDust',w:1}
  ]},
  { name:'Legendary Trove', icon:'👑', price:2000, items:[
    {id:'goldenCompass',w:8},{id:'dragonScale',w:8},{id:'phoenixFeather',w:8},{id:'moonstone',w:8},
    {id:'voidShard',w:7},{id:'starforgedBlade',w:6},{id:'abyssalPearl',w:6},
    {id:'dragonheart',w:5},{id:'etherealCrown',w:4},{id:'cosmicDust',w:4.5},
    {id:'infinityGem',w:2},{id:'islandRelic',w:1.2},{id:'casinoChip',w:1}
  ]},
  { name:'Diamond Vault', icon:'💎', price:10000, items:[
    {id:'voidShard',w:10},{id:'starforgedBlade',w:9},{id:'abyssalPearl',w:9},
    {id:'dragonheart',w:8},{id:'etherealCrown',w:7},{id:'cosmicDust',w:7},
    {id:'infinityGem',w:6},{id:'islandRelic',w:4},{id:'casinoChip',w:4},
    {id:'obsidianCrown',w:2.5},{id:'solarFlare',w:1},{id:'voidEngine',w:0.4}
  ]},
  { name:'Whale Chest', icon:'🐋', price:100000, items:[
    {id:'infinityGem',w:10},{id:'islandRelic',w:8},{id:'casinoChip',w:8},
    {id:'obsidianCrown',w:7},{id:'solarFlare',w:5},{id:'voidEngine',w:3},
    {id:'worldEater',w:1.5},{id:'tidalForce',w:0.8},{id:'cosmicTear',w:0.3}
  ]},
  { name:'Cosmic Crate', icon:'🌌', price:1000000, items:[
    {id:'obsidianCrown',w:10},{id:'solarFlare',w:8},{id:'voidEngine',w:6},
    {id:'worldEater',w:5},{id:'tidalForce',w:3},{id:'cosmicTear',w:1.5},
    {id:'galaxyHeart',w:0.5},{id:'infinityCascade',w:0.15}
  ]},
  { name:'Big Bang Box', icon:'💥', price:50000000, items:[
    {id:'voidEngine',w:10},{id:'worldEater',w:8},{id:'tidalForce',w:6},
    {id:'cosmicTear',w:5},{id:'galaxyHeart',w:3},{id:'infinityCascade',w:1.5},
    {id:'bigBang',w:0.5}
  ]}
];

// ============ INVENTORY ============
let inventory = [];
let invIdCounter = Date.now();

function addToInventory(itemId) {
  const cat = ITEM_CATALOG[itemId];
  if (!cat) return;
  invIdCounter++;
  const item = { id: invIdCounter, itemId: itemId, acquiredPrice: getItemMarketValue(itemId), acquiredAt: Date.now() };
  inventory.push(item);
  // Update local demand
  const d = itemDemand[itemId];
  if (d) { d.supply = (d.supply || 0) + 1; d.mult = Math.max(0.3, d.mult - 0.01); }
  // Update global market — item opened/acquired
  if (window._updateGlobalMarketItem) window._updateGlobalMarketItem(itemId, 'opened', getItemMarketValue(itemId));
}

function removeFromInventory(invId) {
  const idx = inventory.findIndex(x => x.id === invId);
  if (idx === -1) return;
  const item = inventory[idx];
  const d = itemDemand[item.itemId];
  if (d) { d.supply = Math.max(0, d.supply - 1); d.mult = Math.min(3, d.mult + 0.015); }
  // Update global market — item sold/removed
  const val = getItemMarketValue(item.itemId);
  if (window._updateGlobalMarketItem) window._updateGlobalMarketItem(item.itemId, 'sold', val);
  inventory.splice(idx, 1);
}

function getInventoryValue() {
  return inventory.reduce((s, x) => s + getItemMarketValue(x.itemId), 0);
}

// ============ MARKET / DEMAND ============
let itemDemand = {};
let globalMarketData = {};

function initDemand() {
  Object.keys(ITEM_CATALOG).forEach(id => {
    if (!itemDemand[id]) itemDemand[id] = { mult: 1, velocity: 0, supply: 0, globalSupply: 0 };
  });
  if (window._initGlobalMarket) window._initGlobalMarket();
}

window._onGlobalMarketUpdate = (data) => {
  globalMarketData = data || {};
  Object.keys(globalMarketData).forEach(id => {
    const gm = globalMarketData[id];
    const d = itemDemand[id];
    if (!d) return;
    d.globalSupply = gm.globalSupply || 0;
    const supplyFactor = Math.max(0.3, 1.5 - d.globalSupply * 0.08);
    d.mult = d.mult * 0.7 + supplyFactor * 0.3;
    d.mult = Math.max(0.3, Math.min(3, d.mult));
    if (gm.lastTradePrice && gm.lastTradeTs && Date.now() - gm.lastTradeTs < 300000) {
      const cat = ITEM_CATALOG[id];
      if (cat && cat.baseValue > 0) {
        const tradeMult = gm.lastTradePrice / cat.baseValue;
        d.mult = d.mult * 0.85 + Math.max(0.3, Math.min(3, tradeMult)) * 0.15;
      }
    }
  });
};

function getItemMarketValue(id) {
  const cat = ITEM_CATALOG[id]; if (!cat) return 0;
  const d = itemDemand[id] || { mult: 1 };
  return Math.round(cat.baseValue * d.mult);
}

function tickDemand() {
  const tick = Math.floor(Date.now() / 5000);
  Object.keys(itemDemand).forEach((id, idx) => {
    const d = itemDemand[id];
    // Deterministic pseudo-random shift per item per tick
    const seed = ((tick * 2654435761) ^ (idx * 340573321)) >>> 0;
    const r = (seed % 1000) / 1000; // 0..1
    const shift = (r - 0.5) * 0.02; // -1% to +1%
    d.velocity = d.velocity * 0.9 + shift * 0.1;
    d.mult += d.velocity;
    // Mean-revert toward 1.0
    d.mult += (1 - d.mult) * 0.005;
    d.mult = Math.max(0.3, Math.min(3, d.mult));
  });
}
setInterval(tickDemand, 5000);

// ============ CASES SYSTEM ============
let caseStreak = 0, caseOpenTotal = 0, caseBestTier = -1, caseBestName = '—';
let caseRecentUnboxes = [];
let selectedCase = 0, caseOpening = false;

function initCases() {
  initDemand();
  const sel = document.getElementById('caseSelector');
  CASES.forEach((c, i) => {
    const card = document.createElement('div');
    card.className = 'case-card' + (i === 0 ? ' selected' : '');
    card.innerHTML = '<div class="case-icon">' + c.icon + '</div><div class="case-name">' + c.name + '</div><div class="case-price">$' + c.price.toLocaleString() + '</div>';
    card.onclick = () => { selectedCase = i; document.querySelectorAll('.case-card').forEach(x => x.classList.remove('selected')); card.classList.add('selected'); playClickSound(); };
    sel.appendChild(card);
  });
}

function pickWeighted(items) {
  const total = items.reduce((s, i) => s + i.w, 0);
  let r = Math.random() * total;
  for (const item of items) { r -= item.w; if (r <= 0) return item; }
  return items[items.length - 1];
}

function hexToRgb(h) {
  if (!h || h[0] !== '#') return '200,200,200';
  const n = parseInt(h.slice(1), 16);
  return ((n >> 16) & 255) + ',' + ((n >> 8) & 255) + ',' + (n & 255);
}

function pickWeightedWithStreak(items) {
  const streakBonus = Math.min(caseStreak * 0.02, 0.2);
  const adjusted = items.map(it => {
    const cat = ITEM_CATALOG[it.id];
    const tier = cat ? RARITY[cat.rarity].tier : 0;
    const boost = 1 + (tier >= 3 ? streakBonus * tier * 0.3 : 0);
    return { ...it, w: it.w * boost };
  });
  return pickWeighted(adjusted);
}

function updateCaseStats(winCat, winRarity) {
  caseOpenTotal++;
  // Reset streak on low-tier items (consumer/industrial = tier 0-1)
  if (winRarity.tier <= 1) { caseStreak = 0; } else { caseStreak++; }
  const countEl = document.getElementById('caseOpenCount');
  if (countEl) countEl.textContent = caseOpenTotal;
  const streakEl = document.getElementById('caseStreak');
  if (streakEl) streakEl.textContent = caseStreak;
  const bonusEl = document.getElementById('caseStreakBonus');
  if (bonusEl) {
    if (caseStreak >= 3) {
      const bonusPct = Math.min(caseStreak * 2, 20);
      bonusEl.textContent = ' +' + bonusPct + '% luck';
    } else {
      bonusEl.textContent = '';
    }
  }
  if (winRarity.tier > caseBestTier) {
    caseBestTier = winRarity.tier;
    caseBestName = winCat.icon + ' ' + winCat.name;
    const bestEl = document.getElementById('caseBestItem');
    if (bestEl) { bestEl.textContent = caseBestName; bestEl.style.color = winRarity.color; }
  }
  addToCaseRecentFeed(winCat, winRarity);
}

function addToCaseRecentFeed(cat, rar) {
  caseRecentUnboxes.unshift({ icon: cat.icon, name: cat.name, color: rar.color });
  if (caseRecentUnboxes.length > 20) caseRecentUnboxes.pop();
  const feed = document.getElementById('caseRecentFeed');
  if (!feed) return;
  const el = document.createElement('div');
  el.className = 'case-recent-item';
  el.style.borderColor = rar.color;
  el.innerHTML = '<span style="font-size:14px;">' + cat.icon + '</span><span style="color:' + rar.color + ';">' + cat.name + '</span>';
  feed.insertBefore(el, feed.firstChild);
  if (feed.children.length > 15) feed.removeChild(feed.lastChild);
}

function openCase() {
  if (caseOpening) return;
  const c = CASES[selectedCase];
  if(c.price>balance){showToast('Not enough balance!',false);return;}
  caseOpening = true; balance -= c.price; updateBalDisplay();
  document.getElementById('openCaseBtn').disabled = true;
  const quickBtn = document.getElementById('quickOpenBtn');
  if (quickBtn) quickBtn.disabled = true;
  document.getElementById('caseWon').textContent = '';
  document.getElementById('caseWonDetail').textContent = '';
  playClickSound();

  const opener = document.getElementById('caseOpener');
  opener.classList.remove('rare-reveal', 'legendary-reveal');
  const flashEl = document.getElementById('caseFlash');
  if (flashEl) flashEl.style.opacity = '0';

  const strip = document.getElementById('caseStrip');
  strip.innerHTML = ''; strip.style.transition = 'none'; strip.style.transform = 'translateX(0)';

  const winRef = caseStreak >= 3 ? pickWeightedWithStreak(c.items) : pickWeighted(c.items);
  const winCat = ITEM_CATALOG[winRef.id];
  const winRarity = RARITY[winCat.rarity];
  const winPos = 35;
  const totalItems = 50;

  for (let i = 0; i < totalItems; i++) {
    let ref;
    if (i === winPos) {
      ref = winRef;
    } else if (Math.abs(i - winPos) <= 2 && winRarity.tier >= 3 && Math.random() < 0.4) {
      const rareItems = c.items.filter(it => { const ct = ITEM_CATALOG[it.id]; return ct && RARITY[ct.rarity].tier >= Math.max(2, winRarity.tier - 1); });
      ref = rareItems.length > 0 ? rareItems[Math.floor(Math.random() * rareItems.length)] : c.items[Math.floor(Math.random() * c.items.length)];
    } else {
      ref = c.items[Math.floor(Math.random() * c.items.length)];
    }
    const cat = ITEM_CATALOG[ref.id];
    const rar = RARITY[cat.rarity];
    const el = document.createElement('div'); el.className = 'case-item';
    if (i === winPos) el.id = 'caseWinnerItem';
    el.style.borderColor = rar.color;
    el.style.background = 'linear-gradient(180deg,rgba(' + hexToRgb(rar.color) + ',.15),transparent)';
    el.innerHTML = '<div class="item-icon">' + cat.icon + '</div><div class="' + rar.cls + '" style="font-size:10px;">' + cat.name + '</div>'
      + '<div class="item-rarity" style="background:' + rar.color + ';"></div>';
    strip.appendChild(el);
  }

  requestAnimationFrame(() => { requestAnimationFrame(() => {
    const openerW = strip.parentElement.offsetWidth;
    const offset = winPos * 120 - openerW / 2 + 60 + (Math.random() * 60 - 30);
    strip.style.transition = 'transform 4s cubic-bezier(.08,.82,.17,1)';
    strip.style.transform = 'translateX(-' + offset + 'px)';
  }); });

  let ticks = 0;
  const tickI = setInterval(() => {
    const slowdown = Math.max(0.3, 1 - ticks / 60);
    playSound(400 + Math.random() * 500, 'sine', 0.02 * slowdown, 0.04 * slowdown);
    ticks++;
    if (ticks > 55) clearInterval(tickI);
  }, 65);

  setTimeout(() => {
    if (winRarity.tier >= 4 && flashEl) {
      flashEl.style.background = winRarity.color;
      flashEl.style.opacity = '0.3';
      setTimeout(() => flashEl.style.opacity = '0', 300);
    }
  }, 3500);

  setTimeout(() => {
    clearInterval(tickI); caseOpening = false;
    document.getElementById('openCaseBtn').disabled = false;
    if (quickBtn) quickBtn.disabled = false;

    const winEl = document.getElementById('caseWinnerItem');
    if (winEl) winEl.classList.add('highlighted');
    if (winRarity.tier >= 6) opener.classList.add('legendary-reveal');
    else if (winRarity.tier >= 3) opener.classList.add('rare-reveal');

    addToInventory(winRef.id);
    const mktVal = getItemMarketValue(winRef.id);
    const profit = mktVal - c.price;
    const isW = profit >= 0;

    document.getElementById('caseWon').innerHTML =
      '<span class="' + winRarity.cls + '" style="text-shadow:0 0 15px ' + winRarity.color + ';">' + winCat.icon + ' ' + winCat.name + '</span>';
    document.getElementById('caseWonDetail').innerHTML =
      '<span style="color:' + winRarity.color + '">' + winRarity.label + '</span> — Market: <span style="color:var(--gold)">$' + mktVal.toLocaleString() + '</span>'
      + ' <span style="color:' + (isW ? 'var(--green)' : 'var(--red)') + '">(' + (isW ? '+' : '') + ('$' + profit.toLocaleString()) + ')</span>'
      + (caseStreak >= 3 ? ' <span style="color:var(--neon);font-size:10px;">🔥 ' + caseStreak + '× streak!</span>' : '');

    if (winRarity.tier >= 6) {
      showToast('👑 LEGENDARY: ' + winCat.name + '!');
      playWinSound();
      setTimeout(() => { playSound(1047, 'sine', .3, .15); }, 300);
      setTimeout(() => { playSound(1319, 'sine', .4, .12); }, 500);
      spawnParticles(window.innerWidth / 2, window.innerHeight / 2, 150);
      setTimeout(() => spawnParticles(window.innerWidth / 2, window.innerHeight / 3, 80), 300);
      setTimeout(() => spawnParticles(window.innerWidth / 2, window.innerHeight * 2 / 3, 80), 600);
    } else if (winRarity.tier >= 5) {
      showToast('🔥 ' + winRarity.label + ': ' + winCat.name + '!'); playWinSound();
      spawnParticles(window.innerWidth / 2, window.innerHeight / 2, 80 + winRarity.tier * 30);
    } else if (winRarity.tier >= 3) {
      showToast(winCat.icon + ' ' + winCat.name + '!'); playWinSound();
      spawnParticles(window.innerWidth / 2, window.innerHeight / 2, 30);
    } else {
      showToast(winCat.name + ' added to inventory', isW);
      if (!isW) playLoseSound(); else playWinSound();
    }

    updateCaseStats(winCat, winRarity);
    recordGame('cases', c.price, mktVal);
  }, 4300);
}

function quickOpenCase() {
  if (caseOpening) return;
  const c = CASES[selectedCase];
  if(c.price>balance){showToast('Not enough balance!',false);return;}
  caseOpening = true;
  balance -= c.price; updateBalDisplay();
  playClickSound();

  const winRef = caseStreak >= 3 ? pickWeightedWithStreak(c.items) : pickWeighted(c.items);
  const winCat = ITEM_CATALOG[winRef.id];
  const winRarity = RARITY[winCat.rarity];

  addToInventory(winRef.id);
  const mktVal = getItemMarketValue(winRef.id);
  const profit = mktVal - c.price;
  const isW = profit >= 0;

  document.getElementById('caseWon').innerHTML =
    '<span class="' + winRarity.cls + '" style="text-shadow:0 0 15px ' + winRarity.color + ';">' + winCat.icon + ' ' + winCat.name + '</span>';
  document.getElementById('caseWonDetail').innerHTML =
    '<span style="color:' + winRarity.color + '">' + winRarity.label + '</span> — Market: <span style="color:var(--gold)">$' + mktVal.toLocaleString() + '</span>'
    + ' <span style="color:' + (isW ? 'var(--green)' : 'var(--red)') + '">(' + (isW ? '+' : '') + ('$' + profit.toLocaleString()) + ')</span>';

  if (winRarity.tier >= 5) {
    showToast('🔥 ' + winRarity.label + ': ' + winCat.name + '!'); playWinSound();
    spawnParticles(window.innerWidth / 2, window.innerHeight / 2, 60);
  } else if (winRarity.tier >= 3) {
    showToast(winCat.icon + ' ' + winCat.name + '!'); playWinSound();
  } else {
    if (isW) playWinSound(); else playLoseSound();
  }

  updateCaseStats(winCat, winRarity);
  recordGame('cases', c.price, mktVal);
  setTimeout(() => { caseOpening = false; }, 50);
}

// ============ INVENTORY ============
function showInventory(){playClickSound();document.getElementById('inventoryOverlay').classList.add('show');renderInventory();}
function hideInventory(){document.getElementById('inventoryOverlay').classList.remove('show');}
let invFilter='all';

function filterInventory(f,btn){
  invFilter=f;
  document.querySelectorAll('.inv-tab').forEach(t=>t.classList.remove('active'));
  if(btn)btn.classList.add('active');
  renderInventory();
}

function renderInventory(){
  const grid=document.getElementById('invGrid');
  grid.innerHTML='';
  const totalVal=getInventoryValue();
  document.getElementById('invTotalValue').textContent=totalVal.toLocaleString();
  document.getElementById('invCount').textContent=inventory.length;

  // Find rarest
  let rarestTier=-1,rarestName='—';
  inventory.forEach(x=>{
    const cat=ITEM_CATALOG[x.itemId];
    if(!cat)return;
    const rarDef=RARITY[cat.rarity];
    if(!rarDef)return;
    const t=rarDef.tier;
    if(t>rarestTier){rarestTier=t;rarestName=cat.icon+' '+cat.name;}
  });
  document.getElementById('invRarest').textContent=rarestName;

  // Market trend
  const trends=Object.values(itemDemand).map(d=>d.velocity);
  const avg=trends.length?trends.reduce((a,b)=>a+b,0)/trends.length:0;
  document.getElementById('invTrend').innerHTML=avg>0.005?'<span style="color:var(--green)">📈 Bullish</span>'
    :avg<-0.005?'<span style="color:var(--red)">📉 Bearish</span>':'<span style="color:var(--text2)">➡️ Stable</span>';

  let filtered=inventory;
  if(invFilter!=='all'){
    filtered=inventory.filter(x=>{const c=ITEM_CATALOG[x.itemId];return c&&c.rarity===invFilter;});
  }

  // Sort by rarity desc then value desc
  filtered.sort((a,b)=>{
    const catA=ITEM_CATALOG[a.itemId], catB=ITEM_CATALOG[b.itemId];
    const ra=catA&&RARITY[catA.rarity]?RARITY[catA.rarity].tier:0;
    const rb=catB&&RARITY[catB.rarity]?RARITY[catB.rarity].tier:0;
    if(rb!==ra)return rb-ra;
    return getItemMarketValue(b.itemId)-getItemMarketValue(a.itemId);
  });

  if(filtered.length===0){
    grid.innerHTML='<div class="inv-empty">No items'+(invFilter!=='all'?' of this rarity':'')+'. Open some cases!</div>';
    return;
  }

  filtered.forEach(inv=>{
    const cat=ITEM_CATALOG[inv.itemId];
    if(!cat)return; // skip unknown items
    const rar=RARITY[cat.rarity];
    if(!rar)return;
    const val=getItemMarketValue(inv.itemId);
    const pnl=val-(inv.acquiredPrice||0);
    const pnlPct=inv.acquiredPrice>0?((pnl/inv.acquiredPrice)*100).toFixed(1):0;
    const d=itemDemand[inv.itemId]||{mult:1};

    const el=document.createElement('div');el.className='inv-item';
    el.innerHTML=
      '<div class="ii-icon">'+cat.icon+'</div>'
      +'<div class="ii-name '+rar.cls+'">'+cat.name+'</div>'
      +'<div class="ii-value">$'+val.toLocaleString()+'</div>'
      +'<div class="ii-demand" style="color:'+(pnl>=0?'var(--green)':'var(--red)')+'">'+
        (pnl>=0?'▲':'▼')+' '+(pnl>=0?'+':'')+pnlPct+'% | x'+d.mult.toFixed(2)+'</div>'
      +'<button class="inv-sell-btn" data-inv="'+inv.id+'">SELL $'+val.toLocaleString()+'</button>'
      +'<div class="ii-rarity-bar" style="background:'+rar.color+';"></div>';
    grid.appendChild(el);
  });

  // Attach sell handlers
  grid.querySelectorAll('.inv-sell-btn').forEach(btn=>{
    btn.onclick=(e)=>{
      e.stopPropagation();
      const invId=parseInt(btn.dataset.inv);
      const inv=inventory.find(x=>x.id===invId);
      if(!inv)return;
      const val=getItemMarketValue(inv.itemId);
      const cat=ITEM_CATALOG[inv.itemId];
      if(!cat){removeFromInventory(invId);renderInventory();return;}
      balance+=val;updateBalDisplay();
      removeFromInventory(invId);
      showToast('Sold '+cat.name+' for $'+val.toLocaleString()+'!');
      playWinSound();renderInventory();firebaseSave();
    };
  });
}

// Inventory / Demand data persistence accessors
window._getInventoryData=()=>inventory;
window._loadInventory=(data)=>{if(Array.isArray(data)){inventory=data;invIdCounter=inventory.reduce((m,x)=>Math.max(m,x.id||0),Date.now());}};
window._getDemandData=()=>itemDemand;
window._loadDemand=(data)=>{if(data&&typeof data==='object'){Object.assign(itemDemand,data);}};

// ============ PLINKO ============
const PLINKO_PAYOUTS={
  8:{LOW:[5.6,2.1,1.1,1,.5,1,1.1,2.1,5.6],MEDIUM:[13,3,1.3,.7,.4,.7,1.3,3,13],HIGH:[29,4,1.5,.3,.2,.3,1.5,4,29]},
  9:{LOW:[5.6,2,1.6,1,.7,.7,1,1.6,2,5.6],MEDIUM:[18,4,1.7,.9,.5,.5,.9,1.7,4,18],HIGH:[43,7,2,.6,.2,.2,.6,2,7,43]},
  10:{LOW:[8.9,3,1.4,1.1,1,.5,1,1.1,1.4,3,8.9],MEDIUM:[22,5,2,1.4,.6,.4,.6,1.4,2,5,22],HIGH:[76,10,3,.9,.3,.2,.3,.9,3,10,76]},
  11:{LOW:[8.4,3,1.9,1.3,1,.7,.7,1,1.3,1.9,3,8.4],MEDIUM:[24,6,3,1.8,.7,.5,.5,.7,1.8,3,6,24],HIGH:[120,14,5.2,1.4,.4,.2,.2,.4,1.4,5.2,14,120]},
  12:{LOW:[10,3,1.6,1.4,1.1,1,.5,1,1.1,1.4,1.6,3,10],MEDIUM:[33,11,4,2,1.1,.6,.3,.6,1.1,2,4,11,33],HIGH:[170,24,8.1,2,.7,.2,.2,.2,.7,2,8.1,24,170]},
  13:{LOW:[8.1,4,3,1.9,1.2,.9,.7,.7,.9,1.2,1.9,3,4,8.1],MEDIUM:[43,13,6,3,1.3,.7,.4,.4,.7,1.3,3,6,13,43],HIGH:[260,37,11,4,1,.2,.2,.2,.2,1,4,11,37,260]},
  14:{LOW:[7.1,4,1.9,1.4,1.3,1.1,1,.5,1,1.1,1.3,1.4,1.9,4,7.1],MEDIUM:[58,15,7,4,1.9,1,.5,.2,.5,1,1.9,4,7,15,58],HIGH:[420,56,18,5,1.9,.3,.2,.2,.2,.3,1.9,5,18,56,420]},
  15:{LOW:[15,8,3,2,1.5,1.1,1,.7,.7,1,1.1,1.5,2,3,8,15],MEDIUM:[88,18,11,5,3,1.3,.5,.3,.3,.5,1.3,3,5,11,18,88],HIGH:[620,83,27,8,3,.5,.2,.2,.2,.2,.5,3,8,27,83,620]},
  16:{LOW:[16,9,2,1.4,1.4,1.2,1.1,1,.5,1,1.1,1.2,1.4,1.4,2,9,16],MEDIUM:[110,41,10,5,3,1.5,1,.5,.3,.5,1,1.5,3,5,10,41,110],HIGH:[1000,130,26,9,4,2,.2,.2,.2,.2,.2,2,4,9,26,130,1000]}
};
const BALL_FRICTIONS={8:.0395,9:.041,10:.038,11:.0355,12:.0414,13:.0437,14:.0401,15:.0418,16:.0364};

let plinkoInitialized=false,plinkoMatterEngine=null,plinkoMatterRender=null,plinkoMatterRunner=null;
let plinkoPins=[],plinkoWalls=[],plinkoSensor=null,plinkoBallBets={};
let plinkoDropCount=0,plinkoTotalProfit=0,plinkoLastWinsList=[];
let plinkoProfitHistory=[0]; // store cumulative profit history (starts with 0 like source)
let plinkoProfitChartInstance = null; // Chart.js instance for Plinko profit chart
let plinkoWinCount=0, plinkoLossCount=0; // win/loss counters
let autoDropInterval=null,autoDropping=false,plinkoDropLock=false;
let plinkoRowCount=16,plinkoRiskLevel='MEDIUM';
let plinkoLastRowXCoords=[];

const PW=760,PH=570,PPX=52,PPT=36,PPB=28;
const PIN_CAT=0x0001,BALL_CAT=0x0002;

function initPlinko(){
  if(plinkoInitialized)return;plinkoInitialized=true;
  const canvas=document.getElementById('plinkoCanvas');
  canvas.width=PW;canvas.height=PH;

  const engine=Matter.Engine.create({timing:{timeScale:1}});
  const dpr=window.devicePixelRatio||1;
  const render=Matter.Render.create({engine,canvas,options:{width:PW,height:PH,pixelRatio:dpr,background:'#0f1728',wireframes:false}});
  const runner=Matter.Runner.create();
  plinkoMatterEngine=engine;plinkoMatterRender=render;plinkoMatterRunner=runner;

  plinkoSensor=Matter.Bodies.rectangle(PW/2,PH,PW,10,{isSensor:true,isStatic:true,render:{visible:false}});
  Matter.Composite.add(engine.world,[plinkoSensor]);

  Matter.Events.on(engine,'collisionStart',({pairs})=>{
    pairs.forEach(({bodyA,bodyB})=>{
      if(bodyA===plinkoSensor)handlePlinkoHit(bodyB);
      else if(bodyB===plinkoSensor)handlePlinkoHit(bodyA);
    });
  });

  // Pin collision glow + sound
  Matter.Events.on(engine,'collisionStart',({pairs})=>{
    pairs.forEach(({bodyA,bodyB})=>{
      const pin=(bodyA.collisionFilter.category===PIN_CAT)?bodyA:
                (bodyB.collisionFilter.category===PIN_CAT)?bodyB:null;
      if(pin){
        pin.render.fillStyle='#00f0ff';
        setTimeout(()=>{pin.render.fillStyle='#ffffff';},80);
        const pitch=350+(pin.position.x/PW)*300+(pin.position.y/PH)*80;
        playSound(pitch,'sine',.02,.008);
      }
    });
  });

  placePlinkoPins();
  updatePlinkoBins();
  Matter.Render.run(render);
  Matter.Runner.run(runner,engine);
  // ensure canvas scales to wrapper (visual only)
  if(render && render.canvas){ render.canvas.style.width = document.querySelector('.plinko-canvas-wrap').clientWidth + 'px'; render.canvas.style.height = document.querySelector('.plinko-canvas-wrap').clientHeight + 'px'; }

  // Ball glow trail
  Matter.Events.on(render,'afterRender',()=>{
    const ctx=render.context;
    Matter.Composite.allBodies(engine.world).forEach(body=>{
      if(body.collisionFilter.category===BALL_CAT){
        const {x,y}=body.position;const r=body.circleRadius||6;
        ctx.save();
        const grd=ctx.createRadialGradient(x,y,r*.5,x,y,r*3);
        grd.addColorStop(0,'rgba(255,80,80,0.25)');grd.addColorStop(1,'rgba(255,40,40,0)');
        ctx.fillStyle=grd;ctx.beginPath();ctx.arc(x,y,r*3,0,Math.PI*2);ctx.fill();
        ctx.restore();
      }
    });
  });

  // Cleanup balls that fall off-screen or get stuck
  setInterval(()=>{
    Matter.Composite.allBodies(engine.world).forEach(body=>{
      if(body.collisionFilter.category===BALL_CAT&&(body.position.y>PH+60||body.position.x<-20||body.position.x>PW+20)){
        Matter.Composite.remove(engine.world,body);
        delete plinkoBallBets[body.id];
      }
    });
  },2000);

  document.getElementById('plinkoRows').addEventListener('change',e=>{
    // Refund in-flight balls before changing rows
    const activeBalls=Object.keys(plinkoBallBets);
    if(activeBalls.length>0){
      let refundTotal=0;
      activeBalls.forEach(id=>{refundTotal+=plinkoBallBets[id].bet||0;});
      if(refundTotal>0){balance+=refundTotal;updateBalDisplay();showToast('Refunded $'+refundTotal.toFixed(2)+' for in-flight balls',true);}
    }
    plinkoRowCount=parseInt(e.target.value);
    removeAllPlinkoBalls();placePlinkoPins();updatePlinkoBins();
  });
  document.getElementById('plinkoRisk').addEventListener('change',e=>{
    plinkoRiskLevel=e.target.value;updatePlinkoBins();
  });
}

function getPinDistX(){return(PW-PPX*2)/(3+plinkoRowCount-1-1);}
function getPinR(){return(24-plinkoRowCount)/2;}

function placePlinkoPins(){
  if(plinkoPins.length)Matter.Composite.remove(plinkoMatterEngine.world,plinkoPins);
  if(plinkoWalls.length)Matter.Composite.remove(plinkoMatterEngine.world,plinkoWalls);
  plinkoPins=[];plinkoWalls=[];plinkoLastRowXCoords=[];

  const pinDist=getPinDistX();const pinR=getPinR();

  for(let row=0;row<plinkoRowCount;row++){
    const rowY=PPT+((PH-PPT-PPB)/(plinkoRowCount-1))*row;
    const rowPadX=PPX+((plinkoRowCount-1-row)*pinDist)/2;
    const cols=3+row;
    for(let col=0;col<cols;col++){
      const colX=cols>1?rowPadX+((PW-rowPadX*2)/(cols-1))*col:PW/2;
      const pin=Matter.Bodies.circle(colX,rowY,pinR,{
        isStatic:true,render:{fillStyle:'#ffffff'},
        collisionFilter:{category:PIN_CAT,mask:BALL_CAT}
      });
      plinkoPins.push(pin);
      if(row===plinkoRowCount-1)plinkoLastRowXCoords.push(colX);
    }
  }
  Matter.Composite.add(plinkoMatterEngine.world,plinkoPins);

  // Walls
  if(plinkoLastRowXCoords.length>1){
    const firstPinX=plinkoPins[0].position.x;
    const wallAngle=Math.atan2(firstPinX-plinkoLastRowXCoords[0],PH-PPT-PPB);
    const wallX=firstPinX-(firstPinX-plinkoLastRowXCoords[0])/2-pinDist*0.25;

    const lw=Matter.Bodies.rectangle(wallX,PH/2,10,PH,{isStatic:true,angle:wallAngle,render:{visible:false}});
    const rw=Matter.Bodies.rectangle(PW-wallX,PH/2,10,PH,{isStatic:true,angle:-wallAngle,render:{visible:false}});
    plinkoWalls=[lw,rw];
    Matter.Composite.add(plinkoMatterEngine.world,plinkoWalls);
  }
}

function updatePlinkoBins(){
  const binsEl=document.getElementById('plinkoBins');
  const payouts=PLINKO_PAYOUTS[plinkoRowCount][plinkoRiskLevel];
  const count=payouts.length;
  binsEl.innerHTML='';

  // Reference colors: edges rgb(255,0,63) → center rgb(255,192,0)
  // Shadow:           edges rgb(166,0,4)  → center rgb(171,121,0)
  const half=Math.ceil(count/2);
  function lerpC(a,b,t){return Math.round(a+(b-a)*t);}
  function binBg(i){
    const t2=Math.abs(i-(count-1)/2)/((count-1)/2);// 0=center 1=edge
    return'rgb('+lerpC(255,255,t2)+','+lerpC(192,0,t2)+','+lerpC(0,63,t2)+')';
  }
  function binSh(i){
    const t2=Math.abs(i-(count-1)/2)/((count-1)/2);
    return'rgb('+lerpC(171,166,t2)+','+lerpC(121,0,t2)+','+lerpC(0,4,t2)+')';
  }
  for(let i=0;i<count;i++){
    const bin=document.createElement('div');bin.className='plinko-bin';
    bin.style.background=binBg(i);
    bin.style.boxShadow='0 3px 0 '+binSh(i);
    bin.textContent=payouts[i]+'×';
    bin.id='plinkoBin'+i;
    binsEl.appendChild(bin);
  }

  if(plinkoLastRowXCoords.length>1){
    const first=plinkoLastRowXCoords[0],last=plinkoLastRowXCoords[plinkoLastRowXCoords.length-1];
    const pct=((last-first)/PW)*100;
    binsEl.style.width=pct+'%';
  }
}

function handlePlinkoHit(ball){
  if(!plinkoLastRowXCoords.length)return;
  const coords=plinkoLastRowXCoords;
  const ballX=ball.position.x;// capture before removal
  // Find which bin the ball landed in
  let binIndex=-1;
  for(let i=coords.length-1;i>=0;i--){
    if(coords[i]<ballX){binIndex=i;break;}
  }

  // Clean up ball
  Matter.Composite.remove(plinkoMatterEngine.world,ball);
  const ballData=plinkoBallBets[ball.id]||{bet:0,risk:plinkoRiskLevel,rows:plinkoRowCount};
  const betAmt=typeof ballData==='object'?ballData.bet:ballData;
  const ballRisk=typeof ballData==='object'?ballData.risk:plinkoRiskLevel;
  const ballRows=typeof ballData==='object'?ballData.rows:plinkoRowCount;
  delete plinkoBallBets[ball.id];

  if(binIndex<0){binIndex=0;}
  if(binIndex>=coords.length-1){binIndex=coords.length-2;}
  if(binIndex<0){return;} // safety: no valid bins
  // Landing thud sound
  playSound(180+(binIndex/(coords.length-1))*120,'triangle',.06,.04);

  const payouts=PLINKO_PAYOUTS[ballRows][ballRisk];
  if(!payouts){return;}
  const multiplier=payouts[binIndex];
  const payout=betAmt*multiplier;
  const profit=payout-betAmt;

  balance+=payout;
  plinkoTotalProfit+=profit;
  // track wins/losses
  if(profit>=0) plinkoWinCount++; else plinkoLossCount++;
  // record cumulative profit history for graph
  plinkoProfitHistory.push(plinkoTotalProfit); if(plinkoProfitHistory.length>500)plinkoProfitHistory.shift();
  // update profit chart
  try{ updatePlinkoProfitChart(); }catch(e){}
  plinkoDropCount++;
  updateBalDisplay();

  document.getElementById('plinkoDropCount').textContent=plinkoDropCount;
  // Update profit display
  const profitEl=document.getElementById('plinkoProfit');
  profitEl.textContent=(plinkoTotalProfit>=0?'+':'')+('$'+Math.abs(plinkoTotalProfit).toFixed(2));
  profitEl.style.color=plinkoTotalProfit>=0?'#4ade80':'#f87171';
  // Update wins/losses
  document.getElementById('plinkoWins').textContent=plinkoWinCount.toLocaleString();
  document.getElementById('plinkoLosses').textContent=plinkoLossCount.toLocaleString();

  // Bin bounce
  const binEl=document.getElementById('plinkoBin'+binIndex);
  if(binEl){binEl.classList.remove('bounce');void binEl.offsetWidth;binEl.classList.add('bounce');}

  // Last wins display
  plinkoLastWinsList.push({multiplier,binIndex});
  if(plinkoLastWinsList.length>4)plinkoLastWinsList.shift();
  renderPlinkoLastWins();

  // Effects
  if(multiplier>=10){
    playWinSound();
    const rect=document.getElementById('plinkoCanvas').getBoundingClientRect();
    const bx=rect.left+rect.width*(ballX/PW);
    const by=rect.top+rect.height;
    spawnParticles(bx,by,20+Math.min(multiplier,100));
    showToast(multiplier+'× — $'+payout.toFixed(2)+'!');
  }else if(multiplier>=3){
    playSound(600,'sine',.08,.08);
  }else{
    playSound(300,'sine',.04,.04);
  }
  recordGame('plinko', betAmt, payout);
}

function renderPlinkoLastWins(){
  const container=document.getElementById('plinkoLastWins');
  container.innerHTML='';
  const payouts=PLINKO_PAYOUTS[plinkoRowCount][plinkoRiskLevel];
  const count=payouts.length;

  [...plinkoLastWinsList].reverse().forEach(w=>{
    const t=Math.abs(w.binIndex-(count-1)/2)/((count-1)/2);
    const el=document.createElement('div');el.className='plinko-last-win';
    el.style.background='rgb('+Math.round(255)+','+Math.round(192-192*t)+','+Math.round(63*t)+')';
    el.textContent=w.multiplier+'×';
    container.appendChild(el);
  });
}

// ---- Plinko Profit Chart (matches plinko-game-online.github.io ProfitHistoryChart) ----
const PLINKO_WIN_COLOR='rgb(74,222,128)', PLINKO_WIN_FILL='rgba(74,222,128,0.3)';
const PLINKO_LOSS_COLOR='rgb(248,113,113)', PLINKO_LOSS_FILL='rgba(248,113,113,0.3)';
const PLINKO_X_AXIS_COLOR='#1e293b', PLINKO_HOVER_COLOR='#fff';

function updatePlinkoProfitChart(){
  const canvas=document.getElementById('plinkoProfitChart'); if(!canvas) return;
  if(typeof Chart==='undefined') return;
  const data=plinkoProfitHistory.length? plinkoProfitHistory : [0];
  if(plinkoProfitChartInstance){
    plinkoProfitChartInstance.data.labels=Array(data.length).fill(0);
    plinkoProfitChartInstance.data.datasets[0].data=data;
    plinkoProfitChartInstance.update();
    return;
  }
  const ctx=canvas.getContext('2d');
  plinkoProfitChartInstance=new Chart(ctx,{
    type:'line',
    data:{labels:Array(data.length).fill(0),datasets:[{label:'Profit',data:data,
      fill:{target:'origin',above:PLINKO_WIN_FILL,below:PLINKO_LOSS_FILL},
      cubicInterpolationMode:'monotone',
      segment:{borderColor:(c)=>{
        const y0=c.p0.parsed.y, y1=c.p1.parsed.y;
        if(y1===0) return y0<0? PLINKO_LOSS_COLOR : PLINKO_WIN_COLOR;
        return y1<0? PLINKO_LOSS_COLOR : PLINKO_WIN_COLOR;
      }},
      pointRadius:0, pointHoverRadius:5,
      pointHoverBackgroundColor:PLINKO_HOVER_COLOR,
      pointHoverBorderColor:PLINKO_HOVER_COLOR
    }]},
    options:{
      responsive:true, maintainAspectRatio:false,
      animations:{y:{duration:0}},
      interaction:{intersect:false, mode:'index'},
      plugins:{legend:{display:false}, tooltip:{enabled:false}},
      scales:{
        x:{border:{display:false}, grid:{display:false}, ticks:{display:false}},
        y:{border:{display:false}, grid:{color:(c)=>(c.tick.value===0? PLINKO_X_AXIS_COLOR : undefined), lineWidth:2}, ticks:{display:false}, grace:'1%'}
      },
      onHover:(_,elements)=>{
        const hv=document.getElementById('plinkoHoverValue');
        if(elements.length){
          const idx=elements[0].index;
          const val=plinkoProfitHistory[idx];
          if(hv && val!==undefined){
            hv.textContent=(val>=0?'+':'')+('$'+Math.abs(val).toFixed(2));
            hv.style.color=val>=0?'#4ade80':'#f87171';
          }
        }
      }
    }
  });
  // Clear hover value on mouse leave
  canvas.addEventListener('mouseleave',()=>{
    const hv=document.getElementById('plinkoHoverValue'); if(hv) hv.textContent='';
  });
}

function resetPlinkoStats(){
  plinkoDropCount=0; plinkoTotalProfit=0; plinkoWinCount=0; plinkoLossCount=0;
  plinkoProfitHistory=[0]; plinkoLastWinsList=[];
  // Destroy chart so it's recreated fresh
  if(plinkoProfitChartInstance){plinkoProfitChartInstance.destroy();plinkoProfitChartInstance=null;}
  // Reset UI
  document.getElementById('plinkoDropCount').textContent='0';
  const pe=document.getElementById('plinkoProfit'); pe.textContent='$0.00'; pe.style.color='#4ade80';
  document.getElementById('plinkoWins').textContent='0';
  document.getElementById('plinkoLosses').textContent='0';
  const hv=document.getElementById('plinkoHoverValue'); if(hv) hv.textContent='';
  renderPlinkoLastWins();
  // Recreate chart with empty data
  updatePlinkoProfitChart();
}


function removeAllPlinkoBalls(){
  if(!plinkoMatterEngine)return;
  Matter.Composite.allBodies(plinkoMatterEngine.world).forEach(body=>{
    if(body.collisionFilter.category===BALL_CAT)Matter.Composite.remove(plinkoMatterEngine.world,body);
  });
  plinkoBallBets={};
}

function dropPlinkoBall(){
  if(plinkoDropLock)return;plinkoDropLock=true;
  if(!plinkoInitialized)initPlinko();
  const bet=parseFloat(document.getElementById('plinkoBet').value)||10;
  if(bet>balance){showToast('Not enough balance!',false);if(autoDropping)toggleAutoDrop();plinkoDropLock=false;return;}
  if(bet<=0){plinkoDropLock=false;return;}

  balance-=bet;updateBalDisplay();
  plinkoDropLock=false;
  playSound(500,'sine',.04,.05);

  const pinDist=getPinDistX();
  const ballR=getPinR()*2;
  const offsetRange=pinDist*0.8;

  const ball=Matter.Bodies.circle(
    PW/2+(Math.random()-.5)*offsetRange*2, 0, ballR,
    {restitution:0.8,friction:0.5,frictionAir:BALL_FRICTIONS[plinkoRowCount],
      collisionFilter:{category:BALL_CAT,mask:PIN_CAT},
      render:{fillStyle:'#ff0000'}}
  );
  Matter.Composite.add(plinkoMatterEngine.world,ball);
  plinkoBallBets[ball.id]={bet:bet,risk:plinkoRiskLevel,rows:plinkoRowCount};
}

function toggleAutoDrop(){
  if(autoDropping){
    clearInterval(autoDropInterval);autoDropInterval=null;autoDropping=false;
    document.getElementById('autoDropBtn').textContent='AUTO DROP';
    document.getElementById('autoDropBtn').style.background='linear-gradient(135deg,#3355cc,#2244aa)';
  }else{
    autoDropping=true;
    document.getElementById('autoDropBtn').textContent='STOP AUTO';
    document.getElementById('autoDropBtn').style.background='linear-gradient(135deg,#cc3355,#991133)';
    autoDropInterval=setInterval(()=>{
      const bet=parseFloat(document.getElementById('plinkoBet').value)||10;
      if(bet>balance){toggleAutoDrop();return;}
      // Limit max simultaneous balls to prevent performance issues
      const activeBallCount=Object.keys(plinkoBallBets).length;
      if(activeBallCount>=50)return;
      dropPlinkoBall();
    },250);
  }
}

// ============ PUSH YOUR LUCK (Multiplayer Modes) ============
let pylCurrentMode = null; // 'solo','1v1','highstakes','tournament'
let pylRoomCode = null;
let pylRoomUnsub = null; // Firebase listener cleanup
let pylWagerAmount = 0;
let pylWagerEscrowed = false; // true when wager deducted at room creation
let pylHSTarget = 500;
let pylHSMultiplier = 2;
let pylGameActive = false;
let pylOpponentId = null; // Track opponent session ID for 1v1 choice relay

// Listen for score messages from the PYL iframe
window.addEventListener('message', function(evt) {
  if (evt.data && evt.data.type === 'pylScore' && pylGameActive) {
    const score = evt.data.score || 0;
    document.getElementById('pylScoreDisplay').textContent = 'Score: ' + score;
    document.getElementById('pylScoreInput').value = score;
    // Auto-submit for all modes
    pylSubmitScore();
  }
  // 1v1 choice relay: player made a choice in the iframe — write to Firebase and listen for opponent
  if (evt.data && evt.data.type === 'pylChoice' && pylCurrentMode === '1v1' && pylRoomCode && pylOpponentId) {
    const round = evt.data.round;
    const choice = evt.data.choice;
    // Write our choice to Firebase
    if (window._pylWriteChoice) {
      window._pylWriteChoice(pylRoomCode, round, choice);
    }
    // Listen for opponent's choice for this round
    if (window._pylListenChoice) {
      window._pylListenChoice(pylRoomCode, round, pylOpponentId, function(opChoice) {
        // Relay opponent's choice back to the iframe
        const iframe = document.getElementById('pylIframe');
        if (iframe && iframe.contentWindow) {
          iframe.contentWindow.postMessage({ type: 'pylOpponentChoice', choice: opChoice, round: round }, '*');
        }
      });
    }
  }
});

function pylStartMode(mode) {
  pylCurrentMode = mode;
  playClickSound();

  if (mode === 'solo') {
    pylHideLobby();
    pylShowOverlay('FREE PLAY', 0);
    pylGameActive = true;
  } else if (mode === 'tournament') {
    pylHideLobby();
    pylShowOverlay('🏆 TOURNAMENT', 0);
    pylGameActive = true;
    pylLoadLeaderboard();
  }
}

function pylShowWager(mode) {
  playClickSound();
  pylCurrentMode = mode;

  // Hide mode cards
  document.querySelector('.pyl-modes').style.display = 'none';
  document.getElementById('pylLeaderboard').style.display = 'none';

  if (mode === '1v1') {
    document.getElementById('pylRoomUI').style.display = 'block';
    document.getElementById('pylHighStakesUI').style.display = 'none';
    document.getElementById('pylRoomStatus').textContent = 'Create a room or enter a code to join';
    document.getElementById('pylRoomPlayers').innerHTML = '';
  } else if (mode === 'highstakes') {
    document.getElementById('pylHighStakesUI').style.display = 'block';
    document.getElementById('pylRoomUI').style.display = 'none';
  }
}

function pylBackToLobby() {
  playClickSound();
  // Refund escrowed wager if game never started
  if (pylWagerEscrowed && pylWagerAmount > 0) {
    balance += pylWagerAmount;
    updateBalDisplay();
    showToast('Wager refunded ($' + pylWagerAmount + ')');
    pylWagerEscrowed = false;
  }
  // Clean up any room listener
  if (pylRoomUnsub) { pylRoomUnsub(); pylRoomUnsub = null; }
  if (pylRoomCode && pylCurrentMode === '1v1') {
    // Cancel our onDisconnect handlers since we're leaving cleanly
    if (window._pylCancelDisconnect) window._pylCancelDisconnect(pylRoomCode);
    // Mark ourselves offline and delete room
    if (window._pylDeleteRoom) window._pylDeleteRoom(pylRoomCode);
    // Reset iframe so next game doesn't carry stale 1v1 config
    const iframe = document.getElementById('pylIframe');
    if (iframe) iframe.src = '';
  }
  pylRoomCode = null;
  pylCurrentMode = null;
  pylGameActive = false;
  pylOpponentId = null;
  _pylDisconnectHandled = false;

  // Show lobby, hide everything else
  document.querySelector('.pyl-modes').style.display = '';
  document.getElementById('pylRoomUI').style.display = 'none';
  document.getElementById('pylHighStakesUI').style.display = 'none';
  document.getElementById('pylLobby').style.display = '';
  document.getElementById('pylOverlay').classList.add('hidden');
  document.getElementById('pylLeaderboard').style.display = '';
  pylLoadLeaderboard();
}

function pylHideLobby(opponentName, roomCode) {
  document.getElementById('pylLobby').style.display = 'none';
  // Ensure the game iframe exists and is loaded
  let iframe = document.getElementById('pylIframe');
  if (!iframe) {
    iframe = document.createElement('iframe');
    iframe.id = 'pylIframe';
    iframe.allow = 'autoplay';
    const panel = document.getElementById('luckPanel');
    panel.insertBefore(iframe, panel.firstChild);
  }
  // Build URL with 1v1 hash if opponent name provided
  let url = 'push-your-luck/index.html';
  if (opponentName) {
    url += '?t=' + Date.now() + '#1v1=' + encodeURIComponent(opponentName) + '&room=' + (roomCode || 'default');
  }
  // Always force reload for 1v1 so PYL_1V1 is picked up fresh; also reload for non-1v1 if coming from a 1v1 game
  if (opponentName || !iframe.src || !iframe.src.includes('push-your-luck') || iframe.src.includes('#1v1=')) {
    iframe.src = url;
  }
}

function pylShowOverlay(label, wager) {
  const overlay = document.getElementById('pylOverlay');
  overlay.classList.remove('hidden');
  document.getElementById('pylModeLabel').textContent = label;
  document.getElementById('pylScoreDisplay').textContent = 'Score: —';
  document.getElementById('pylScoreInput').value = '';

  if (wager > 0) {
    document.getElementById('pylWagerCard').style.display = '';
    document.getElementById('pylWagerDisplay').textContent = '$' + wager.toLocaleString();
  } else {
    document.getElementById('pylWagerCard').style.display = 'none';
  }

  document.getElementById('pylOpponentCard').style.display = 'none';
}

// ---- 1v1 ROOM ----
function generateRoomCode() {
  const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
  let code = '';
  for (let i = 0; i < 5; i++) code += chars[Math.floor(Math.random() * chars.length)];
  return code;
}

function pylCreateRoom() {
  const wager = parseFloat(document.getElementById('pylWager').value) || 100;
  if (wager < 10) { showToast('Minimum wager is $10', false); return; }

  pylWagerAmount = wager;
  pylRoomCode = generateRoomCode();
  playClickSound();

  // Escrow wager immediately to prevent spending it on other games
  balance -= pylWagerAmount;
  updateBalDisplay();
  pylWagerEscrowed = true;

  document.getElementById('pylRoomStatus').innerHTML =
    'Room: <span style="color:var(--neon);font-size:18px;letter-spacing:3px;">' + pylRoomCode + '</span><br>' +
    '<span style="color:var(--text2);font-size:11px;">Share this code with your opponent</span>';
  document.getElementById('pylRoomPlayers').innerHTML =
    '<div style="color:var(--green);margin:4px 0;">✓ You (host) — $' + wager + ' wager</div>' +
    '<div style="color:var(--text2);margin:4px 0;">⏳ Waiting for opponent...</div>';

  // Create room in Firebase
  if (window._pylCreateRoom) {
    window._pylCreateRoom(pylRoomCode, wager).then(() => {
      // Listen for opponent joining
      let pylGameStarted = false;
      pylRoomUnsub = window._pylListenRoom(pylRoomCode, (data) => {
        if (!data || pylGameStarted) return;
        const players = data.players || {};
        const playerKeys = Object.keys(players);

        if (playerKeys.length >= 2) {
          pylGameStarted = true;
          pylWagerEscrowed = false; // game started, escrow consumed
          showToast('⚔️ Opponent joined! Game on!');
          playWinSound();
          // Wager already escrowed at room creation
          const opId = playerKeys.find(k => k !== window._pylPlayerId);
          const opData = opId ? players[opId] : null;
          const opName = opData && opData.name ? opData.name : (opId ? opId.slice(-5) : 'Opponent');
          pylOpponentId = opId;

          pylHideLobby(opName, pylRoomCode);
          document.getElementById('pylRoomUI').style.display = 'none';
          pylShowOverlay('⚔️ 1v1 WAGER — $' + (pylWagerAmount * 2), pylWagerAmount);
          document.getElementById('pylOpponentCard').style.display = '';
          document.getElementById('pylOpponentName').textContent = opName;
          document.getElementById('pylOpponentScore').textContent = 'Playing...';
          pylGameActive = true;

          // Listen for opponent score + disconnect
          pylRoomUnsub = window._pylListenRoom(pylRoomCode, (roomData) => {
            if (!roomData) {
              // Room was deleted — opponent disconnected
              pylHandleOpponentDisconnect();
              return;
            }
            const ps = roomData.players || {};
            if (opId && ps[opId]) {
              if (ps[opId].score != null) {
                document.getElementById('pylOpponentScore').textContent = ps[opId].score + ' pts';
              }
              if (ps[opId].online === false && pylGameActive) {
                pylHandleOpponentDisconnect();
              }
            }
          });
        }
      });
    });
  }
}

function pylJoinRoom() {
  const code = (document.getElementById('pylJoinCode').value || '').toUpperCase().trim();
  if (!code) { showToast('Enter a room code!', false); return; }

  playClickSound();
  document.getElementById('pylRoomStatus').textContent = 'Checking room...';

  if (window._pylJoinRoom) {
    // PRE-CHECK: read room data first to validate balance BEFORE joining on Firebase
    window._pylPeekRoom(code).then(data => {
      if (!data) {
        showToast('Room not found or already started!', false);
        document.getElementById('pylRoomStatus').textContent = 'Room not found. Try again.';
        return;
      }
      const wager = data.wager || 100;
      if (wager > balance) {
        showToast('Not enough balance for $' + wager + ' wager!', false);
        document.getElementById('pylRoomStatus').textContent = 'Insufficient balance ($' + wager + ' needed).';
        return;
      }
      // Balance OK — now actually join on Firebase
      document.getElementById('pylRoomStatus').textContent = 'Joining...';
      return window._pylJoinRoom(code);
    }).then(data => {
      if (!data) return; // already handled above

      pylRoomCode = code;
      pylWagerAmount = data.wager || 100;

      balance -= pylWagerAmount;
      updateBalDisplay();

      showToast('⚔️ Joined! Game on!');
      playWinSound();
      const players = data.players || {};
      const opId = Object.keys(players).find(k => k !== window._pylPlayerId);
      const opData = opId ? players[opId] : null;
      const opName = opData && opData.name ? opData.name : (opId ? opId.slice(-5) : 'Opponent');
      pylOpponentId = opId;

      pylHideLobby(opName, pylRoomCode);
      document.getElementById('pylRoomUI').style.display = 'none';
      pylShowOverlay('⚔️ 1v1 WAGER — $' + (pylWagerAmount * 2), pylWagerAmount);
      document.getElementById('pylOpponentCard').style.display = '';
      document.getElementById('pylOpponentName').textContent = opName;
      document.getElementById('pylOpponentScore').textContent = 'Playing...';
      pylGameActive = true;

      // Listen for opponent score + disconnect
      pylRoomUnsub = window._pylListenRoom(pylRoomCode, (roomData) => {
        if (!roomData) {
          // Room was deleted — opponent disconnected
          pylHandleOpponentDisconnect();
          return;
        }
        const ps = roomData.players || {};
        if (opId && ps[opId]) {
          if (ps[opId].score != null) {
            document.getElementById('pylOpponentScore').textContent = ps[opId].score + ' pts';
          }
          if (ps[opId].online === false && pylGameActive) {
            pylHandleOpponentDisconnect();
          }
        }
      });
    });
  }
}

// ---- HIGH STAKES ----
function pylStartHighStakes() {
  const wager = parseFloat(document.getElementById('pylHSWager').value) || 500;
  if (wager > balance) { showToast('Not enough balance!', false); return; }
  if (wager < 50) { showToast('Minimum wager is $50', false); return; }

  const sel = document.getElementById('pylHSTarget');
  pylHSTarget = parseInt(sel.value);
  pylHSMultiplier = parseFloat(sel.options[sel.selectedIndex].dataset.mult);
  pylWagerAmount = wager;

  balance -= wager;
  updateBalDisplay();
  playClickSound();

  pylHideLobby();
  document.getElementById('pylHighStakesUI').style.display = 'none';
  pylShowOverlay('💀 HIGH STAKES — ' + pylHSTarget + 'pts for ' + pylHSMultiplier + 'x', wager);
  pylGameActive = true;

  showToast('💀 Hit ' + pylHSTarget + ' pts to win $' + (wager * pylHSMultiplier).toLocaleString() + '!');
}

// ---- SCORE SUBMISSION ----
function pylSubmitScore() {
  const scoreInput = document.getElementById('pylScoreInput');
  const score = parseInt(scoreInput.value);
  if (isNaN(score) || score < 0) { showToast('Enter a valid score!', false); return; }

  playClickSound();
  document.getElementById('pylScoreDisplay').textContent = 'Score: ' + score;
  scoreInput.value = '';
  pylGameActive = false;

  // Track PYL stats
  if (gameStats.pyl) {
    gameStats.pyl.played = (gameStats.pyl.played || 0) + 1;
    if (score > (gameStats.pyl.highScore || 0)) gameStats.pyl.highScore = score;
  }

  if (pylCurrentMode === 'solo') {
    showToast('Free play score: ' + score + ' pts!');
    firebaseSave();
  }

  else if (pylCurrentMode === '1v1') {
    // Submit score to Firebase
    if (window._pylSubmitRoomScore && pylRoomCode) {
      window._pylSubmitRoomScore(pylRoomCode, score).then(() => {
        document.getElementById('pylScoreDisplay').textContent = 'Your Score: ' + score + ' — Waiting for opponent...';

        // Check if opponent already submitted
        const checkResult = () => {
          if (pylRoomUnsub) pylRoomUnsub();
          pylRoomUnsub = window._pylListenRoom(pylRoomCode, (data) => {
            if (!data) {
              // Room deleted — opponent disconnected while we were waiting
              if (!_pylDisconnectHandled) {
                _pylDisconnectHandled = true;
                pylGameActive = false;
                const pot = pylWagerAmount * 2;
                balance += pot;
                updateBalDisplay();
                showToast('⚔️ Opponent disconnected — YOU WIN! +$' + pot.toLocaleString() + '!');
                playWinSound();
                document.getElementById('pylScoreDisplay').innerHTML =
                  '<span style="color:var(--green);">⚔️ OPPONENT DISCONNECTED</span> — You win $' + pot.toLocaleString() + '!';
                document.getElementById('pylOpponentScore').textContent = 'DISCONNECTED';
                if (pylRoomUnsub) { pylRoomUnsub(); pylRoomUnsub = null; }
                firebaseSave();
                setTimeout(() => pylBackToLobby(), 4000);
              }
              return;
            }
            const ps = data.players || {};
            const myScore = score;
            const opId = Object.keys(ps).find(k => k !== window._pylPlayerId);

            // Check if opponent disconnected
            if (opId && ps[opId] && ps[opId].online === false && ps[opId].score == null) {
              if (!_pylDisconnectHandled) {
                _pylDisconnectHandled = true;
                pylGameActive = false;
                if (pylRoomUnsub) { pylRoomUnsub(); pylRoomUnsub = null; }
                const pot = pylWagerAmount * 2;
                balance += pot;
                updateBalDisplay();
                showToast('⚔️ Opponent disconnected — YOU WIN! +$' + pot.toLocaleString() + '!');
                playWinSound();
                document.getElementById('pylScoreDisplay').innerHTML =
                  '<span style="color:var(--green);">⚔️ OPPONENT DISCONNECTED</span> — You win $' + pot.toLocaleString() + '!';
                document.getElementById('pylOpponentScore').textContent = 'DISCONNECTED';
                firebaseSave();
                setTimeout(() => { if (window._pylDeleteRoom) window._pylDeleteRoom(pylRoomCode); pylRoomCode = null; }, 4000);
              }
              return;
            }

            if (opId && ps[opId] && ps[opId].score != null) {
              const opScore = ps[opId].score;
              document.getElementById('pylOpponentScore').textContent = opScore + ' pts';

              if (pylRoomUnsub) { pylRoomUnsub(); pylRoomUnsub = null; }

              const pot = pylWagerAmount * 2;
              if (myScore > opScore) {
                balance += pot;
                updateBalDisplay();
                showToast('🏆 YOU WIN! +$' + pot.toLocaleString() + '!');
                playWinSound();
                spawnParticles(window.innerWidth / 2, window.innerHeight / 2, 60);
                document.getElementById('pylScoreDisplay').innerHTML =
                  '<span style="color:var(--green);">🏆 YOU WIN!</span> ' + myScore + ' vs ' + opScore + ' — +$' + pot.toLocaleString();
              } else if (myScore < opScore) {
                showToast('💀 You lost! -$' + pylWagerAmount, false);
                playLoseSound();
                document.getElementById('pylScoreDisplay').innerHTML =
                  '<span style="color:var(--red);">💀 YOU LOSE</span> ' + myScore + ' vs ' + opScore;
              } else {
                balance += pylWagerAmount; // refund on tie
                updateBalDisplay();
                showToast('🤝 Tie! Wager refunded.');
                document.getElementById('pylScoreDisplay').innerHTML =
                  '<span style="color:var(--gold);">🤝 TIE</span> ' + myScore + ' vs ' + opScore + ' — Refunded';
              }

              // Clean up room after a delay
              setTimeout(() => { if (window._pylDeleteRoom) window._pylDeleteRoom(pylRoomCode); pylRoomCode = null; }, 5000);
              firebaseSave();
            }
          });
        };
        checkResult();
      });
    }
  }

  else if (pylCurrentMode === 'highstakes') {
    if (score >= pylHSTarget) {
      const payout = pylWagerAmount * pylHSMultiplier;
      balance += payout;
      updateBalDisplay();
      showToast('🔥 HIGH STAKES WIN! +$' + payout.toLocaleString() + '!');
      playWinSound();
      spawnParticles(window.innerWidth / 2, window.innerHeight / 2, 80);
      document.getElementById('pylScoreDisplay').innerHTML =
        '<span style="color:var(--green);">🔥 ' + pylHSMultiplier + 'x WIN!</span> ' + score + '/' + pylHSTarget +
        ' pts — +$' + payout.toLocaleString();
    } else {
      showToast('💀 Didn\'t hit target! -$' + pylWagerAmount, false);
      playLoseSound();
      document.getElementById('pylScoreDisplay').innerHTML =
        '<span style="color:var(--red);">💀 MISS</span> ' + score + '/' + pylHSTarget +
        ' pts — Lost $' + pylWagerAmount.toLocaleString();
    }
    firebaseSave();
  }

  else if (pylCurrentMode === 'tournament') {
    if (window._pylSubmitLeaderboard) {
      window._pylSubmitLeaderboard(score).then(() => {
        showToast('🏆 Score submitted to leaderboard: ' + score + ' pts!');
        pylLoadLeaderboard();
      });
    }
    firebaseSave();
  }
}

let _pylDisconnectHandled = false;

function pylHandleOpponentDisconnect() {
  if (_pylDisconnectHandled || !pylGameActive) return;
  _pylDisconnectHandled = true;

  // Opponent disconnected — refund wager, auto-win
  if (pylRoomUnsub) { pylRoomUnsub(); pylRoomUnsub = null; }
  pylGameActive = false;

  const pot = pylWagerAmount * 2;
  balance += pot;
  updateBalDisplay();
  firebaseSave();

  showToast('⚔️ Opponent disconnected — YOU WIN! +$' + pot.toLocaleString() + '!');
  playWinSound();
  spawnParticles(window.innerWidth / 2, window.innerHeight / 2, 40);

  document.getElementById('pylScoreDisplay').innerHTML =
    '<span style="color:var(--green);">⚔️ OPPONENT DISCONNECTED</span> — You win $' + pot.toLocaleString() + '!';
  document.getElementById('pylOpponentScore').textContent = 'DISCONNECTED';

  // Clean up the room
  if (pylRoomCode && window._pylDeleteRoom) {
    window._pylDeleteRoom(pylRoomCode);
  }

  // Auto return to lobby after 4 seconds
  setTimeout(() => {
    pylBackToLobby();
  }, 4000);
}

function pylEndGame() {
  playClickSound();

  // If 1v1 with no score submitted, forfeit
  if (pylCurrentMode === '1v1' && pylGameActive && pylRoomCode) {
    showToast('Forfeited wager: -$' + pylWagerAmount, false);
    playLoseSound();
    if (window._pylSubmitRoomScore) window._pylSubmitRoomScore(pylRoomCode, 0);
    // Mark ourselves offline so opponent detects the disconnect
    if (window._pylMarkOffline) window._pylMarkOffline(pylRoomCode);
  }

  pylGameActive = false;
  _pylDisconnectHandled = false;
  if (pylRoomUnsub) { pylRoomUnsub(); pylRoomUnsub = null; }
  pylBackToLobby();
}

// ---- LEADERBOARD ----
function pylLoadLeaderboard() {
  const container = document.getElementById('pylLBRows');
  if (!container) return;

  if (window._pylGetLeaderboard) {
    window._pylGetLeaderboard().then(entries => {
      if (entries.length === 0) {
        container.innerHTML = '<div style="color:var(--text2);padding:8px;text-align:center;font-size:12px;">No scores yet. Be the first!</div>';
        return;
      }
      container.innerHTML = entries.map((e, i) => {
        const medal = i === 0 ? '🥇' : i === 1 ? '🥈' : i === 2 ? '🥉' : (i + 1) + '.';
        const isMe = e.player === (window._currentUsername || '');
        return '<div class="pyl-lb-row' + (isMe ? ' me' : '') + '">' +
          '<span class="lb-rank">' + medal + '</span>' +
          '<span class="lb-name">' + escapeHtml(e.player) + (isMe ? ' (you)' : '') + '</span>' +
          '<span class="lb-score">' + e.score.toLocaleString() + ' pts</span>' +
          '</div>';
      }).join('');
    }).catch(() => {
      container.innerHTML = '<div style="color:var(--text2);padding:8px;text-align:center;font-size:12px;">Could not load leaderboard</div>';
    });
  }
}

// ============ STOCKS (Deterministic Time-Based Market) ============
// Prices are deterministic based on real time — every 3-second "tick" since
// epoch produces the same price no matter when you compute it. The market
// truly runs 24/7 whether the page is open or not.

// -- Seeded PRNG (Mulberry32) --
function mulberry32(seed) {
  let t = (seed >>> 0) + 0x6D2B79F5;
  t = Math.imul(t ^ (t >>> 15), t | 1);
  t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
  return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
}
function hashTicker(str) {
  let h = 5381;
  for (let i = 0; i < str.length; i++) h = ((h << 5) + h) + str.charCodeAt(i);
  return h >>> 0;
}

const STOCK_DEFS = [
  { ticker: 'GMBL', name: 'Gamble Corp', basePrice: 100, volatility: 0.025, drift: 0.00012 },
  { ticker: 'LUCK', name: 'Lucky Labs', basePrice: 42, volatility: 0.035, drift: -0.00005 },
  { ticker: 'NEON', name: 'Neon Digital', basePrice: 250, volatility: 0.018, drift: 0.0002 },
  { ticker: 'DICE', name: 'DiceTech Inc', basePrice: 15, volatility: 0.045, drift: 0.00008 },
  { ticker: 'MOON', name: 'Moonshot AI', basePrice: 500, volatility: 0.03, drift: 0.00025 },
];

// Tick epoch: Jan 1 2025 00:00 UTC — all ticks counted from here
const TICK_EPOCH = new Date('2025-01-01T00:00:00Z').getTime();
const TICK_MS = 3000; // 3 seconds per tick

function getCurrentTick() {
  return Math.floor((Date.now() - TICK_EPOCH) / TICK_MS);
}

// Get deterministic price change for a stock at a specific tick
function getTickRandom(tickerHash, tickNum) {
  return mulberry32(tickerHash ^ (tickNum * 2654435761));
}

let stockPrices = {};       // ticker -> current price
let stockHoldings = {};     // ticker -> { shares, totalCost }
let stockPriceHistory = {}; // ticker -> [last 100 prices]
let stocksInitialized = false;
let stockTickInterval = null;
let lastComputedTick = 0;   // global: the tick number we've computed up to

function initStocks() {
  if (stocksInitialized) return;
  stocksInitialized = true;

  // Set initial prices = base prices at tick 0
  STOCK_DEFS.forEach(s => {
    if (!stockPrices[s.ticker]) stockPrices[s.ticker] = s.basePrice;
    if (!stockPriceHistory[s.ticker]) stockPriceHistory[s.ticker] = [];
  });

  // If no saved state, compute from tick 0 to now
  if (lastComputedTick === 0) {
    // For fresh start, begin from 200 ticks ago so chart has data
    const now = getCurrentTick();
    lastComputedTick = Math.max(0, now - 500);
    // Reset to base prices for a clean computation
    STOCK_DEFS.forEach(s => { stockPrices[s.ticker] = s.basePrice; });
    advanceToTick(now);
  } else {
    // Advance from saved state to current time
    advanceToTick(getCurrentTick());
  }

  // Live tick every 3 seconds
  startStockTicker();
}

function advanceToTick(targetTick) {
  if (targetTick <= lastComputedTick) return;

  // Cap catchup to prevent UI freeze (max 5000 ticks = ~4.2 hours)
  const MAX_CATCHUP_TICKS = 5000;
  const MAX_COMPUTE_TICKS = 20000; // absolute max ticks to compute
  const gap = targetTick - lastComputedTick;
  if (gap > MAX_CATCHUP_TICKS) {
    // Fast-forward the skipped ticks deterministically using a step size
    // that keeps total computation under MAX_COMPUTE_TICKS iterations
    const skipTo = targetTick - MAX_CATCHUP_TICKS;
    const skipGap = skipTo - lastComputedTick;
    const step = Math.max(1, Math.ceil(skipGap / MAX_COMPUTE_TICKS));
    for (let t = lastComputedTick + step; t <= skipTo; t += step) {
      STOCK_DEFS.forEach(s => {
        const h = hashTicker(s.ticker);
        const r = getTickRandom(h, t);
        const price = stockPrices[s.ticker];
        const change = price * s.volatility * (r * 2 - 1) * step;
        const reversion = (s.basePrice - price) * 0.0015 * step;
        const driftAmt = price * s.drift * step;
        let newPrice = price + change + reversion + driftAmt;
        newPrice = Math.max(s.basePrice * 0.05, newPrice);
        stockPrices[s.ticker] = Math.round(newPrice * 10000) / 10000;
      });
    }
    lastComputedTick = skipTo;
    STOCK_DEFS.forEach(s => { stockPriceHistory[s.ticker] = []; });
  }

  const startTick = lastComputedTick;
  // Record old prices for offline message
  const oldPrices = {};
  STOCK_DEFS.forEach(s => { oldPrices[s.ticker] = stockPrices[s.ticker]; });

  for (let t = startTick + 1; t <= targetTick; t++) {
    STOCK_DEFS.forEach(s => {
      const h = hashTicker(s.ticker);
      const r = getTickRandom(h, t); // deterministic 0..1
      const price = stockPrices[s.ticker];
      const change = price * s.volatility * (r * 2 - 1);
      const reversion = (s.basePrice - price) * 0.0015;
      const driftAmt = price * s.drift;
      let newPrice = price + change + reversion + driftAmt;
      newPrice = Math.max(s.basePrice * 0.05, newPrice); // floor at 5% of base
      stockPrices[s.ticker] = Math.round(newPrice * 10000) / 10000;
    });

    // Record history every ~5 ticks (or always for last 500)
    const remaining = targetTick - t;
    if (remaining < 500 || t % 5 === 0) {
      STOCK_DEFS.forEach(s => {
        const hist = stockPriceHistory[s.ticker];
        hist.push(stockPrices[s.ticker]);
        if (hist.length > 500) hist.shift();
      });
    }
  }

  const ticksAdvanced = targetTick - startTick;
  lastComputedTick = targetTick;

  // Show offline catchup message if significant
  if (ticksAdvanced > 10) {
    const elapsed = ticksAdvanced * TICK_MS;
    const mins = Math.floor(elapsed / 60000);
    const hours = Math.floor(mins / 60);
    const days = Math.floor(hours / 24);
    let timeStr = '';
    if (days > 0) timeStr = days + 'd ' + (hours % 24) + 'h';
    else if (hours > 0) timeStr = hours + 'h ' + (mins % 60) + 'm';
    else timeStr = mins + 'm';

    // Show price changes
    let biggestMove = '', biggestPct = 0;
    STOCK_DEFS.forEach(s => {
      const pct = Math.abs((stockPrices[s.ticker] - oldPrices[s.ticker]) / oldPrices[s.ticker] * 100);
      if (pct > biggestPct) { biggestPct = pct; biggestMove = s.ticker; }
    });
    const moveDir = stockPrices[biggestMove] > oldPrices[biggestMove] ? '📈' : '📉';
    const msg = moveDir + ' ' + biggestMove + ' moved ' + biggestPct.toFixed(1) + '% while you were away';

    setTimeout(() => { showToast(msg, biggestPct > 0); }, 500);
  }
}

function startStockTicker() {
  if (stockTickInterval) return;
  stockTickInterval = setInterval(() => {
    const now = getCurrentTick();
    if (now > lastComputedTick) {
      advanceToTick(now);
      if (document.querySelector('#stocksPanel.active')) renderStocks();
      // Auto-save periodically to keep tick state fresh
    }
  }, 1000); // check every second for smoother updates
}

function buyStock(ticker) {
  const amt = parseFloat(document.getElementById('stockBuyAmt').value) || 100;
  if (amt > balance) { showToast('Not enough balance!', false); return; }
  if (amt <= 0) return;

  const price = stockPrices[ticker];
  const shares = amt / price;

  balance -= amt;
  updateBalDisplay();

  if (!stockHoldings[ticker]) {
    stockHoldings[ticker] = { shares: 0, totalCost: 0 };
  }
  stockHoldings[ticker].shares += shares;
  stockHoldings[ticker].totalCost += amt;

  playClickSound();
  showToast('Bought ' + shares.toFixed(4) + ' ' + ticker + ' @ $' + formatStockPrice(price));
  renderStocks();
  firebaseSave();
}

function sellStock(ticker) {
  if (!stockHoldings[ticker] || stockHoldings[ticker].shares <= 0) return;

  const holding = stockHoldings[ticker];
  const price = stockPrices[ticker];
  const value = holding.shares * price;
  const profit = value - holding.totalCost;

  balance += value;
  updateBalDisplay();

  if (profit >= 0) {
    showToast('Sold ' + ticker + ' +$' + profit.toFixed(2) + '!');
    playWinSound();
    spawnParticles(window.innerWidth / 2, window.innerHeight / 2, 20 + Math.min(profit / 10, 60));
  } else {
    showToast('Sold ' + ticker + ' -$' + Math.abs(profit).toFixed(2), false);
    playLoseSound();
  }

  delete stockHoldings[ticker];
  renderStocks();
  firebaseSave();
}

let selectedStock = 'GMBL';

function selectStock(ticker) {
  selectedStock = ticker;
  renderStocks();
}

function renderStocks() {
  if (!stocksInitialized) initStocks();

  // Render ticker bar
  const tickerBar = document.getElementById('stockTickerBar');
  if (tickerBar) {
    tickerBar.innerHTML = STOCK_DEFS.map(s => {
      const price = stockPrices[s.ticker];
      const hist = stockPriceHistory[s.ticker] || [price];
      const prev = hist.length > 1 ? hist[hist.length - 2] : price;
      const isUp = price >= prev;
      const pct = prev ? ((price - prev) / prev * 100).toFixed(1) : '0.0';
      const active = s.ticker === selectedStock;
      const hasPos = stockHoldings[s.ticker] && stockHoldings[s.ticker].shares > 0;
      return `<div onclick="selectStock('${s.ticker}')" style="
        flex:0 0 auto;padding:6px 12px;border-radius:8px;cursor:pointer;text-align:center;font-family:'Orbitron';
        background:${active ? 'linear-gradient(135deg,rgba(0,255,136,0.15),rgba(0,255,136,0.05))' : 'var(--bg)'};
        border:1px solid ${active ? 'var(--neon)' : 'var(--border)'};transition:all 0.2s;position:relative;
      ">
        ${hasPos ? '<div style="position:absolute;top:2px;right:4px;width:6px;height:6px;background:var(--gold);border-radius:50%;"></div>' : ''}
        <div style="font-size:11px;font-weight:700;color:${active?'var(--neon)':'var(--text)'};">$${s.ticker}</div>
        <div style="font-size:9px;color:${isUp?'#3fb950':'#f85149'};">${isUp?'▲':'▼'}${pct}%</div>
      </div>`;
    }).join('');
  }

  const s = STOCK_DEFS.find(x => x.ticker === selectedStock) || STOCK_DEFS[0];
  const price = stockPrices[s.ticker];
  const hist = stockPriceHistory[s.ticker] || [price];
  const prev = hist.length > 1 ? hist[hist.length - 2] : price;
  const isUp = price >= prev;
  const changePct = prev ? ((price - prev) / prev * 100).toFixed(2) : '0.00';
  const holding = stockHoldings[s.ticker];
  const hasHolding = holding && holding.shares > 0;

  // Update hero
  document.getElementById('stockTickerLabel').textContent = '$' + s.ticker;
  document.getElementById('stockNameLabel').textContent = s.name;
  document.getElementById('stockPriceDisplay').textContent = '$' + formatStockPrice(price);
  const changeEl = document.getElementById('stockChangeDisplay');
  const firstPrice = hist[0] || price;
  const totalChangePct = ((price - firstPrice) / firstPrice * 100).toFixed(2);
  const tickChangePct = changePct;
  changeEl.innerHTML = (isUp ? '▲' : '▼') + ' ' + tickChangePct + '% <span style="color:#8b949e;font-size:12px;">tick</span> &nbsp; ' +
    (price >= firstPrice ? '▲' : '▼') + ' ' + totalChangePct + '% <span style="color:#8b949e;font-size:12px;">session</span>';
  changeEl.className = 'sh-change ' + (isUp ? 'up' : 'down');

  // Update bottom bar
  if (hasHolding) {
    const curVal = holding.shares * price;
    const pnl = curVal - holding.totalCost;
    document.getElementById('stockShares').textContent = holding.shares.toFixed(4);
    document.getElementById('stockValue').textContent = '$' + curVal.toFixed(2);
    const pnlEl = document.getElementById('stockPnl');
    pnlEl.textContent = (pnl >= 0 ? '+' : '') + '$' + pnl.toFixed(2);
    pnlEl.style.color = pnl >= 0 ? '#3fb950' : '#f85149';
  } else {
    document.getElementById('stockShares').textContent = '0';
    document.getElementById('stockValue').textContent = '$0';
    const pnlEl = document.getElementById('stockPnl');
    pnlEl.textContent = '$0';
    pnlEl.style.color = '#8b949e';
  }
  document.getElementById('stockSellBtn').disabled = !hasHolding;

  // Draw the BIG chart
  drawStockChart(hist);

  // Render portfolio overview for all holdings
  const overviewDiv = document.getElementById('stockPortfolioOverview');
  if (overviewDiv) {
    const activePositions = STOCK_DEFS.filter(sd => stockHoldings[sd.ticker] && stockHoldings[sd.ticker].shares > 0);
    if (activePositions.length === 0) {
      overviewDiv.innerHTML = '<div style="text-align:center;font-size:11px;color:var(--text2);padding:8px;">No open positions</div>';
    } else {
      let totalValue = 0, totalCost = 0;
      const rows = activePositions.map(sd => {
        const h = stockHoldings[sd.ticker];
        const p = stockPrices[sd.ticker];
        const val = h.shares * p;
        const pnl = val - h.totalCost;
        totalValue += val;
        totalCost += h.totalCost;
        const pnlColor = pnl >= 0 ? '#3fb950' : '#f85149';
        return `<div style="display:flex;align-items:center;gap:8px;padding:6px 8px;background:var(--bg);border-radius:6px;border:1px solid var(--border);">
          <span style="font-family:'Orbitron';font-size:11px;font-weight:700;color:var(--neon);min-width:45px;">$${sd.ticker}</span>
          <span style="font-size:10px;color:var(--text2);flex:1;">${h.shares.toFixed(2)} shares</span>
          <span style="font-size:11px;color:var(--text);font-weight:600;">$${val.toFixed(0)}</span>
          <span style="font-size:10px;font-weight:700;color:${pnlColor};min-width:50px;text-align:right;">${pnl>=0?'+':''}$${pnl.toFixed(0)}</span>
        </div>`;
      }).join('');
      const totalPnl = totalValue - totalCost;
      overviewDiv.innerHTML = `
        <div style="font-size:10px;color:var(--text2);font-weight:600;letter-spacing:1px;margin-bottom:6px;">PORTFOLIO</div>
        <div style="display:flex;flex-direction:column;gap:4px;">${rows}</div>
        <div style="display:flex;justify-content:space-between;padding:6px 8px;margin-top:4px;background:rgba(0,255,136,0.05);border-radius:6px;border:1px solid var(--neon)20;">
          <span style="font-size:11px;font-weight:700;color:var(--text);">Total: $${totalValue.toFixed(0)}</span>
          <span style="font-size:11px;font-weight:700;color:${totalPnl>=0?'#3fb950':'#f85149'};">${totalPnl>=0?'+':''}$${totalPnl.toFixed(0)}</span>
        </div>`;
    }
  }
}

function drawStockChart(hist) {
  const canvas = document.getElementById('stockChart');
  const wrap = canvas.parentElement;
  const dpr = window.devicePixelRatio || 1;
  canvas.width = wrap.clientWidth * dpr;
  canvas.height = wrap.clientHeight * dpr;
  canvas.style.width = wrap.clientWidth + 'px';
  canvas.style.height = wrap.clientHeight + 'px';
  const ctx = canvas.getContext('2d');
  ctx.scale(dpr, dpr);
  const W = wrap.clientWidth;
  const H = wrap.clientHeight;

  ctx.clearRect(0, 0, W, H);

  if (hist.length < 2) return;

  const pMin = Math.min(...hist);
  const pMax = Math.max(...hist);
  const pRange = pMax - pMin || 1;
  const pad = { top: 12, bottom: 20, left: 50, right: 12 };
  const cW = W - pad.left - pad.right;
  const cH = H - pad.top - pad.bottom;

  // Grid lines + price labels
  const gridLines = 4;
  ctx.strokeStyle = '#1e2933';
  ctx.lineWidth = 1;
  ctx.fillStyle = '#8b949e';
  ctx.font = '11px Orbitron, monospace';
  ctx.textAlign = 'right';
  for (let i = 0; i <= gridLines; i++) {
    const y = pad.top + (cH / gridLines) * i;
    const priceAtLine = pMax - (pRange / gridLines) * i;
    ctx.beginPath();
    ctx.moveTo(pad.left, y);
    ctx.lineTo(W - pad.right, y);
    ctx.stroke();
    ctx.fillText('$' + formatStockPrice(priceAtLine), pad.left - 6, y + 4);
  }

  // Build points
  const points = [];
  for (let i = 0; i < hist.length; i++) {
    const x = pad.left + (i / (hist.length - 1)) * cW;
    const y = pad.top + (1 - (hist[i] - pMin) / pRange) * cH;
    points.push({ x, y });
  }

  const isUpOverall = hist[hist.length - 1] >= hist[0];
  const lineColor = isUpOverall ? '#3fb950' : '#f85149';
  const fillColor = isUpOverall ? 'rgba(63,185,80,' : 'rgba(248,81,73,';

  // Gradient fill under line
  const grad = ctx.createLinearGradient(0, pad.top, 0, H - pad.bottom);
  grad.addColorStop(0, fillColor + '0.35)');
  grad.addColorStop(1, fillColor + '0.0)');

  ctx.beginPath();
  ctx.moveTo(points[0].x, H - pad.bottom);
  points.forEach(p => ctx.lineTo(p.x, p.y));
  ctx.lineTo(points[points.length - 1].x, H - pad.bottom);
  ctx.closePath();
  ctx.fillStyle = grad;
  ctx.fill();

  // Line
  ctx.beginPath();
  points.forEach((p, i) => i === 0 ? ctx.moveTo(p.x, p.y) : ctx.lineTo(p.x, p.y));
  ctx.strokeStyle = lineColor;
  ctx.lineWidth = 2;
  ctx.lineJoin = 'round';
  ctx.stroke();

  // Current price dot (pulsing)
  const last = points[points.length - 1];
  ctx.beginPath();
  ctx.arc(last.x, last.y, 5, 0, Math.PI * 2);
  ctx.fillStyle = lineColor;
  ctx.fill();
  ctx.beginPath();
  ctx.arc(last.x, last.y, 8, 0, Math.PI * 2);
  ctx.strokeStyle = lineColor;
  ctx.lineWidth = 1.5;
  ctx.globalAlpha = 0.4;
  ctx.stroke();
  ctx.globalAlpha = 1;
}

function formatStockPrice(p) {
  if (p >= 1000) return p.toFixed(0);
  if (p >= 1) return p.toFixed(2);
  return p.toFixed(4);
}

// Save/Load stocks to/from Firebase
window._getStocksData = () => {
  if (!stocksInitialized && Object.keys(stockHoldings).length === 0) return null;
  return {
    prices: stockPrices,
    holdings: stockHoldings,
    lastTick: lastComputedTick // save the tick NUMBER, not timestamp
  };
};

window._loadStocks = (data) => {
  if (!data) return;

  // Restore prices from saved state
  if (data.prices) {
    stockPrices = data.prices;
    STOCK_DEFS.forEach(s => {
      if (!stockPrices[s.ticker]) stockPrices[s.ticker] = s.basePrice;
      stockPriceHistory[s.ticker] = [stockPrices[s.ticker]];
    });
  }

  // Restore holdings
  if (data.holdings) stockHoldings = data.holdings;

  // Restore tick position — then advanceToTick will deterministically
  // compute all ticks that happened while offline
  if (data.lastTick) {
    lastComputedTick = data.lastTick;
  }

  stocksInitialized = true;

  // Advance to current real time (deterministic catchup)
  advanceToTick(getCurrentTick());

  // Start live ticker
  startStockTicker();
};

// ============ CARD UTILS ============
const CARD_SUITS=['♠','♥','♦','♣'];const CARD_RANKS=['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
function newDeck(){let d=[];CARD_SUITS.forEach(s=>CARD_RANKS.forEach(r=>d.push({r,s})));for(let i=d.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[d[i],d[j]]=[d[j],d[i]];}return d;}
function cardNumVal(c){if(c.r==='A')return 11;if('KQJ'.includes(c.r))return 10;return parseInt(c.r);}
function cardIsRed(c){return c.s==='♥'||c.s==='♦';}
function renderCard(c,hidden){if(hidden)return'<div class="bj-card hidden">?</div>';return'<div class="bj-card'+(cardIsRed(c)?' red':'')+'">'+c.r+'<br>'+c.s+'</div>';}
function cardRankIdx(c){return CARD_RANKS.indexOf(c.r);}

// ============ BLACKJACK ============
let bjDeck=[],bjPlayer=[],bjDealer=[],bjBetAmt=0,bjActive=false;
function bjDrawCard(){if(bjDeck.length<10)bjDeck=bjDeck.concat(newDeck());return bjDeck.pop();}
function bjHandVal(h){let v=0,a=0;h.forEach(c=>{v+=cardNumVal(c);if(c.r==='A')a++;});while(v>21&&a>0){v-=10;a--;}return v;}
function bjDeal(){
  if(bjActive)return;const bet=parseFloat(document.getElementById('bjBet').value)||10;if(bet<=0)return;
  if(!checkMaxBet(bet,'Blackjack'))return;
  if(bet>balance){showToast('Not enough balance!',false);return;}
  bjBetAmt=bet;balance-=bet;updateBalDisplay();bjDeck=newDeck();bjPlayer=[bjDrawCard(),bjDrawCard()];bjDealer=[bjDrawCard(),bjDrawCard()];bjActive=true;bjRender();
  document.getElementById('bjResult').textContent='';
  if(bjHandVal(bjPlayer)===21)bjStand();playClickSound();
}
function bjHit(){if(!bjActive)return;bjPlayer.push(bjDrawCard());if(bjHandVal(bjPlayer)>21){bjActive=false;bjRender();bjFinish();}else if(bjHandVal(bjPlayer)===21)bjStand();else bjRender();}
function bjStand(){if(!bjActive)return;while(bjHandVal(bjDealer)<17)bjDealer.push(bjDrawCard());bjActive=false;bjRender();bjFinish();}
function bjDouble(){if(!bjActive||bjPlayer.length!==2)return;if(!checkMaxBet(bjBetAmt*2,'Blackjack'))return;if(bjBetAmt>balance){showToast('Not enough balance to double!',false);return;}balance-=bjBetAmt;bjBetAmt*=2;updateBalDisplay();bjPlayer.push(bjDrawCard());while(bjHandVal(bjDealer)<17)bjDealer.push(bjDrawCard());bjActive=false;bjRender();bjFinish();}
function bjFinish(){
  const pv=bjHandVal(bjPlayer),dv=bjHandVal(bjDealer);let w=0,msg='';
  const isNatural=bjPlayer.length===2&&pv===21;
  const dealerNatural=bjDealer.length===2&&dv===21;
  if(pv>21){msg='BUST!';showToast('-$'+bjBetAmt.toFixed(2),false);playLoseSound();}
  else if(isNatural&&!dealerNatural){w=Math.round(bjBetAmt*2.5*100)/100;msg='BLACKJACK! +$'+w.toFixed(2);balance+=w;updateBalDisplay();showBigWin(w);showToast('BLACKJACK! +$'+w.toFixed(2));playWinSound();spawnParticles(window.innerWidth/2,window.innerHeight/2,40);}
  else if(dv>21||pv>dv){w=bjBetAmt*2;msg='WIN +$'+w.toFixed(2);balance+=w;updateBalDisplay();showBigWin(w);showToast('+$'+w.toFixed(2));playWinSound();spawnParticles(window.innerWidth/2,window.innerHeight/2,30);}
  else if(pv===dv){w=bjBetAmt;msg='PUSH';balance+=w;updateBalDisplay();showToast('Push');}
  else{msg='LOSE';showToast('-$'+bjBetAmt.toFixed(2),false);playLoseSound();}
  const r=document.getElementById('bjResult');r.textContent=msg;r.style.color=w>bjBetAmt?'var(--green)':w===bjBetAmt?'var(--gold)':'var(--red)';
  recordGame('blackjack',bjBetAmt,w);
}
function bjRender(){const s=!bjActive;document.getElementById('bjDealerCards').innerHTML=bjDealer.map((c,i)=>renderCard(c,!s&&i===1)).join('');document.getElementById('bjPlayerCards').innerHTML=bjPlayer.map(c=>renderCard(c)).join('');document.getElementById('bjDealerScore').textContent=s?bjHandVal(bjDealer):'?';document.getElementById('bjPlayerScore').textContent=bjHandVal(bjPlayer);document.getElementById('bjHitBtn').disabled=!bjActive;document.getElementById('bjStandBtn').disabled=!bjActive;document.getElementById('bjDoubleBtn').disabled=!bjActive||bjPlayer.length!==2;document.getElementById('bjDealBtn').disabled=bjActive;}

// ============ MINES ============
let minesBoard=[],minesRevealed=0,minesBetAmt=0,minesActive=false,minesCount=3;
function minesMultiplier(){const t=25,m=minesCount,r=minesRevealed;if(r===0)return 1;let mult=1;for(let i=0;i<r;i++)mult*=(t-m-i)>0?(t-i)/(t-m-i):t;return Math.round(mult*97)/100;}
function minesStart(){
  if(minesActive)return;const bet=parseFloat(document.getElementById('minesBet').value)||10;if(bet<=0)return;minesCount=parseInt(document.getElementById('mineCount').value);
  if(!minesCount||minesCount<1)minesCount=1;if(minesCount>24)minesCount=24;
  if(bet>balance){showToast('Not enough!',false);return;}
  if(!checkMaxBet(bet,'Mines'))return;
  minesBetAmt=bet;balance-=bet;updateBalDisplay();minesActive=true;minesRevealed=0;
  minesBoard=Array(25).fill(false);const pos=[];while(pos.length<minesCount){const p=Math.floor(Math.random()*25);if(!pos.includes(p))pos.push(p);}
  pos.forEach(p=>minesBoard[p]=true);minesRenderGrid();
  document.getElementById('minesStartBtn').style.display='none';document.getElementById('minesCashoutBtn').style.display='';
  document.getElementById('minesMultiplier').textContent='1.00×';document.getElementById('minesProfit').textContent='Next: $'+minesBetAmt.toFixed(2);playClickSound();
}
function minesCashout(){if(!minesActive||minesRevealed===0)return;const payout=minesBetAmt*minesMultiplier();balance+=payout;updateBalDisplay();
  showBigWin(payout);showToast('+$'+payout.toFixed(2));playWinSound();spawnParticles(window.innerWidth/2,window.innerHeight/2,30);
  minesActive=false;minesRevealAll();document.getElementById('minesStartBtn').style.display='';document.getElementById('minesCashoutBtn').style.display='none';
  recordGame('mines',minesBetAmt,payout);
}
function minesClick(i){if(!minesActive)return;const cells=document.querySelectorAll('.mine-cell');if(cells[i].classList.contains('revealed'))return;
  if(minesBoard[i]){cells[i].classList.add('revealed','mine');cells[i].textContent='💣';minesActive=false;
    showToast('-$'+minesBetAmt.toFixed(2),false);playLoseSound();minesRevealAll();
    document.getElementById('minesStartBtn').style.display='';document.getElementById('minesCashoutBtn').style.display='none';recordGame('mines',minesBetAmt,0);
  }else{cells[i].classList.add('revealed','safe');cells[i].textContent='💎';minesRevealed++;playSound(600+minesRevealed*40,'sine',.06,.06);
    const m=minesMultiplier();document.getElementById('minesMultiplier').textContent=m.toFixed(2)+'×';
    document.getElementById('minesProfit').textContent='Cash out: $'+(minesBetAmt*m).toFixed(2);if(minesRevealed===25-minesCount)minesCashout();
  }
}
function minesRevealAll(){const cells=document.querySelectorAll('.mine-cell');minesBoard.forEach((isMine,i)=>{if(!cells[i].classList.contains('revealed')){cells[i].classList.add('revealed',isMine?'mine':'safe');cells[i].textContent=isMine?'💣':'💎';}});}
function minesRenderGrid(){const g=document.getElementById('minesGrid');g.innerHTML='';for(let i=0;i<25;i++){const c=document.createElement('div');c.className='mine-cell';c.onclick=(()=>{const idx=i;return()=>minesClick(idx);})();g.appendChild(c);}}

// ============ DICE ============
let diceMode='over';
function diceSetMode(m){diceMode=m;document.getElementById('diceOverBtn').className='dice-mode-btn'+(m==='over'?' active':'');document.getElementById('diceUnderBtn').className='dice-mode-btn'+(m==='under'?' active':'');diceUpdateSlider();}
function diceUpdateSlider(){const v=Math.max(2,Math.min(98,parseFloat(document.getElementById('diceSlider').value)));const chance=diceMode==='over'?(100-v):v;const payout=chance>0?Math.min(Math.floor(99/chance*100)/100,9900):0;document.getElementById('diceTarget').textContent=v.toFixed(2);document.getElementById('diceChance').textContent=chance.toFixed(2)+'%';document.getElementById('dicePayout').textContent=payout.toFixed(2)+'×';
  const sl=document.getElementById('diceSlider');sl.style.background='linear-gradient(90deg,'+(diceMode==='over'?'var(--red)':'var(--green)')+' 0%,'+(diceMode==='over'?'var(--red)':'var(--green)')+' '+v+'%,'+(diceMode==='over'?'var(--green)':'var(--red)')+' '+v+'%,'+(diceMode==='over'?'var(--green)':'var(--red)')+' 100%)';}
function diceRoll(){const bet=parseFloat(document.getElementById('diceBet').value)||10;if(bet>balance){showToast('Not enough!',false);return;}if(bet<=0)return;
  if(!checkMaxBet(bet,'Dice'))return;
  balance-=bet;updateBalDisplay();let target=parseFloat(document.getElementById('diceSlider').value);target=Math.max(2,Math.min(98,target));const chance=diceMode==='over'?(100-target):target;const payout=chance>0?Math.min(Math.floor(99/chance*100)/100,9900):0;
  const roll=Math.random()*100;const won=diceMode==='over'?roll>target:roll<target;const display=document.getElementById('diceDisplay');
  display.textContent=roll.toFixed(2);display.style.color=won?'var(--green)':'var(--red)';
  if(won){const w=bet*payout;balance+=w;updateBalDisplay();showBigWin(w);showToast('+$'+w.toFixed(2));playWinSound();spawnParticles(window.innerWidth/2,window.innerHeight/2,25);recordGame('dice',bet,w);}
  else{showToast('-$'+bet.toFixed(2),false);playLoseSound();recordGame('dice',bet,0);}playClickSound();
}

// ============ TOWER ============
let towerBoard=[],towerRow=0,towerBetAmt=0,towerActive=false,towerCols=3,towerRows=8,towerSafePerRow=2;
function towerMultiplier(){if(towerRow===0)return 1;let m=1;for(let i=0;i<towerRow;i++)m*=towerCols/towerSafePerRow;return Math.round(m*97)/100;}
function towerStart(){
  if(towerActive)return;const bet=parseFloat(document.getElementById('towerBet').value)||10;if(bet<=0)return;if(bet>balance){showToast('Not enough!',false);return;}
  if(!checkMaxBet(bet,'Tower'))return;
  const diff=document.getElementById('towerDiff').value;
  if(diff==='easy'){towerCols=4;towerSafePerRow=3;}else if(diff==='medium'){towerCols=3;towerSafePerRow=2;}else if(diff==='hard'){towerCols=4;towerSafePerRow=2;}else{towerCols=4;towerSafePerRow=1;}
  towerBetAmt=bet;balance-=bet;updateBalDisplay();towerActive=true;towerRow=0;towerRows=8;
  towerBoard=[];for(let r=0;r<towerRows;r++){const row=Array(towerCols).fill(true);const traps=towerCols-towerSafePerRow;const trapPos=[];while(trapPos.length<traps){const p=Math.floor(Math.random()*towerCols);if(!trapPos.includes(p))trapPos.push(p);}trapPos.forEach(p=>row[p]=false);towerBoard.push(row);}
  towerRender();document.getElementById('towerStartBtn').style.display='none';document.getElementById('towerCashoutBtn').style.display='';
  document.getElementById('towerInfo').innerHTML='Floor <span style="color:var(--neon)">1</span> — Pick a tile!';playClickSound();
}
function towerCashout(){if(!towerActive||towerRow===0)return;const p=towerBetAmt*towerMultiplier();balance+=p;updateBalDisplay();
  showBigWin(p);showToast('+$'+p.toFixed(2));playWinSound();spawnParticles(window.innerWidth/2,window.innerHeight/2,30);
  towerActive=false;towerRevealAll();document.getElementById('towerStartBtn').style.display='';document.getElementById('towerCashoutBtn').style.display='none';
  document.getElementById('towerInfo').textContent='Cashed out at '+towerMultiplier().toFixed(2)+'× — $'+p.toFixed(2);recordGame('tower',towerBetAmt,p);
}
function towerClick(r,c){if(!towerActive||r!==towerRow)return;
  const rowEl=document.querySelectorAll('.tower-row')[towerRows-1-r];
  if(towerBoard[r][c]){towerRow++;rowEl.children[c].classList.add('revealed','safe');rowEl.children[c].textContent='✅';
    playSound(400+towerRow*60,'sine',.08,.06);const m=towerMultiplier();
    document.getElementById('towerInfo').innerHTML='Floor <span style="color:var(--neon)">'+(towerRow+1)+'</span> — '+m.toFixed(2)+'× ($'+(towerBetAmt*m).toFixed(2)+')';
    if(towerRow>=towerRows)towerCashout();else towerRender();
  }else{rowEl.children[c].classList.add('revealed','trap');rowEl.children[c].textContent='💀';
    towerActive=false;showToast('-$'+towerBetAmt.toFixed(2),false);playLoseSound();towerRevealAll();
    document.getElementById('towerStartBtn').style.display='';document.getElementById('towerCashoutBtn').style.display='none';
    document.getElementById('towerInfo').textContent='Hit a trap! Lost $'+towerBetAmt.toFixed(2);recordGame('tower',towerBetAmt,0);
  }
}
function towerRevealAll(){document.querySelectorAll('.tower-row').forEach((row,ri)=>{const actualRow=towerRows-1-ri;[...row.children].forEach((c,ci)=>{if(!c.classList.contains('revealed')){c.classList.add('revealed',towerBoard[actualRow][ci]?'safe':'trap');c.textContent=towerBoard[actualRow][ci]?'✅':'💀';}});});}
function towerRender(){const g=document.getElementById('towerGrid');g.innerHTML='';for(let r=towerRows-1;r>=0;r--){const row=document.createElement('div');row.className='tower-row';for(let c=0;c<towerCols;c++){const cell=document.createElement('div');cell.className='tower-cell';if(r===towerRow&&towerActive)cell.classList.add('current-row');else if(r>towerRow)cell.classList.add('locked');cell.onclick=(()=>{const rr=r,cc=c;return()=>towerClick(rr,cc);})();row.appendChild(cell);}g.appendChild(row);}}

// ============ COIN FLIP ============
let coinChoice='heads',coinFlipping=false;
function coinSelect(c){coinChoice=c;document.getElementById('coinHeads').className='coin-choice'+(c==='heads'?' selected':'');document.getElementById('coinTails').className='coin-choice'+(c==='tails'?' selected':'');playClickSound();}
function coinFlip(){if(coinFlipping)return;const bet=parseFloat(document.getElementById('coinBet').value)||10;if(bet<=0)return;if(bet>balance){showToast('Not enough!',false);return;}
  if(!checkMaxBet(bet,'Coinflip'))return;
  coinFlipping=true;balance-=bet;updateBalDisplay();document.getElementById('coinFlipBtn').disabled=true;document.getElementById('coinResult').textContent='';
  const coin=document.getElementById('coinDisplay');coin.classList.remove('flip');void coin.offsetWidth;coin.classList.add('flip');playClickSound();
  const result=Math.random()<0.5?'heads':'tails';
  setTimeout(()=>{coin.textContent=result==='heads'?'👑':'🦅';const won=result===coinChoice;
    if(won){const w=bet*1.96;balance+=w;updateBalDisplay();showBigWin(w);showToast('+$'+w.toFixed(2));playWinSound();spawnParticles(window.innerWidth/2,window.innerHeight/2,25);
      document.getElementById('coinResult').innerHTML='<span style="color:var(--green)">'+result.toUpperCase()+' — WIN!</span>';recordGame('coinflip',bet,w);}
    else{showToast('-$'+bet.toFixed(2),false);playLoseSound();document.getElementById('coinResult').innerHTML='<span style="color:var(--red)">'+result.toUpperCase()+' — LOSE</span>';recordGame('coinflip',bet,0);}
    coinFlipping=false;document.getElementById('coinFlipBtn').disabled=false;},800);
}

// ============ KENO ============
let kenoSelected=new Set(),kenoPlaying=false;
const KENO_PAYOUTS={1:[0,2.5],2:[0,1,5],3:[0,0,2,25],4:[0,0,1,5,50],5:[0,0,.5,3,15,100],6:[0,0,0,2,5,30,200],7:[0,0,0,1,3,10,50,400],8:[0,0,0,.5,2,8,25,100,500],9:[0,0,0,0,1,5,15,50,200,1000],10:[0,0,0,0,.5,3,10,25,100,500,2000]};
function kenoInit(){const g=document.getElementById('kenoGrid');if(!g)return;g.innerHTML='';for(let i=1;i<=40;i++){const c=document.createElement('div');c.className='keno-num';c.textContent=i;c.onclick=(()=>{const n=i;return()=>kenoToggle(n);})();g.appendChild(c);}}
function kenoToggle(n){if(kenoPlaying)return;const cells=document.querySelectorAll('.keno-num');if(kenoSelected.has(n)){kenoSelected.delete(n);cells[n-1].classList.remove('selected');}else{if(kenoSelected.size>=10){showToast('Max 10!',false);return;}kenoSelected.add(n);cells[n-1].classList.add('selected');}document.getElementById('kenoInfo').textContent=kenoSelected.size+'/10 selected';playClickSound();}
function kenoClear(){if(kenoPlaying)return;kenoSelected.clear();document.querySelectorAll('.keno-num').forEach(c=>{c.className='keno-num';});document.getElementById('kenoInfo').textContent='Pick up to 10 numbers';document.getElementById('kenoResult').textContent='';}
function kenoDraw(){if(kenoPlaying||kenoSelected.size===0)return;const bet=parseFloat(document.getElementById('kenoBet').value)||10;if(bet<=0)return;if(bet>balance){showToast('Not enough!',false);return;}
  if(!checkMaxBet(bet,'Keno'))return;
  kenoPlaying=true;balance-=bet;updateBalDisplay();document.getElementById('kenoDrawBtn').disabled=true;
  const drawn=new Set();while(drawn.size<10){drawn.add(Math.floor(Math.random()*40)+1);}
  const cells=document.querySelectorAll('.keno-num');let hits=0;const drawnArr=[...drawn];let idx=0;
  const revealInterval=setInterval(()=>{if(idx>=drawnArr.length){clearInterval(revealInterval);
    const picks=kenoSelected.size;const payTable=KENO_PAYOUTS[picks];const mult=payTable&&payTable[hits]?payTable[hits]:0;const payout=bet*mult;
    cells.forEach((c,i)=>{if(!drawn.has(i+1)&&!kenoSelected.has(i+1))c.classList.add('miss');});
    if(payout>0){balance+=payout;updateBalDisplay();showBigWin(payout);showToast(hits+' hits! +$'+payout.toFixed(2));playWinSound();spawnParticles(window.innerWidth/2,window.innerHeight/2,20+hits*10);
      document.getElementById('kenoResult').innerHTML='<span style="color:var(--green)">'+hits+' HITS — '+mult+'× — +$'+payout.toFixed(2)+'</span>';}
    else{showToast(hits+' hits — no win',false);playLoseSound();document.getElementById('kenoResult').innerHTML='<span style="color:var(--red)">'+hits+' hits — no win</span>';}
    recordGame('keno',bet,payout);kenoPlaying=false;document.getElementById('kenoDrawBtn').disabled=false;return;}
    const n=drawnArr[idx];cells[n-1].classList.add('drawn');if(kenoSelected.has(n)){cells[n-1].classList.add('hit');hits++;playSound(600+hits*80,'sine',.06,.06);}else{playSound(300,'sine',.03,.02);}idx++;
  },200);
}

// ============ LIMBO ============
let limboRolling=false;
function limboUpdateInfo(){const t=parseFloat(document.getElementById('limboTarget').value)||2;const chance=Math.min(99,(99/t));document.getElementById('limboPayout').textContent='Win chance: '+chance.toFixed(2)+'% — Payout: '+t.toFixed(2)+'×';}
function limboGo(){if(limboRolling)return;const bet=parseFloat(document.getElementById('limboBet').value)||10;if(bet<=0)return;let target=parseFloat(document.getElementById('limboTarget').value)||2;target=Math.max(1.01,Math.min(1000,target));
  if(bet>balance){showToast('Not enough!',false);return;}if(target<1.01){showToast('Min target 1.01×',false);return;}
  if(!checkMaxBet(bet,'Limbo'))return;
  limboRolling=true;balance-=bet;updateBalDisplay();document.getElementById('limboGoBtn').disabled=true;
  const result=Math.min(10000,0.99/(1-Math.random()));const display=document.getElementById('limboResult');const limboBar=document.getElementById('limboBar');
  let cur=1;const step=Math.max(0.01,(result-1)/20);
  const anim=setInterval(()=>{cur+=step;if(cur>=result){cur=result;clearInterval(anim);
    display.textContent=Math.max(1,result).toFixed(2)+'×';const won=result>=target;
    display.style.color=won?'var(--green)':'var(--red)';
    if(limboBar){const pct=Math.min(100,(result/Math.max(target,2))*100);limboBar.style.width=pct+'%';limboBar.style.background=won?'var(--green)':'var(--red)';limboBar.style.boxShadow=won?'0 0 15px var(--green)':'0 0 15px var(--red)';}
    if(won){const w=bet*target;balance+=w;updateBalDisplay();showBigWin(w);showToast('+$'+w.toFixed(2));playWinSound();spawnParticles(window.innerWidth/2,window.innerHeight/2,25);recordGame('limbo',bet,w);addResultDot('limboHistory',target.toFixed(1)+'×',true);}
    else{showToast('-$'+bet.toFixed(2),false);playLoseSound();recordGame('limbo',bet,0);addResultDot('limboHistory',result.toFixed(1)+'×',false);}
    limboRolling=false;document.getElementById('limboGoBtn').disabled=false;}
  else{display.textContent=cur.toFixed(2)+'×';display.style.color='var(--neon)';if(limboBar){const pct=Math.min(100,(cur/Math.max(target,2))*100);limboBar.style.width=pct+'%';limboBar.style.background=cur>=target?'var(--green)':'var(--neon)';limboBar.style.transition='width 0.05s';}playSound(400+cur*30,'sine',.02,.015);}},50);
}

// ============ VIDEO POKER ============
let pokerDeckArr=[],pokerHandArr=[],pokerHeld=[],pokerBetAmt=0,pokerPhase='idle';
function pokerDeal(){
  if(pokerPhase==='hold'){pokerDrawCards();return;}
  const bet=parseFloat(document.getElementById('pokerBet').value)||10;if(bet<=0)return;if(bet>balance){showToast('Not enough!',false);return;}
  if(!checkMaxBet(bet,'Poker'))return;
  pokerBetAmt=bet;balance-=bet;updateBalDisplay();pokerDeckArr=newDeck();pokerHandArr=[];pokerHeld=Array(5).fill(false);
  for(let i=0;i<5;i++)pokerHandArr.push(pokerDeckArr.pop());pokerPhase='hold';pokerRender();
  document.getElementById('pokerDealBtn').textContent='DRAW';document.getElementById('pokerResult').textContent='Click cards to hold, then DRAW';playClickSound();
}
function pokerDrawCards(){for(let i=0;i<5;i++){if(!pokerHeld[i])pokerHandArr[i]=pokerDeckArr.pop();}pokerPhase='done';pokerRender();
  const result=pokerEvaluate();const mult=result.mult;const payout=pokerBetAmt*mult;
  if(payout>0){balance+=payout;updateBalDisplay();showBigWin(payout);showToast(result.name+' +$'+payout.toFixed(2));playWinSound();spawnParticles(window.innerWidth/2,window.innerHeight/2,20+mult*5);
    document.getElementById('pokerResult').innerHTML='<span style="color:var(--green)">'+result.name+' — '+mult+'× — +$'+payout.toFixed(2)+'</span>';}
  else{showToast('No win',false);playLoseSound();document.getElementById('pokerResult').innerHTML='<span style="color:var(--red)">No winning hand</span>';}
  recordGame('poker',pokerBetAmt,payout);document.getElementById('pokerDealBtn').textContent='DEAL';pokerPhase='idle';
}
function pokerToggleHold(i){if(pokerPhase!=='hold')return;pokerHeld[i]=!pokerHeld[i];pokerRender();playClickSound();}
function pokerRender(){const h=document.getElementById('pokerHand');h.innerHTML='';pokerHandArr.forEach((c,i)=>{const el=document.createElement('div');el.className='poker-card'+(cardIsRed(c)?' red':'')+(pokerHeld[i]?' held':'');el.innerHTML=c.r+'<div class="card-suit" style="font-size:24px;margin-top:4px;">'+c.s+'</div>'+(pokerHeld[i]?'<div class="held-tag">HELD</div>':'');el.onclick=()=>pokerToggleHold(i);el.style.opacity='0';el.style.transform='translateY(20px) scale(0.8)';el.style.transition='all 0.3s ease '+(i*0.08)+'s';h.appendChild(el);requestAnimationFrame(()=>{el.style.opacity='1';el.style.transform=pokerHeld[i]?'translateY(-10px) scale(1)':'translateY(0) scale(1)';});});}
function pokerEvaluate(){const h=pokerHandArr;const ranks=h.map(c=>cardRankIdx(c)).sort((a,b)=>a-b);const suits=h.map(c=>c.s);
  const isFlush=suits.every(s=>s===suits[0]);const counts={};ranks.forEach(r=>{counts[r]=(counts[r]||0)+1;});const vals=Object.values(counts).sort((a,b)=>b-a);
  const isStraight=(ranks[4]-ranks[0]===4&&new Set(ranks).size===5)||(JSON.stringify(ranks)==='[0,9,10,11,12]');
  const isRoyal=isStraight&&isFlush&&ranks[0]===0&&ranks[1]===9;
  if(isRoyal)return{name:'Royal Flush',mult:250};if(isStraight&&isFlush)return{name:'Straight Flush',mult:50};
  if(vals[0]===4)return{name:'Four of a Kind',mult:25};if(vals[0]===3&&vals[1]===2)return{name:'Full House',mult:9};
  if(isFlush)return{name:'Flush',mult:6};if(isStraight)return{name:'Straight',mult:4};
  if(vals[0]===3)return{name:'Three of a Kind',mult:3};if(vals[0]===2&&vals[1]===2)return{name:'Two Pair',mult:2};
  if(vals[0]===2){const pairRank=parseInt(Object.keys(counts).find(k=>counts[k]===2));if(pairRank>=10||pairRank===0)return{name:'Jacks or Better',mult:1};}
  return{name:'No Win',mult:0};
}
function scratchRevealAll(){if(!scratchActive)return;const cells=document.querySelectorAll('.scratch-cell');let delay=0;cells.forEach((c,i)=>{if(!c.classList.contains('revealed')){setTimeout(()=>scratchReveal(i),delay);delay+=80;}});}

// ============ HORSE RACING ============
const HORSES=[{name:'Thunder',emoji:'🐎',color:'#ff4444'},{name:'Lightning',emoji:'🏇',color:'#ffaa00'},{name:'Shadow',emoji:'🐴',color:'#8844ff'},{name:'Spirit',emoji:'🦄',color:'#44aaff'},{name:'Blaze',emoji:'🐎',color:'#44ff44'}];
let horseSelected=-1,horseRacing=false;
function horseInit(){const t=document.getElementById('horseTrack');const b=document.getElementById('horseBets');if(!t||!b)return;t.innerHTML='';b.innerHTML='';
  HORSES.forEach((h,i)=>{t.innerHTML+='<div class="horse-lane"><div class="horse-name" style="color:'+h.color+'">'+h.emoji+' '+h.name+'</div><div class="horse-bar"><div class="horse-progress" id="hp'+i+'" style="width:0%;background:'+h.color+';opacity:.6;"></div><div class="horse-emoji" id="he'+i+'" style="left:0%;">'+h.emoji+'</div></div><div class="horse-odds" id="ho'+i+'"></div></div>';
    b.innerHTML+='<button class="horse-bet" onclick="horseSelect('+i+',this)">'+h.emoji+' '+h.name+'</button>';});horseSetOdds();}
function horseSetOdds(){
  // Generate odds display only (speeds are regenerated fresh each race)
  const demoWeights=HORSES.map(()=>1+Math.random()*3);
  const totalW=demoWeights.reduce((s,w)=>s+w,0);
  HORSES.forEach((_,i)=>{
    const winProb=demoWeights[i]/totalW;
    const odds=Math.max(1.2,(0.95/winProb)).toFixed(1); // ~95% RTP
    document.getElementById('ho'+i).textContent=odds+'×';
    document.getElementById('ho'+i).dataset.odds=odds;
  });
}
function horseSelect(i,btn){horseSelected=i;document.querySelectorAll('.horse-bet').forEach(b=>b.classList.remove('selected'));if(btn)btn.classList.add('selected');playClickSound();}
function horseRace(){if(horseRacing||horseSelected<0){if(horseSelected<0)showToast('Pick a horse!',false);return;}
  const bet=parseFloat(document.getElementById('horseBet').value)||10;if(bet<=0)return;if(bet>balance){showToast('Not enough!',false);return;}
  if(!checkMaxBet(bet,'Horses'))return;
  horseRacing=true;balance-=bet;updateBalDisplay();document.getElementById('horseRaceBtn').disabled=true;document.getElementById('horseResult').textContent='';
  const progress=HORSES.map(()=>0);
  const raceSpds=HORSES.map(()=>1+Math.random()*3);
  playClickSound();
  const raceInterval=setInterval(()=>{let winner=-1;HORSES.forEach((_,i)=>{
    progress[i]+=Math.random()*raceSpds[i]*1.8+0.3;
    if(progress[i]>=100){progress[i]=100;if(winner<0)winner=i;}
    document.getElementById('hp'+i).style.width=progress[i]+'%';document.getElementById('he'+i).style.left=Math.min(progress[i],95)+'%';});
    if(winner>=0){clearInterval(raceInterval);horseRacing=false;document.getElementById('horseRaceBtn').disabled=false;
      const odds=parseFloat(document.getElementById('ho'+horseSelected).dataset.odds);
      if(winner===horseSelected){const w=bet*odds;balance+=w;updateBalDisplay();showBigWin(w);showToast(HORSES[winner].emoji+' '+HORSES[winner].name+' wins! +$'+w.toFixed(2));playWinSound();
        spawnParticles(window.innerWidth/2,window.innerHeight/2,40);document.getElementById('horseResult').innerHTML='<span style="color:var(--green)">'+HORSES[winner].name+' WINS! +$'+w.toFixed(2)+'</span>';recordGame('horses',bet,w);}
      else{showToast(HORSES[winner].name+' wins',false);playLoseSound();document.getElementById('horseResult').innerHTML='<span style="color:var(--red)">'+HORSES[winner].name+' wins</span>';recordGame('horses',bet,0);}
      setTimeout(()=>{HORSES.forEach((_,i)=>{document.getElementById('hp'+i).style.width='0%';document.getElementById('he'+i).style.left='0%';});horseSetOdds();},2000);}
  },60);
}

// ============ SCRATCH CARDS ============
const SCRATCH_TIERS=[{name:'Basic',price:5,symbols:['🍒','🍋','🔔','💎','7️⃣','⭐'],maxWin:50},{name:'Silver',price:25,symbols:['💎','7️⃣','⭐','👑','💰','🏆'],maxWin:500},{name:'Gold',price:100,symbols:['👑','💰','🏆','💎','🔥','🌟'],maxWin:5000},{name:'Diamond',price:500,symbols:['💎','👑','🔥','🌟','💀','🌀'],maxWin:50000}];
let scratchTier=0,scratchCells=[],scratchRevealed=0,scratchActive=false;
function scratchSelectTier(t,btn){scratchTier=t;document.querySelectorAll('.scratch-tier').forEach(b=>b.classList.remove('selected'));if(btn)btn.classList.add('selected');document.getElementById('scratchBuyBtn').textContent='BUY CARD — $'+SCRATCH_TIERS[t].price;playClickSound();}
function scratchBuy(){if(scratchActive)return;const tier=SCRATCH_TIERS[scratchTier];
  if(tier.price>balance){showToast('Not enough balance!',false);return;}
  balance-=tier.price;updateBalDisplay();scratchActive=true;scratchRevealed=0;scratchCells=[];
  const r=Math.random();let winCount=0;if(r<0.03)winCount=4;else if(r<0.15)winCount=3;
  if(winCount>0){
    const winSym=tier.symbols[Math.floor(Math.random()*tier.symbols.length)];
    const others=tier.symbols.filter(s=>s!==winSym);
    for(let i=0;i<9;i++){if(i<winCount)scratchCells.push(winSym);else{
      // Fill remaining with random others, but cap each other symbol at 2 to prevent accidental 3-match
      let pick;do{pick=others[Math.floor(Math.random()*others.length)];}while(scratchCells.filter(s=>s===pick).length>=2);scratchCells.push(pick);
    }}
  } else {
    // No win: fill 9 cells ensuring no symbol appears 3+ times
    const syms=tier.symbols.slice();
    for(let i=0;i<9;i++){
      const valid=syms.filter(s=>scratchCells.filter(c=>c===s).length<2);
      scratchCells.push(valid[Math.floor(Math.random()*valid.length)]);
    }
  }
  for(let i=scratchCells.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[scratchCells[i],scratchCells[j]]=[scratchCells[j],scratchCells[i]];}
  document.getElementById('scratchResult').textContent='';const g=document.getElementById('scratchGrid');g.innerHTML='';
  scratchCells.forEach((_,i)=>{const c=document.createElement('div');c.className='scratch-cell';c.textContent='?';c.onclick=()=>scratchReveal(i);g.appendChild(c);});document.getElementById('scratchRevealAllBtn').style.display='inline-block';playClickSound();
}
function scratchReveal(i){if(!scratchActive)return;const cells=document.querySelectorAll('.scratch-cell');if(cells[i].classList.contains('revealed'))return;
  cells[i].classList.add('revealed');cells[i].textContent=scratchCells[i];scratchRevealed++;playSound(500+Math.random()*200,'sine',.04,.03);
  if(scratchRevealed===9){scratchActive=false;document.getElementById('scratchRevealAllBtn').style.display='none';const tier=SCRATCH_TIERS[scratchTier];const counts={};scratchCells.forEach(s=>{counts[s]=(counts[s]||0)+1;});
    let maxC=0;Object.values(counts).forEach(c=>{if(c>maxC)maxC=c;});let payout=0;
    if(maxC>=3){payout=tier.price*(maxC===3?3:maxC===4?10:50);payout=Math.min(payout,tier.maxWin);}
    if(payout>0){balance+=payout;updateBalDisplay();showBigWin(payout);showToast(maxC+' matches! +$'+payout.toFixed(2));playWinSound();spawnParticles(window.innerWidth/2,window.innerHeight/2,30);
      document.getElementById('scratchResult').innerHTML='<span style="color:var(--green)">'+maxC+' MATCHES — +$'+payout+'!</span>';recordGame('scratch',tier.price,payout);}
    else{showToast('No matches',false);playLoseSound();document.getElementById('scratchResult').innerHTML='<span style="color:var(--red)">No matches</span>';recordGame('scratch',tier.price,0);}
  }
}

// ============ WHEEL OF FORTUNE ============
const WHEEL_SEGMENTS=[{label:'0×',mult:0,color:'#333',weight:5},{label:'0.5×',mult:0.5,color:'#444',weight:7},{label:'1×',mult:1,color:'#555',weight:6},{label:'1.5×',mult:1.5,color:'#1a5a1a',weight:4},{label:'2×',mult:2,color:'#2a7a2a',weight:3},{label:'3×',mult:3,color:'#1a1a8e',weight:1.5},{label:'5×',mult:5,color:'#6b2fd9',weight:0.8},{label:'10×',mult:10,color:'#cc2233',weight:0.25},{label:'50×',mult:50,color:'#ffd700',weight:0.04}];
let wheelAngle=0,wheelSpinning=false,wheelDrawn=false;
function drawWheel(angle){wheelDrawn=true;const c=document.getElementById('wheelCanvas');if(!c)return;const ctx=c.getContext('2d');const cx=c.width/2,cy=c.height/2,r=c.width/2-8;ctx.clearRect(0,0,c.width,c.height);
  const totalW=WHEEL_SEGMENTS.reduce((s,seg)=>s+seg.weight,0);let curAngle=angle;
  WHEEL_SEGMENTS.forEach(seg=>{const sliceAngle=(seg.weight/totalW)*Math.PI*2;ctx.beginPath();ctx.moveTo(cx,cy);ctx.arc(cx,cy,r,curAngle,curAngle+sliceAngle);ctx.closePath();ctx.fillStyle=seg.color;ctx.fill();ctx.strokeStyle='rgba(255,255,255,.15)';ctx.lineWidth=2;ctx.stroke();
    const ta=curAngle+sliceAngle/2;const tx=cx+Math.cos(ta)*(r*.62);const ty=cy+Math.sin(ta)*(r*.62);ctx.save();ctx.translate(tx,ty);ctx.rotate(ta+Math.PI/2);ctx.fillStyle='#fff';ctx.font='bold 11px Orbitron';ctx.textAlign='center';ctx.textBaseline='middle';ctx.globalAlpha=0.95;ctx.fillText(seg.label,0,0);ctx.restore();curAngle+=sliceAngle;});
  ctx.beginPath();ctx.arc(cx,cy,r*.12,0,Math.PI*2);ctx.fillStyle='#1a1a3e';ctx.fill();ctx.strokeStyle='rgba(255,215,0,.4)';ctx.lineWidth=2;ctx.stroke();
  ctx.beginPath();ctx.arc(cx,cy,r+2,0,Math.PI*2);ctx.strokeStyle='rgba(255,215,0,.2)';ctx.lineWidth=4;ctx.stroke();
}
function wheelSpin(){if(wheelSpinning)return;const bet=parseFloat(document.getElementById('wheelBet').value)||10;if(bet<=0)return;if(bet>balance){showToast('Not enough!',false);return;}
  if(!checkMaxBet(bet,'Wheel'))return;
  wheelSpinning=true;balance-=bet;updateBalDisplay();document.getElementById('wheelSpinBtn').disabled=true;document.getElementById('wheelResult').textContent='';playClickSound();
  const totalW=WHEEL_SEGMENTS.reduce((s,seg)=>s+seg.weight,0);let rnd=Math.random()*totalW,winIdx=0;
  for(let i=0;i<WHEEL_SEGMENTS.length;i++){rnd-=WHEEL_SEGMENTS[i].weight;if(rnd<=0){winIdx=i;break;}}const seg=WHEEL_SEGMENTS[winIdx];
  let cumAngle=0;for(let i=0;i<winIdx;i++){cumAngle+=(WHEEL_SEGMENTS[i].weight/totalW)*Math.PI*2;}cumAngle+=(seg.weight/totalW)*Math.PI;
  const targetAngle=-Math.PI/2-cumAngle+Math.PI*2*(5+Math.random()*3);const startAngle=wheelAngle;const totalRot=targetAngle-startAngle;
  const dur=3500;const st=performance.now();
  let lastTickAngle=startAngle;const tickSize=(WHEEL_SEGMENTS[0].weight/totalW)*Math.PI*2;
  function anim(now){const elapsed=now-st;const prog=Math.min(elapsed/dur,1);const eased=1-Math.pow(1-prog,4);const cur=startAngle+totalRot*eased;drawWheel(cur);
    if(Math.abs(cur-lastTickAngle)>tickSize){lastTickAngle=cur;playSound(600+Math.random()*200,'sine',.015,.01);}
    if(prog<1)requestAnimationFrame(anim);
    else{wheelAngle=cur%(Math.PI*2);wheelSpinning=false;document.getElementById('wheelSpinBtn').disabled=false;
      /* visual readback — find which segment the top pointer actually sits on */
      const twTotal=WHEEL_SEGMENTS.reduce((s,sg)=>s+sg.weight,0);
      const pointerAng=((-Math.PI/2-wheelAngle)%(Math.PI*2)+Math.PI*4)%(Math.PI*2);
      let acc=0,visSeg=WHEEL_SEGMENTS[0];
      for(let i=0;i<WHEEL_SEGMENTS.length;i++){acc+=(WHEEL_SEGMENTS[i].weight/twTotal)*Math.PI*2;if(pointerAng<acc){visSeg=WHEEL_SEGMENTS[i];break;}}
      const payout=bet*visSeg.mult;
      if(payout>0){balance+=payout;updateBalDisplay();showBigWin(payout);showToast(visSeg.label+' +$'+payout.toFixed(2));if(visSeg.mult>=2)playWinSound();else playClickSound();
        if(visSeg.mult>=5)spawnParticles(window.innerWidth/2,window.innerHeight/2,30+visSeg.mult*5);
        document.getElementById('wheelResult').innerHTML='<span style="color:var(--green)">'+visSeg.label+' — +$'+payout.toFixed(2)+'</span>';recordGame('wheel',bet,payout);}
      else{showToast(visSeg.label,false);playLoseSound();document.getElementById('wheelResult').innerHTML='<span style="color:var(--red)">'+visSeg.label+'</span>';recordGame('wheel',bet,0);}
    }
  }requestAnimationFrame(anim);
}

// ============ BACCARAT ============
let baccBetType=null;
function baccSelect(type,btn){baccBetType=type;document.querySelectorAll('.bacc-bet').forEach(b=>b.classList.remove('selected'));if(btn)btn.classList.add('selected');playClickSound();}
function baccCardVal(c){const v=cardNumVal(c);return v===11?1:v>=10?0:v;}
function baccHandTotal(hand){return hand.reduce((s,c)=>s+baccCardVal(c),0)%10;}
function baccDeal(){if(!baccBetType){showToast('Select bet!',false);return;}const bet=parseFloat(document.getElementById('baccBet').value)||10;if(bet<=0)return;if(bet>balance){showToast('Not enough!',false);return;}
  if(!checkMaxBet(bet,'Baccarat'))return;
  balance-=bet;updateBalDisplay();const deck=newDeck();const player=[deck.pop(),deck.pop()],banker=[deck.pop(),deck.pop()];
  let pScore=baccHandTotal(player),bScore=baccHandTotal(banker);
  if(pScore<8&&bScore<8){let pThird=null;
    if(pScore<=5){pThird=deck.pop();player.push(pThird);pScore=baccHandTotal(player);}
    if(!pThird){if(bScore<=5)banker.push(deck.pop());}
    else{const pTV=baccCardVal(pThird);
      if(bScore<=2)banker.push(deck.pop());
      else if(bScore===3&&pTV!==8)banker.push(deck.pop());
      else if(bScore===4&&[2,3,4,5,6,7].includes(pTV))banker.push(deck.pop());
      else if(bScore===5&&[4,5,6,7].includes(pTV))banker.push(deck.pop());
      else if(bScore===6&&[6,7].includes(pTV))banker.push(deck.pop());
    }
  }
  pScore=baccHandTotal(player);bScore=baccHandTotal(banker);
  document.getElementById('baccPlayerCards').innerHTML='';
  document.getElementById('baccBankerCards').innerHTML='';
  document.getElementById('baccPlayerScore').textContent='?';
  document.getElementById('baccBankerScore').textContent='?';
  document.getElementById('baccResult').innerHTML='<span style="color:var(--text2)">Dealing...</span>';
  const allCards=[];
  allCards.push({side:'player',card:player[0]});allCards.push({side:'banker',card:banker[0]});
  allCards.push({side:'player',card:player[1]});allCards.push({side:'banker',card:banker[1]});
  if(player.length>2)allCards.push({side:'player',card:player[2]});
  if(banker.length>2)allCards.push({side:'banker',card:banker[2]});
  let ci=0;
  const dealInterval=setInterval(()=>{
    if(ci>=allCards.length){clearInterval(dealInterval);
      document.getElementById('baccPlayerScore').textContent=pScore;
      document.getElementById('baccBankerScore').textContent=bScore;
      let winner=pScore>bScore?'player':bScore>pScore?'banker':'tie';let payout=0;
      if(winner===baccBetType){if(baccBetType==='player')payout=bet*2;else if(baccBetType==='banker')payout=bet*1.95;else payout=bet*9;}
      else if(winner==='tie'&&baccBetType!=='tie'){payout=bet;}
      setTimeout(()=>{
        if(payout>bet){balance+=payout;updateBalDisplay();showBigWin(payout);showToast((winner==='tie'?'TIE':winner.toUpperCase())+' +$'+(payout-bet).toFixed(2));playWinSound();
          spawnParticles(window.innerWidth/2,window.innerHeight/2,25);document.getElementById('baccResult').innerHTML='<span style="color:var(--green)">'+winner.toUpperCase()+' WINS! +$'+payout.toFixed(2)+'</span>';recordGame('baccarat',bet,payout);addResultDot('baccHistory',winner[0].toUpperCase(),true);}
        else if(payout===bet){balance+=payout;updateBalDisplay();showToast('Push');document.getElementById('baccResult').innerHTML='<span style="color:var(--gold)">PUSH</span>';recordGame('baccarat',bet,bet);addResultDot('baccHistory','T',false);}
        else{showToast('-$'+bet.toFixed(2),false);playLoseSound();document.getElementById('baccResult').innerHTML='<span style="color:var(--red)">'+winner.toUpperCase()+' WINS</span>';recordGame('baccarat',bet,0);addResultDot('baccHistory',winner[0].toUpperCase(),false);}
      },400);
      return;
    }
    const {side,card}=allCards[ci];
    const container=document.getElementById(side==='player'?'baccPlayerCards':'baccBankerCards');
    const el=document.createElement('div');el.innerHTML=renderCard(card);const cardEl=el.firstChild;
    cardEl.style.opacity='0';cardEl.style.transform='translateY(-20px)';cardEl.style.transition='all 0.3s ease';
    container.appendChild(cardEl);
    requestAnimationFrame(()=>{cardEl.style.opacity='1';cardEl.style.transform='translateY(0)';});
    playSound(300+ci*80,'sine',.03,.02);ci++;
  },450);
  playClickSound();
}

// ============ HILO ============
let hiloDeck=[],hiloCard=null,hiloStreakCount=0,hiloBetAmt=0,hiloActive=false,hiloSkipCount=0;
const HILO_MAX_MULT=500; // cap multiplier at 500×
const HILO_SKIP_PENALTY=0.10; // each skip reduces payout by 10%
function hiloMultiplier(){
  if(hiloStreakCount===0)return 1;
  let m=1;for(let i=0;i<hiloStreakCount;i++)m*=1.55;
  // Apply skip penalties (each skip ×0.90)
  for(let i=0;i<hiloSkipCount;i++)m*=(1-HILO_SKIP_PENALTY);
  m=Math.round(m*100)/100;
  return Math.min(m,HILO_MAX_MULT);
}
function hiloStart(){if(hiloActive)return;const bet=parseFloat(document.getElementById('hiloBet').value)||10;if(bet<=0)return;
  if(!checkMaxBet(bet,'Hi-Lo'))return;
  if(bet>balance){showToast('Not enough balance!',false);return;}
  hiloBetAmt=bet;balance-=bet;updateBalDisplay();hiloActive=true;hiloStreakCount=0;hiloSkipCount=0;hiloDeck=newDeck();hiloCard=hiloDeck.pop();hiloRender();
  document.getElementById('hiloStartBtn').style.display='none';document.getElementById('hiloCashoutBtn').style.display='';playClickSound();
}
function hiloCashout(){if(!hiloActive||hiloStreakCount===0)return;const p=hiloBetAmt*hiloMultiplier();balance+=p;updateBalDisplay();
  showBigWin(p);showToast('+$'+p.toFixed(2));playWinSound();spawnParticles(window.innerWidth/2,window.innerHeight/2,25);hiloActive=false;
  document.getElementById('hiloStartBtn').style.display='';document.getElementById('hiloCashoutBtn').style.display='none';
  document.getElementById('hiloStreak').textContent='Cashed out '+hiloMultiplier().toFixed(2)+'× — $'+p.toFixed(2);recordGame('hilo',hiloBetAmt,p);
}
function hiloGuess(guess){if(!hiloActive)return;if(hiloDeck.length<2)hiloDeck=newDeck();
  const next=hiloDeck.pop();const curRank=cardRankIdx(hiloCard),nextRank=cardRankIdx(next);
  if(guess==='skip'){hiloSkipCount++;hiloCard=next;hiloRender();playSound(400,'sine',.04,.04);
    showToast('Skipped! (-10% payout penalty)',false);return;}
  let correct=false;
  const tied = nextRank===curRank;
  // Ties (equal rank) = push — card redrawn, no streak change
  if(guess==='higher')correct=nextRank>curRank;else if(guess==='lower')correct=nextRank<curRank;
  hiloCard=next;
  if(tied){hiloRender();playSound(400,'sine',.06,.05);
    showToast('TIE! Same card — try again.',false);
    document.getElementById('hiloStreak').innerHTML='<span style="color:var(--gold)">TIE!</span> Card was '+next.r+next.s+' — guess again';return;}
  if(correct){hiloStreakCount++;playSound(500+hiloStreakCount*60,'sine',.08,.06);hiloRender();}
  else{hiloActive=false;hiloRender();showToast('-$'+hiloBetAmt.toFixed(2),false);playLoseSound();
    document.getElementById('hiloStartBtn').style.display='';document.getElementById('hiloCashoutBtn').style.display='none';
    document.getElementById('hiloStreak').innerHTML='<span style="color:var(--red)">WRONG!</span> Card was '+next.r+next.s;recordGame('hilo',hiloBetAmt,0);
  }
}
function hiloRender(){const c=hiloCard;document.getElementById('hiloCard').className='hilo-card'+(cardIsRed(c)?' red':'');document.getElementById('hiloCard').innerHTML=c.r+'<br>'+c.s;
  document.getElementById('hiloHigherBtn').disabled=!hiloActive;document.getElementById('hiloLowerBtn').disabled=!hiloActive;document.getElementById('hiloSkipBtn').disabled=!hiloActive;
  if(hiloActive){const m=hiloMultiplier();document.getElementById('hiloStreak').textContent='Streak: '+hiloStreakCount+' — '+m.toFixed(2)+'×'+(hiloSkipCount>0?' ('+hiloSkipCount+' skips, -'+Math.round(100*(1-Math.pow(0.9,hiloSkipCount)))+'%)':'');
    document.getElementById('hiloCashout').textContent=hiloStreakCount>0?'Cash out: $'+(hiloBetAmt*m).toFixed(2):'';}
}

// ============ GLOBAL CHAT (Client) ============
let chatOpen = false;
let chatUnread = 0;
let chatInitialized = false;

function toggleChat() {
  chatOpen = !chatOpen;
  const panel = document.getElementById('chatPanel');
  panel.classList.toggle('open', chatOpen);
  if (chatOpen) {
    chatUnread = 0;
    updateChatBadge();
    if (!chatInitialized && window._initChat) {
      window._initChat();
      chatInitialized = true;
    }
    const input = document.getElementById('chatInput');
    setTimeout(() => input.focus(), 100);
    // Scroll to bottom
    const msgs = document.getElementById('chatMessages');
    msgs.scrollTop = msgs.scrollHeight;
  }
}

function updateChatBadge() {
  const badge = document.getElementById('chatBadge');
  if (chatUnread > 0) {
    badge.style.display = 'flex';
    badge.textContent = chatUnread > 99 ? '99+' : chatUnread;
  } else {
    badge.style.display = 'none';
  }
}

window._onChatMessages = function(msgs) {
  const container = document.getElementById('chatMessages');
  const wasAtBottom = container.scrollTop >= container.scrollHeight - container.clientHeight - 30;
  container.innerHTML = '<div class="chat-msg-system">Welcome to Casino Royale chat! Be respectful.</div>';
  
  msgs.forEach(m => {
    if (m.type === 'win') {
      const el = document.createElement('div');
      el.className = 'chat-msg-win';
      el.innerHTML = '<div class="win-text">🎉 ' + escapeHtml(m.text) + '</div>';
      container.appendChild(el);
    } else if (m.type === 'system') {
      const el = document.createElement('div');
      el.className = 'chat-msg-system';
      el.textContent = m.text;
      container.appendChild(el);
    } else {
      const el = document.createElement('div');
      el.className = 'chat-msg';
      const initial = (m.user || '?')[0].toUpperCase();
      const isGuest = (m.user || '').toLowerCase() === 'guest';
      const timeStr = m.ts ? new Date(m.ts).toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'}) : '';
      const pBadge = m.prestige > 0 ? getPrestigeBadgeHTML(m.prestige) : '';
      let roleBadge = '';
      if (m.role === 'owner') roleBadge = '<span class="role-badge-owner">OWNER</span>';
      else if (m.role === 'co-owner') roleBadge = '<span class="role-badge-coowner">CO-OWNER</span>';
      const avatarContent = m.profilePicUrl ? `<img src="${m.profilePicUrl}" style="width:100%;height:100%;object-fit:cover;border-radius:50%;">` : initial;
      el.innerHTML = `<div class="chat-msg-avatar">${avatarContent}</div>
        <div class="chat-msg-body">
          <div class="chat-msg-name${isGuest?' guest-name':''}">${escapeHtml(m.user||'Guest')}${roleBadge}${pBadge} <span class="chat-msg-time">${timeStr}</span></div>
          <div class="chat-msg-text">${escapeHtml(m.text)}</div>
        </div>`;
      container.appendChild(el);
    }
  });

  if (wasAtBottom || !chatOpen) container.scrollTop = container.scrollHeight;
  if (!chatOpen && msgs.length > 0) {
    chatUnread = Math.min(chatUnread + 1, 99);
    updateChatBadge();
  }
};

window._onChatOnlineCount = function(count) {
  const el = document.getElementById('chatOnlineCount');
  if (el) el.textContent = count > 0 ? '(' + count + ' online)' : '';
};

function escapeHtml(str) {
  const div = document.createElement('div');
  div.textContent = str;
  return div.innerHTML;
}

function sendChatMessage() {
  const input = document.getElementById('chatInput');
  let text = input.value.trim();
  if (!text) return;
  if (isGuestMode) { showToast('Sign in to chat', false); return; }
  if (text.length > 200) text = text.slice(0, 200); // enforce length limit
  const username = window._currentUsername || 'Guest';
  if (window._sendChatMsg) {
    window._sendChatMsg(text, username, 'msg').then(()=>{
      // Scroll to bottom so user sees their message
      const msgs = document.getElementById('chatMessages');
      if(msgs) msgs.scrollTop = msgs.scrollHeight;
    }).catch((e)=>{ showToast('Message failed to send', false); console.error('Chat error:', e); });
  } else {
    showToast('Chat not available', false);
  }
  input.value = '';
}

// Enter key to send
document.getElementById('chatInput').addEventListener('keydown', function(e) {
  if (e.key === 'Enter' && !e.shiftKey) {
    e.preventDefault();
    sendChatMessage();
  }
});

// Broadcast big wins to chat (throttled to prevent spam)
let _lastBroadcast = 0;
const _origRecordGame = recordGame;
recordGame = function(game, wagered, won) {
  _origRecordGame(game, wagered, won);
  // Only broadcast wins over $5000, max once per 15 seconds
  const now = Date.now();
  if (won >= 5000 && window._broadcastWin && (now - _lastBroadcast > 15000)) {
    _lastBroadcast = now;
    const username = window._currentUsername || 'Guest';
    const gameNames = {slots:'Slots',crash:'Crash',roulette:'Roulette',cases:'Cases',plinko:'Plinko',
      blackjack:'Blackjack',mines:'Mines',dice:'Dice',tower:'Tower',coinflip:'Coin Flip',
      keno:'Keno',limbo:'Limbo',poker:'Poker',horses:'Horses',scratch:'Scratch',
      wheel:'Wheel',baccarat:'Baccarat',hilo:'Hi-Lo'};
    window._broadcastWin(username, gameNames[game] || game, won);
  }
};

// ============ INIT ============
window.addEventListener('load',()=>{
  initSlots();
  initCases();
  resizeCrashCanvas();
  initStocks();
  minesRenderGrid();
  diceUpdateSlider();
  kenoInit();
  horseInit();
  drawWheel(0);
  // Initialize Plinko profit chart on first load if panel visible
  try{ updatePlinkoProfitChart(); }catch(e){}
  document.getElementById('limboTarget').addEventListener('input',limboUpdateInfo);
  window.addEventListener('resize',()=>{resizeCrashCanvas();resizeParticles();
  try{const wrap=document.querySelector('.plinko-canvas-wrap');if(wrap&&plinkoInitialized&&plinkoMatterRender&&plinkoMatterRender.canvas){plinkoMatterRender.canvas.style.width = wrap.clientWidth + 'px';plinkoMatterRender.canvas.style.height = wrap.clientHeight + 'px';}}
  catch(e){}
  if(document.querySelector('#stocksPanel.active')&&typeof renderStocks==='function'){try{renderStocks();}catch(e){}}
  if(document.querySelector('#wheelPanel.active')&&typeof drawWheel==='function'){try{drawWheel(wheelAngle||0);}catch(e){}}
});
  // iPad Safari: set --vh initially and on visual viewport resize (address bar show/hide)
  if(window.visualViewport){document.documentElement.style.setProperty('--vh',window.visualViewport.height+'px');window.visualViewport.addEventListener('resize',()=>{document.documentElement.style.setProperty('--vh',window.visualViewport.height+'px');});}
  setInterval(firebaseSave,30000);
  // Poll for incoming trade requests every 10s and notify
  let _lastTradeReqCount = 0;
  setInterval(async ()=>{
    if(!window._loadTradeRequests || !window._currentPlayerId) return;
    try {
      const reqs = await window._loadTradeRequests();
      if(reqs.length > 0 && reqs.length > _lastTradeReqCount){
        showToast('🤝 You have ' + reqs.length + ' trade request(s)! Check Trade → Inbox', true);
      }
      _lastTradeReqCount = reqs.length;
    } catch(e){}
  }, 10000);
  // Logo should show the catalog
  const logo = document.querySelector('.logo'); if(logo){ logo.addEventListener('click',()=>{ const catalog=document.getElementById('gameCatalog'); if(catalog) catalog.style.display='flex'; document.querySelectorAll('.game-panel').forEach(p=>p.classList.remove('active')); document.querySelectorAll('.nav-btn').forEach(b=>b.classList.remove('active')); }); }
});

// Save on page close/refresh
window.addEventListener('beforeunload',()=>{ if(window._flushStatsNow) window._flushStatsNow(); firebaseSaveNow(); });
window.addEventListener('visibilitychange',()=>{ if(document.hidden) firebaseSave(); });

// Handle keyboard shortcuts
document.addEventListener('keydown',e=>{
  if(e.code==='Space'){
    // Don't fire shortcuts when typing in inputs
    const tag = (e.target.tagName||'').toUpperCase();
    if(tag==='INPUT'||tag==='TEXTAREA'||tag==='SELECT'||e.target.isContentEditable) return;
    e.preventDefault();
    const panel=document.querySelector('.game-panel.active');
    if(!panel)return;
    if(panel.id==='slotsPanel')spinSlots();
    else if(panel.id==='crashPanel'){if(crashRunning)cashOut();else startCrash();}
    else if(panel.id==='roulettePanel')spinRoulette();
    else if(panel.id==='casesPanel')openCase();
    else if(panel.id==='plinkoPanel')dropPlinkoBall();
    else if(panel.id==='blackjackPanel'){if(bjActive)bjHit();else bjDeal();}
    else if(panel.id==='minesPanel'){if(minesActive)minesCashout();else minesStart();}
    else if(panel.id==='dicePanel')diceRoll();
    else if(panel.id==='towerPanel'){if(towerActive)towerCashout();else towerStart();}
    else if(panel.id==='coinflipPanel')coinFlip();
    else if(panel.id==='kenoPanel')kenoDraw();
    else if(panel.id==='limboPanel')limboGo();
    else if(panel.id==='pokerPanel')pokerDeal();
    else if(panel.id==='horsesPanel')horseRace();
    else if(panel.id==='wheelPanel')wheelSpin();
    else if(panel.id==='baccaratPanel')baccDeal();
    else if(panel.id==='hiloPanel'){if(hiloActive)hiloCashout();else hiloStart();}
  }
});

// ============ BUCKSHOT ROULETTE ============
let bsrState = null;
let bsrDifficulty = 'normal'; // 'easy', 'normal', 'hard'
const BSR_DIFF = {
  easy:   { rounds:2, hp:5, items:4, mult:2.5, dealerHpScale:1, label:'EASY',   icon:'😎' },
  normal: { rounds:3, hp:4, items:3, mult:4,   dealerHpScale:1, label:'NORMAL', icon:'💀' },
  hard:   { rounds:4, hp:3, items:2, mult:7,   dealerHpScale:1, label:'HARD',   icon:'☠️' },
};
const BSR_ITEM_ICONS = { handcuffs:'🔗', cigarettes:'🚬', gummy:'🍬', saw:'🪚', phone:'📱', magnifying:'🔍' };
const BSR_ITEM_NAMES = { handcuffs:'Handcuffs', cigarettes:'Cigarettes', gummy:'Rotten Gummy', saw:'Saw', phone:'Burner Phone', magnifying:'Magnifying Glass' };
const BSR_ITEM_DESCS = { handcuffs:'Dealer skips next turn', cigarettes:'Heal +1 HP', gummy:'40% +2HP / 60% −1HP', saw:'Next live = 2 dmg', phone:'Reveal random shell', magnifying:'See current shell' };
const BSR_ALL_ITEMS = ['handcuffs','cigarettes','gummy','saw','phone','magnifying'];

// Stats persisted in localStorage
let bsrStats = JSON.parse(localStorage.getItem('bsr_stats')) || { wins:0, losses:0, biggestWin:0, streak:0, bestStreak:0 };
function bsrSaveStats(){ localStorage.setItem('bsr_stats', JSON.stringify(bsrStats)); }

function bsrSelectDiff(diff, el) {
  bsrDifficulty = diff;
  document.querySelectorAll('.bsr-diff-card').forEach(c => c.classList.remove('selected'));
  if(el) el.classList.add('selected');
  playClickSound();
}

function initBuckshotRoulette() {
  if (!bsrState || !bsrState.active) {
    document.getElementById('bsrLobby').style.display = 'block';
    document.getElementById('bsrGame').style.display = 'none';
    document.getElementById('bsrGameOver').style.display = 'none';
    document.getElementById('bsrRoundSplash').style.display = 'none';
    bsrUpdateStats();
  }
}

function bsrUpdateStats() {
  const total = bsrStats.wins + bsrStats.losses;
  const wr = total > 0 ? Math.round(bsrStats.wins / total * 100) + '%' : '--';
  const bw = bsrStats.biggestWin > 0 ? '$' + bsrStats.biggestWin.toLocaleString() : '--';
  const el1 = document.getElementById('bsrStatWinRate');
  const el2 = document.getElementById('bsrStatBigWin');
  const el3 = document.getElementById('bsrStatStreak');
  if(el1) el1.textContent = wr;
  if(el2) el2.textContent = bw;
  if(el3) el3.textContent = bsrStats.streak;
}

/* ─── START GAME ─── */
function bsrStartGame() {
  const bet = parseFloat(document.getElementById('bsrBet').value) || 100;
  if (bet <= 0) { showToast('Bet must be positive!', false); return; }
  if (bet > balance) { showToast('Not enough balance!', false); return; }
  balance -= bet; updateBalDisplay();
  playClickSound();

  const diff = BSR_DIFF[bsrDifficulty];
  bsrState = {
    active: true,
    bet: bet,
    diff: bsrDifficulty,
    mult: diff.mult,
    round: 1,
    maxRounds: diff.rounds,
    playerHP: diff.hp,
    playerMaxHP: diff.hp,
    dealerHP: diff.hp,
    dealerMaxHP: diff.hp,
    shells: [],
    shellIndex: 0,
    turn: 'player',
    sawActive: false,
    handcuffs: 0,       // dealer skip count
    playerHandcuffed: 0,// player skip count
    maxItems: diff.items,
    items: [],
    dealerItems: [],
    log: [],
    animating: false,
    _dealerKnowsCurrent: null,
    _revealedShells: {},  // index => type, for phone reveals
  };

  document.getElementById('bsrLobby').style.display = 'none';
  document.getElementById('bsrGame').style.display = 'block';
  document.getElementById('bsrGameOver').style.display = 'none';
  document.getElementById('bsrLog').innerHTML = '';

  bsrShowRoundSplash(1, () => bsrNewRound());
}

/* ─── ROUND SPLASH ─── */
function bsrShowRoundSplash(roundNum, callback) {
  const splash = document.getElementById('bsrRoundSplash');
  const txt = document.getElementById('bsrRoundSplashText');
  txt.textContent = 'ROUND ' + roundNum;
  splash.style.display = 'flex';
  splash.style.opacity = '0';
  requestAnimationFrame(() => {
    splash.style.transition = 'opacity 0.4s';
    splash.style.opacity = '1';
  });
  setTimeout(() => {
    splash.style.transition = 'opacity 0.5s';
    splash.style.opacity = '0';
    setTimeout(() => {
      splash.style.display = 'none';
      if(callback) callback();
    }, 500);
  }, 1600);
}

/* ─── NEW ROUND ─── */
function bsrNewRound() {
  const s = bsrState;
  if(!s) return;
  s.animating = false;
  s._dealerKnowsCurrent = null;
  s._revealedShells = {};

  // Shell loading: 3–8 shells, at least 1 live and 1 blank
  const totalShells = Math.floor(Math.random() * 4) + 4; // 4-7
  let liveCount = Math.max(1, Math.floor(Math.random() * (totalShells - 1)) + 1);
  if(liveCount >= totalShells) liveCount = totalShells - 1; // ensure ≥1 blank
  const blankCount = totalShells - liveCount;
  s.shells = [];
  for(let i = 0; i < liveCount; i++) s.shells.push('live');
  for(let i = 0; i < blankCount; i++) s.shells.push('blank');
  // Fisher-Yates shuffle
  for(let i = s.shells.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [s.shells[i], s.shells[j]] = [s.shells[j], s.shells[i]];
  }
  s.shellIndex = 0;
  s.sawActive = false;
  s.handcuffs = 0;
  s.playerHandcuffed = 0;

  // Distribute items
  s.items = [];
  s.dealerItems = [];
  for(let i = 0; i < s.maxItems; i++) {
    s.items.push(BSR_ALL_ITEMS[Math.floor(Math.random() * BSR_ALL_ITEMS.length)]);
    s.dealerItems.push(BSR_ALL_ITEMS[Math.floor(Math.random() * BSR_ALL_ITEMS.length)]);
  }

  // Who goes first (alternate or random)
  s.turn = s.round % 2 === 1 ? 'player' : 'dealer';

  bsrLog(`⚡ ROUND ${s.round} — Shotgun loaded: ${liveCount} LIVE 🔴, ${blankCount} BLANK 🔵`);
  bsrLog(`${s.items.length} items each. ${s.turn === 'player' ? 'Your' : "Dealer's"} turn first.`);

  bsrRender();
  bsrSetStatus(s.turn === 'player' ? 'Your turn — choose wisely.' : "Dealer's turn...");

  if(s.turn === 'dealer') {
    bsrDisableActions();
    setTimeout(() => bsrDealerTurn(), 2000);
  }
}

/* ─── LOGGING ─── */
function bsrLog(msg) {
  if(!bsrState) return;
  bsrState.log.push(msg);
  const el = document.getElementById('bsrLog');
  if(!el) return;
  el.innerHTML = bsrState.log.map(m => '<div class="bsr-log-line">' + m + '</div>').join('');
  el.scrollTop = el.scrollHeight;
}

/* ─── RENDER ─── */
function bsrRender() {
  const s = bsrState;
  if(!s) return;

  // Round & multiplier
  document.getElementById('bsrRoundInfo').textContent = `ROUND ${s.round}/${s.maxRounds}`;
  document.getElementById('bsrMultiplier').textContent = `${s.mult}× PAYOUT`;

  // Shell info
  const remaining = s.shells.length - s.shellIndex;
  const livesLeft = s.shells.slice(s.shellIndex).filter(x => x === 'live').length;
  const blanksLeft = remaining - livesLeft;
  document.getElementById('bsrShellInfo').innerHTML = `<span style="color:#ff4444;">${livesLeft} live</span> / <span style="color:#4488ff;">${blanksLeft} blank</span>`;

  // Shell rack
  const rack = document.getElementById('bsrShellRack');
  rack.innerHTML = s.shells.map((sh, i) => {
    let cls = 'bsr-shell';
    if(i < s.shellIndex) cls += ' used' + (sh === 'live' ? ' was-live' : ' was-blank');
    else if(i === s.shellIndex) cls += ' current';
    else cls += ' unknown';
    // If phone revealed this shell, show it
    if(i >= s.shellIndex && s._revealedShells[i]) {
      cls += s._revealedShells[i] === 'live' ? ' reveal-live' : ' reveal-blank';
    }
    const label = i < s.shellIndex ? '✓' : (s._revealedShells[i] && i > s.shellIndex ? (s._revealedShells[i] === 'live' ? '🔴' : '🔵') : '?');
    return `<div class="${cls}">${label}</div>`;
  }).join('');

  // HP bars + hearts
  const pPct = Math.max(0, s.playerHP / s.playerMaxHP * 100);
  const dPct = Math.max(0, s.dealerHP / s.dealerMaxHP * 100);
  const pHP = Math.max(0, s.playerHP);
  const dHP = Math.max(0, s.dealerHP);
  document.getElementById('bsrPlayerHP').textContent = pHP + ' HP';
  document.getElementById('bsrPlayerHPBar').style.width = pPct + '%';
  document.getElementById('bsrPlayerHearts').textContent = '❤️'.repeat(pHP) + '🖤'.repeat(Math.max(0, s.playerMaxHP - pHP));
  document.getElementById('bsrDealerHP').textContent = dHP + ' HP';
  document.getElementById('bsrDealerHPBar').style.width = dPct + '%';
  document.getElementById('bsrDealerHearts').textContent = '❤️'.repeat(dHP) + '🖤'.repeat(Math.max(0, s.dealerMaxHP - dHP));

  // Color HP bar by health percentage
  const pBar = document.getElementById('bsrPlayerHPBar');
  pBar.style.background = pPct > 50 ? 'linear-gradient(90deg,var(--green),#66ff99)' : pPct > 25 ? 'linear-gradient(90deg,#ff8800,#ffbb00)' : 'linear-gradient(90deg,#ff4444,#ff6666)';
  const dBar = document.getElementById('bsrDealerHPBar');
  dBar.style.background = dPct > 50 ? 'linear-gradient(90deg,#ff4444,#ff8888)' : dPct > 25 ? 'linear-gradient(90deg,#ff8800,#ffbb00)' : 'linear-gradient(90deg,#ff4444,#880000)';

  // Player items
  const itemsEl = document.getElementById('bsrItems');
  const canUse = s.turn === 'player' && !s.animating;
  itemsEl.innerHTML = s.items.map((it, i) =>
    `<button class="bsr-item-btn${canUse ? '' : ' disabled'}" onclick="bsrUseItem(${i})" ${canUse ? '' : 'disabled'}>` +
    `<span class="item-icon">${BSR_ITEM_ICONS[it]}</span>` +
    `<span class="item-info"><span class="item-name">${BSR_ITEM_NAMES[it]}</span><span class="item-desc">${BSR_ITEM_DESCS[it]}</span></span>` +
    `</button>`
  ).join('');

  // Dealer items (visible but not clickable)
  const dealerItemsEl = document.getElementById('bsrDealerItemsDisplay');
  dealerItemsEl.innerHTML = s.dealerItems.map(it =>
    `<span style="display:inline-block;padding:3px 7px;border-radius:6px;background:rgba(255,68,68,.08);border:1px solid rgba(255,68,68,.15);font-size:11px;color:rgba(255,68,68,.6);">${BSR_ITEM_ICONS[it]}</span>`
  ).join(' ');

  // Saw indicator on shotgun
  const shotgunEl = document.getElementById('bsrShotgun');
  shotgunEl.textContent = s.sawActive ? '🪚🔫' : '🔫';
  if(s.sawActive) shotgunEl.style.filter = 'drop-shadow(0 0 8px rgba(255,136,0,.6))';
  else shotgunEl.style.filter = '';

  // Action buttons
  if(canUse) bsrEnableActions(); else bsrDisableActions();
}

function bsrEnableActions() {
  const d = document.getElementById('bsrShootDealer');
  const s = document.getElementById('bsrShootSelf');
  if(d){ d.disabled = false; d.style.opacity = '1'; d.style.pointerEvents = 'auto'; }
  if(s){ s.disabled = false; s.style.opacity = '1'; s.style.pointerEvents = 'auto'; }
}
function bsrDisableActions() {
  const d = document.getElementById('bsrShootDealer');
  const s = document.getElementById('bsrShootSelf');
  if(d){ d.disabled = true; d.style.opacity = '0.35'; d.style.pointerEvents = 'none'; }
  if(s){ s.disabled = true; s.style.opacity = '0.35'; s.style.pointerEvents = 'none'; }
}
function bsrSetStatus(msg) {
  const el = document.getElementById('bsrStatus');
  if(el) el.textContent = msg;
}

/* ─── SHOTGUN ANIMATION ─── */
function bsrAnimateShotgun(direction, isLive) {
  // direction: 'left' (shoot dealer) or 'right' (shoot self)
  const gun = document.getElementById('bsrShotgun');
  if(!gun) return;
  gun.classList.add('shake');
  setTimeout(() => {
    gun.classList.remove('shake');
    gun.classList.add(direction === 'left' ? 'recoil-left' : 'recoil-right');
    // Flash the current shell
    const shells = document.querySelectorAll('.bsr-shell.current');
    if(shells.length) {
      shells[0].classList.add(isLive ? 'reveal-live' : 'reveal-blank');
    }
    setTimeout(() => {
      gun.classList.remove('recoil-left', 'recoil-right');
    }, 400);
  }, 600);
}

function bsrAnimateHit(who) {
  // who: 'player' or 'dealer'
  const card = document.getElementById(who === 'player' ? 'bsrPlayerCard' : 'bsrDealerCard');
  if(!card) return;
  card.classList.add('hit');
  setTimeout(() => card.classList.remove('hit'), 500);
}

/* ─── USE ITEM (PLAYER) ─── */
function bsrUseItem(index) {
  const s = bsrState;
  if(!s || !s.active || s.turn !== 'player' || s.animating) return;
  if(index < 0 || index >= s.items.length) return;

  const item = s.items[index];
  s.items.splice(index, 1);
  playClickSound();

  switch(item) {
    case 'handcuffs':
      s.handcuffs = Math.max(s.handcuffs, 1); // doesn't stack, just ensures 1 skip
      bsrLog('🔗 You used Handcuffs! Dealer skips their next turn.');
      bsrSetStatus('Dealer is handcuffed!');
      break;
    case 'cigarettes':
      if(s.playerHP < s.playerMaxHP) {
        s.playerHP = Math.min(s.playerHP + 1, s.playerMaxHP);
        bsrLog('🚬 You smoked a Cigarette. +1 HP! (' + s.playerHP + '/' + s.playerMaxHP + ')');
        bsrSetStatus('+1 HP! Health: ' + s.playerHP + '/' + s.playerMaxHP);
      } else {
        bsrLog('🚬 Cigarette used but HP already full.');
        bsrSetStatus('Already at max HP!');
      }
      break;
    case 'gummy':
      if(Math.random() < 0.4) {
        const heal = Math.min(2, s.playerMaxHP + 1 - s.playerHP); // can overheal by 1
        s.playerHP += heal;
        bsrLog('🍬 Rotten Gummy worked! +' + heal + ' HP! (' + s.playerHP + ')');
        bsrSetStatus('Lucky! +' + heal + ' HP!');
      } else {
        s.playerHP -= 1;
        bsrLog('🍬 Rotten Gummy backfired! −1 HP (' + s.playerHP + ')');
        bsrSetStatus('Food poisoning! −1 HP');
        if(s.playerHP <= 0) {
          bsrRender();
          bsrAnimateHit('player');
          setTimeout(() => bsrEndGame(false), 1200);
          return;
        }
      }
      break;
    case 'saw':
      s.sawActive = true;
      bsrLog('🪚 Saw attached! Next LIVE shell deals double damage.');
      bsrSetStatus('Saw equipped — next live = 2 damage!');
      break;
    case 'phone': {
      const rem = s.shells.slice(s.shellIndex);
      if(rem.length > 1) {
        // Pick a random future shell (not current)
        const futureIdx = Math.floor(Math.random() * (rem.length - 1)) + 1;
        const absIdx = s.shellIndex + futureIdx;
        const shellType = rem[futureIdx];
        s._revealedShells[absIdx] = shellType;
        bsrLog('📱 Phone call: "Shell #' + (absIdx + 1) + ' is ' + shellType.toUpperCase() + '"');
        bsrSetStatus('Shell #' + (absIdx+1) + ' is ' + shellType.toUpperCase() + (shellType === 'live' ? ' 🔴' : ' 🔵'));
      } else {
        bsrLog('📱 No future shells to reveal.');
        bsrSetStatus('No more shells ahead.');
      }
      break;
    }
    case 'magnifying': {
      const cur = s.shells[s.shellIndex];
      bsrLog('🔍 Current shell: ' + cur.toUpperCase() + (cur === 'live' ? ' 🔴' : ' 🔵'));
      bsrSetStatus('Current shell: ' + cur.toUpperCase() + (cur === 'live' ? ' 🔴' : ' 🔵'));
      break;
    }
  }
  bsrRender();
}

/* ─── SHOOT (PLAYER) ─── */
function bsrShoot(target) {
  const s = bsrState;
  if(!s || !s.active || s.animating || s.turn !== 'player') return;
  s.animating = true;
  bsrDisableActions();

  const shell = s.shells[s.shellIndex];
  s.shellIndex++;
  const damage = shell === 'live' ? (s.sawActive ? 2 : 1) : 0;
  if(shell === 'live') s.sawActive = false; // saw only consumed when it fires (live shell)

  // Animate shotgun
  bsrAnimateShotgun(target === 'dealer' ? 'left' : 'right', shell === 'live');
  bsrSetStatus('💥 ...');

  // Sound: loud bang for live, click for blank
  if(shell === 'live') {
    playSound(120, 'sawtooth', 0.35, 0.2);
    setTimeout(() => playSound(80, 'square', 0.2, 0.1), 100);
  } else {
    playSound(600, 'sine', 0.08, 0.06);
  }

  // Resolve after animation
  setTimeout(() => {
    if(target === 'dealer') {
      if(shell === 'live') {
        s.dealerHP -= damage;
        bsrAnimateHit('dealer');
        bsrLog(`🔫 You shot the Dealer — LIVE! ${damage > 1 ? '🪚 SAW: 2 dmg! ' : ''}Dealer: ${Math.max(0,s.dealerHP)} HP`);
        bsrSetStatus(`💥 LIVE! Dealer takes ${damage} damage!`);
      } else {
        bsrLog('🔫 You shot the Dealer — BLANK. No damage.');
        bsrSetStatus('*click* — BLANK. No damage.');
      }
      s.turn = 'dealer'; // always pass turn
    } else {
      if(shell === 'live') {
        s.playerHP -= damage;
        bsrAnimateHit('player');
        bsrLog(`🫵 You shot yourself — LIVE! ${damage > 1 ? '🪚 SAW: 2 dmg! ' : ''}You: ${Math.max(0,s.playerHP)} HP`);
        bsrSetStatus(`💥 LIVE! You take ${damage} damage!`);
        s.turn = 'dealer';
      } else {
        bsrLog('🫵 You shot yourself — BLANK! Free extra turn!');
        bsrSetStatus('*click* — BLANK! You get another turn!');
        s.turn = 'player'; // keep turn on blank self-shot
      }
    }

    s.animating = false;
    bsrRender();

    // Check death / round win / shells exhausted
    if(s.dealerHP <= 0) {
      setTimeout(() => bsrRoundWin(), 1200);
      return;
    }
    if(s.playerHP <= 0) {
      setTimeout(() => bsrEndGame(false), 1200);
      return;
    }
    if(s.shellIndex >= s.shells.length) {
      bsrLog('📦 All shells spent! Reloading...');
      setTimeout(() => {
        bsrShowRoundSplash(s.round, () => bsrNewRound());
      }, 1500);
      return;
    }

    // A blank self-shot grants an immediate bonus shot (not a new "turn"),
    // so handcuffs should NOT consume the skip for that free shot.
    if(target === 'self' && shell === 'blank') {
      bsrRender(); // just stay in player's turn
    } else {
      bsrResolveTurn();
    }
  }, 1100);
}

/* ─── TURN RESOLUTION (handles handcuffs for both sides) ─── */
function bsrResolveTurn() {
  const s = bsrState;
  if(!s || !s.active) return;

  if(s.turn === 'dealer') {
    if(s.handcuffs > 0) {
      s.handcuffs--;
      bsrLog('🔗 Dealer is handcuffed! Skipping turn.');
      bsrSetStatus('Dealer is chained! Skipping...');
      s.turn = 'player';
      setTimeout(() => {
        // Player may also be cuffed
        if(s.playerHandcuffed > 0) {
          s.playerHandcuffed--;
          bsrLog('🔗 You are also handcuffed! Skipping turn.');
          bsrSetStatus('You are chained too! Skipping...');
          s.turn = 'dealer';
          bsrRender();
          setTimeout(() => bsrDealerTurn(), 1800);
        } else {
          bsrRender();
        }
      }, 1000);
    } else {
      setTimeout(() => bsrDealerTurn(), 1800);
    }
  } else { // player turn
    if(s.playerHandcuffed > 0) {
      s.playerHandcuffed--;
      bsrLog('🔗 You are handcuffed! Skipping turn.');
      bsrSetStatus('You are chained! Skipping...');
      s.turn = 'dealer';
      bsrRender();
      setTimeout(() => {
        if(s.handcuffs > 0) {
          s.handcuffs--;
          bsrLog('🔗 Dealer also handcuffed! Skipping turn.');
          s.turn = 'player';
          bsrRender();
        } else {
          bsrDealerTurn();
        }
      }, 1800);
    } else {
      bsrRender(); // player's turn, enable actions
    }
  }
}

/* ─── DEALER AI ─── */
function bsrDealerTurn() {
  const s = bsrState;
  if(!s || !s.active) return;
  // Guard: if shells exhausted mid-turn
  if(s.shellIndex >= s.shells.length) {
    bsrLog('📦 All shells spent! Reloading...');
    setTimeout(() => bsrShowRoundSplash(s.round, () => bsrNewRound()), 1000);
    return;
  }

  bsrSetStatus("🤖 Dealer is thinking...");
  s.animating = true;
  bsrDisableActions();
  bsrRender();

  // Dealer uses items one at a time with delays
  setTimeout(() => bsrDealerItemLoop(() => bsrDealerShoot()), 1200);
}

function bsrDealerItemLoop(callback) {
  const s = bsrState;
  if(!s || !s.active || !s.dealerItems.length) { callback(); return; }

  // Priority: magnifying > saw (if know live) > cigarettes (if hurt) > handcuffs > phone
  let used = false;

  // 1. Magnifying glass — always use if available
  const mgIdx = s.dealerItems.indexOf('magnifying');
  if(mgIdx !== -1) {
    s.dealerItems.splice(mgIdx, 1);
    s._dealerKnowsCurrent = s.shells[s.shellIndex];
    bsrLog('🤖🔍 Dealer peers through a magnifying glass...');
    bsrRender();
    used = true;
    setTimeout(() => bsrDealerItemLoop(callback), 1100);
    return;
  }

  // 2. Saw — use if dealer knows current is live
  const sawIdx = s.dealerItems.indexOf('saw');
  if(sawIdx !== -1 && s._dealerKnowsCurrent === 'live') {
    s.dealerItems.splice(sawIdx, 1);
    s.sawActive = true;
    bsrLog('🤖🪚 Dealer saws the barrel! Next live = 2 damage.');
    bsrRender();
    used = true;
    setTimeout(() => bsrDealerItemLoop(callback), 1100);
    return;
  }

  // 3. Cigarettes — use if HP below max
  const cigIdx = s.dealerItems.indexOf('cigarettes');
  if(cigIdx !== -1 && s.dealerHP < s.dealerMaxHP) {
    s.dealerItems.splice(cigIdx, 1);
    s.dealerHP = Math.min(s.dealerHP + 1, s.dealerMaxHP);
    bsrLog('🤖🚬 Dealer lights a cigarette. +1 HP (' + s.dealerHP + '/' + s.dealerMaxHP + ')');
    bsrRender();
    used = true;
    setTimeout(() => bsrDealerItemLoop(callback), 1100);
    return;
  }

  // 4. Handcuffs — use ~50% of the time
  const hcIdx = s.dealerItems.indexOf('handcuffs');
  if(hcIdx !== -1 && s.playerHandcuffed <= 0 && Math.random() < 0.5) {
    s.dealerItems.splice(hcIdx, 1);
    s.playerHandcuffed = 1;
    bsrLog('🤖🔗 Dealer slaps handcuffs on you! Skip next turn.');
    bsrSetStatus('You are handcuffed!');
    bsrRender();
    used = true;
    setTimeout(() => bsrDealerItemLoop(callback), 1100);
    return;
  }

  // 5. Phone — use ~40% of the time
  const phoneIdx = s.dealerItems.indexOf('phone');
  if(phoneIdx !== -1 && Math.random() < 0.4) {
    s.dealerItems.splice(phoneIdx, 1);
    bsrLog('🤖📱 Dealer makes a phone call... (intel hidden)');
    // Actually give dealer info about a random future shell
    const rem = s.shells.slice(s.shellIndex);
    if(rem.length > 1) {
      const fi = Math.floor(Math.random() * (rem.length - 1)) + 1;
      // Dealer doesn't share this info with player
    }
    bsrRender();
    used = true;
    setTimeout(() => bsrDealerItemLoop(callback), 1100);
    return;
  }

  // 6. Gummy — use if HP below max, 30% chance
  const gummyIdx = s.dealerItems.indexOf('gummy');
  if(gummyIdx !== -1 && s.dealerHP < s.dealerMaxHP && Math.random() < 0.3) {
    s.dealerItems.splice(gummyIdx, 1);
    if(Math.random() < 0.4) {
      const heal = Math.min(2, s.dealerMaxHP + 1 - s.dealerHP);
      s.dealerHP += heal;
      bsrLog('🤖🍬 Dealer ate Rotten Gummy... +' + heal + ' HP!');
    } else {
      s.dealerHP -= 1;
      bsrLog('🤖🍬 Dealer ate Rotten Gummy... −1 HP (' + s.dealerHP + ')');
      if(s.dealerHP <= 0) {
        bsrRender();
        setTimeout(() => bsrRoundWin(), 1200);
        return;
      }
    }
    bsrRender();
    used = true;
    setTimeout(() => bsrDealerItemLoop(callback), 1100);
    return;
  }

  // No more items to use
  callback();
}

function bsrDealerShoot() {
  const s = bsrState;
  if(!s || !s.active) return;
  // Guard: shells might be exhausted
  if(s.shellIndex >= s.shells.length) {
    bsrLog('📦 All shells spent! Reloading...');
    s.animating = false;
    setTimeout(() => bsrShowRoundSplash(s.round, () => bsrNewRound()), 1000);
    return;
  }

  const shell = s.shells[s.shellIndex];
  s.shellIndex++;
  s.animating = true;

  // Dealer decides target
  let target = 'player';
  if(s._dealerKnowsCurrent === 'blank') {
    target = 'self';
  } else if(s._dealerKnowsCurrent === 'live') {
    target = 'player';
  } else {
    // Heuristic: count live/blank ratio in remaining shells (before this shot)
    const allRemaining = s.shells.slice(s.shellIndex - 1); // include current
    const liveR = allRemaining.filter(x => x === 'live').length / allRemaining.length;
    target = liveR < 0.4 ? 'self' : 'player';
  }
  s._dealerKnowsCurrent = null;

  const damage = shell === 'live' ? (s.sawActive ? 2 : 1) : 0;
  if(shell === 'live') s.sawActive = false; // saw only consumed when it fires (live shell)

  bsrSetStatus('🤖 Dealer aims at ' + (target === 'player' ? 'YOU' : 'ITSELF') + '...');

  // Dramatic pause
  setTimeout(() => {
    // Animate
    bsrAnimateShotgun(target === 'player' ? 'left' : 'right', shell === 'live');
    if(shell === 'live') {
      playSound(120, 'sawtooth', 0.35, 0.18);
      setTimeout(() => playSound(80, 'square', 0.2, 0.08), 100);
    } else {
      playSound(600, 'sine', 0.08, 0.05);
    }

    setTimeout(() => {
      if(target === 'player') {
        if(shell === 'live') {
          s.playerHP -= damage;
          bsrAnimateHit('player');
          bsrLog(`🤖🔫 Dealer shot you — LIVE! ${damage > 1 ? '🪚 2 dmg! ' : ''}You: ${Math.max(0,s.playerHP)} HP`);
          bsrSetStatus(`💥 Dealer hits you for ${damage}!`);
        } else {
          bsrLog('🤖🔫 Dealer shot you — BLANK. No damage.');
          bsrSetStatus('*click* — Dealer missed. BLANK!');
        }
        s.turn = 'player';
      } else {
        if(shell === 'live') {
          s.dealerHP -= damage;
          bsrAnimateHit('dealer');
          bsrLog(`🤖🫵 Dealer shot itself — LIVE! ${damage > 1 ? '🪚 2 dmg! ' : ''}Dealer: ${Math.max(0,s.dealerHP)} HP`);
          bsrSetStatus('Dealer shot itself! LIVE!');
          s.turn = 'player';
        } else {
          bsrLog('🤖🫵 Dealer shot itself — BLANK! Extra turn.');
          bsrSetStatus('*click* — Dealer gets another turn.');
          s.turn = 'dealer';
        }
      }

      s.animating = false;
      bsrRender();

      if(s.playerHP <= 0) { setTimeout(() => bsrEndGame(false), 1200); return; }
      if(s.dealerHP <= 0) { setTimeout(() => bsrRoundWin(), 1200); return; }
      if(s.shellIndex >= s.shells.length) {
        bsrLog('📦 All shells spent! Reloading...');
        setTimeout(() => bsrShowRoundSplash(s.round, () => bsrNewRound()), 1500);
        return;
      }

      bsrResolveTurn();
    }, 1100);
  }, 800);
}

/* ─── ROUND WIN ─── */
function bsrRoundWin() {
  const s = bsrState;
  if(!s || !s.active) return; // guard against double-calls
  if(s.round >= s.maxRounds) {
    bsrEndGame(true);
    return;
  }
  bsrLog(`✅ ROUND ${s.round} WON! The Dealer is down.`);
  s.round++;
  // Scale dealer HP each round (+1 per round past first)
  const diff = BSR_DIFF[s.diff];
  s.dealerHP = diff.hp + (s.round - 1);
  s.dealerMaxHP = diff.hp + (s.round - 1);
  // Heal player a bit (2 HP, capped at max)
  s.playerHP = Math.min(s.playerHP + 2, s.playerMaxHP);

  bsrSetStatus('Round won! Advancing...');
  bsrRender();

  setTimeout(() => {
    bsrShowRoundSplash(s.round, () => bsrNewRound());
  }, 1200);
}

/* ─── END GAME ─── */
function bsrEndGame(won) {
  const s = bsrState;
  if(!s || !s.active) return; // guard against double-calls from async paths
  s.active = false;

  const overlay = document.getElementById('bsrGameOver');
  overlay.style.display = 'flex';

  if(won) {
    const winnings = Math.floor(s.bet * s.mult);
    balance += winnings;
    updateBalDisplay();
    recordGame('rusroulette', s.bet, winnings);

    // Update stats
    bsrStats.wins++;
    bsrStats.streak++;
    if(bsrStats.streak > bsrStats.bestStreak) bsrStats.bestStreak = bsrStats.streak;
    if(winnings > bsrStats.biggestWin) bsrStats.biggestWin = winnings;
    bsrSaveStats();

    document.getElementById('bsrGameOverContent').innerHTML = `
      <div style="font-size:72px;margin-bottom:16px;">🏆</div>
      <div style="font-family:'Orbitron';font-size:30px;color:var(--green);font-weight:900;margin-bottom:8px;">YOU WIN!</div>
      <div style="font-size:13px;color:var(--text2);margin-bottom:4px;">Survived all ${s.maxRounds} rounds on ${BSR_DIFF[s.diff].label}</div>
      <div style="font-size:13px;color:var(--text2);margin-bottom:16px;">${s.mult}× multiplier</div>
      <div style="font-size:28px;color:var(--gold);font-weight:900;margin-bottom:6px;">+$${winnings.toLocaleString()}</div>
      <div style="font-size:12px;color:var(--text2);margin-bottom:20px;">Streak: ${bsrStats.streak} 🔥</div>
      <button onclick="bsrCloseGameOver()" class="action-btn primary" style="padding:14px 32px;font-size:15px;font-family:'Orbitron';">PLAY AGAIN</button>
    `;
  } else {
    recordGame('rusroulette', s.bet, 0);
    bsrStats.losses++;
    bsrStats.streak = 0;
    bsrSaveStats();

    document.getElementById('bsrGameOverContent').innerHTML = `
      <div style="font-size:72px;margin-bottom:16px;">💀</div>
      <div style="font-family:'Orbitron';font-size:30px;color:var(--red);font-weight:900;margin-bottom:8px;">YOU DIED</div>
      <div style="font-size:13px;color:var(--text2);margin-bottom:4px;">Eliminated in Round ${s.round}/${s.maxRounds} on ${BSR_DIFF[s.diff].label}</div>
      <div style="font-size:28px;color:var(--red);font-weight:900;margin-bottom:20px;">-$${s.bet.toLocaleString()}</div>
      <button onclick="bsrCloseGameOver()" class="action-btn primary" style="padding:14px 32px;font-size:15px;font-family:'Orbitron';">TRY AGAIN</button>
    `;
  }
}

function bsrCloseGameOver() {
  document.getElementById('bsrGameOver').style.display = 'none';
  bsrState = null;
  document.getElementById('bsrLobby').style.display = 'block';
  document.getElementById('bsrGame').style.display = 'none';
  document.getElementById('bsrRoundSplash').style.display = 'none';
  bsrUpdateStats();
}

// ============ RUSSIAN ROULETTE ============
let rrState = null;
const RR_DIFF = {
  easy:   { rounds: 3, mult: 2, label: 'EASY',   icon: '😎' },
  normal: { rounds: 5, mult: 4, label: 'NORMAL', icon: '💀' },
  hard:   { rounds: 8, mult: 8, label: 'HARD',   icon: '☠️' }
};
let rrDiff = 'easy';
let rrMode = 'bot';

function rrSwitchMode(mode, tab) {
  rrMode = mode;
  document.querySelectorAll('#russianrPanel .inv-tab').forEach(t => t.classList.remove('active'));
  tab.classList.add('active');
  document.getElementById('rrBotLobby').style.display = mode === 'bot' ? 'block' : 'none';
  document.getElementById('rrPvpLobby').style.display = mode === 'pvp' ? 'block' : 'none';
  document.getElementById('rrGameArea').style.display = 'none';
  document.getElementById('rrGameOver').style.display = 'none';
}

function rrSelectDiff(d, el) {
  rrDiff = d;
  document.querySelectorAll('#rrBotLobby .bsr-diff-card').forEach(c => c.classList.remove('selected'));
  el.classList.add('selected');
}

function initRussianRoulette() {
  document.getElementById('rrBotLobby').style.display = rrMode === 'bot' ? 'block' : 'none';
  document.getElementById('rrPvpLobby').style.display = rrMode === 'pvp' ? 'block' : 'none';
  document.getElementById('rrGameArea').style.display = 'none';
  document.getElementById('rrGameOver').style.display = 'none';
  rrUpdateStats();
}

function rrUpdateStats() {
  // stats are tracked via gameStats.russianr
}

function rrLog(msg, color) {
  const log = document.getElementById('rrLog');
  const d = document.createElement('div');
  d.style.cssText = 'padding:4px 8px;border-bottom:1px solid rgba(255,255,255,0.05);font-size:12px;';
  if (color) d.style.color = color;
  d.textContent = msg;
  log.prepend(d);
}

// ---- Chamber mechanics ----
function rrNewCylinder() {
  // Place 1 bullet randomly in 6 chambers
  const chambers = [0, 0, 0, 0, 0, 0];
  chambers[Math.floor(Math.random() * 6)] = 1;
  return { chambers, pos: 0, remaining: 6 };
}

function rrPullChamber(cyl) {
  const hit = cyl.chambers[cyl.pos] === 1;
  cyl.pos = (cyl.pos + 1) % 6;
  cyl.remaining--;
  return hit;
}

function rrSpinCylinderMech(cyl) {
  // Re-randomize
  cyl.chambers = [0, 0, 0, 0, 0, 0];
  cyl.chambers[Math.floor(Math.random() * 6)] = 1;
  cyl.pos = 0;
  cyl.remaining = 6;
}

// ---- Bot AI ----
function rrBotDecision(cyl, roundNum, totalRounds) {
  // Bot weighs risk: if remaining chambers are few and bullet hasn't fired, more likely to spin
  const hitChance = 1 / Math.max(1, cyl.remaining);
  // Easy bot: plays dumber (less likely to spin)
  // Hard bot: smarter (spins when risk > 40%)
  let spinThreshold;
  if (rrDiff === 'easy') spinThreshold = 0.65;
  else if (rrDiff === 'normal') spinThreshold = 0.45;
  else spinThreshold = 0.35;
  
  // Random factor
  if (hitChance >= spinThreshold && Math.random() < 0.6) return 'spin';
  return 'pull';
}

// ---- BOT START ----
function rrStartBot() {
  const betEl = document.getElementById('rrBet');
  const bet = parseInt(betEl.value);
  if (!bet || bet < 10) return showToast('Min bet is $10', false);
  if (!checkMaxBet(bet, 'russianr')) return;

  const diff = RR_DIFF[rrDiff];
  rrState = {
    mode: 'bot',
    bet,
    diff: rrDiff,
    totalRounds: diff.rounds,
    currentRound: 1,
    mult: diff.mult,
    cylinder: rrNewCylinder(),
    playerTurn: Math.random() < 0.5,
    playerAlive: true,
    dealerAlive: true,
    roundKills: 0,      // track kills across rounds
    gameOver: false,
    paused: false
  };

  balance -= bet;
  updateBalDisplay();

  document.getElementById('rrBotLobby').style.display = 'none';
  document.getElementById('rrPvpLobby').style.display = 'none';
  document.getElementById('rrGameArea').style.display = 'block';
  document.getElementById('rrGameOver').style.display = 'none';
  document.getElementById('rrLog').innerHTML = '';
  document.getElementById('rrOpponentLabel').textContent = '🤖 DEALER';

  rrUpdateUI();
  rrLog(`Game started — ${diff.label} difficulty (${diff.rounds} rounds, ${diff.mult}× payout)`, 'var(--gold)');
  rrLog(`Round 1 — New cylinder loaded!`, 'var(--neon)');
  rrAnimateNewRound();

  if (!rrState.playerTurn) {
    rrLog('Dealer goes first...', 'var(--text2)');
    rrDisableActions();
    setTimeout(() => rrBotTurn(), 1500);
  } else {
    rrLog('You go first!', 'var(--green)');
    rrEnableActions();
  }
}

function rrUpdateUI() {
  if (!rrState) return;
  const s = rrState;
  document.getElementById('rrRoundInfo').textContent = `ROUND ${s.currentRound} / ${s.totalRounds}`;
  document.getElementById('rrMultInfo').textContent = `🏆 ${s.mult}× ($${Math.floor(s.bet * s.mult).toLocaleString()})`;
  
  // Chamber info
  const chamberDots = [];
  for (let i = 0; i < 6; i++) {
    if (i < s.cylinder.pos) chamberDots.push('⚫'); // already fired (empty)
    else chamberDots.push('🔴'); // unknown
  }
  document.getElementById('rrChamberInfo').textContent = chamberDots.join(' ') + ` (${s.cylinder.remaining} left)`;
  
  // Player status
  document.getElementById('rrPlayerStatus').textContent = s.playerAlive ? (s.playerTurn ? '😰' : '😐') : '💀';
  document.getElementById('rrPlayerAlive').textContent = s.playerAlive ? 'ALIVE' : 'DEAD';
  document.getElementById('rrPlayerAlive').style.color = s.playerAlive ? 'var(--green)' : 'var(--red)';
  document.getElementById('rrPlayerCard').style.borderColor = s.playerTurn && !s.gameOver ? 'var(--neon)' : 'var(--border)';
  document.getElementById('rrPlayerCard').style.boxShadow = s.playerTurn && !s.gameOver ? '0 0 20px rgba(0,240,255,.2)' : 'none';
  
  // Dealer status
  document.getElementById('rrDealerStatus').textContent = s.dealerAlive ? (!s.playerTurn ? '😈' : '😐') : '💀';
  document.getElementById('rrDealerAlive').textContent = s.dealerAlive ? 'ALIVE' : 'DEAD';
  document.getElementById('rrDealerAlive').style.color = s.dealerAlive ? 'var(--green)' : 'var(--red)';
  document.getElementById('rrDealerCard').style.borderColor = !s.playerTurn && !s.gameOver ? 'rgba(255,68,68,.5)' : 'var(--border)';
  document.getElementById('rrDealerCard').style.boxShadow = !s.playerTurn && !s.gameOver ? '0 0 20px rgba(255,68,68,.2)' : 'none';
}

function rrEnableActions() {
  document.getElementById('rrPullBtn').disabled = false;
  document.getElementById('rrSpinBtn').disabled = false;
  document.getElementById('rrPullBtn').style.opacity = '1';
  document.getElementById('rrSpinBtn').style.opacity = '1';
}

function rrDisableActions() {
  document.getElementById('rrPullBtn').disabled = true;
  document.getElementById('rrSpinBtn').disabled = true;
  document.getElementById('rrPullBtn').style.opacity = '0.4';
  document.getElementById('rrSpinBtn').style.opacity = '0.4';
}

function rrAnimateNewRound() {
  const rev = document.getElementById('rrRevolver');
  rev.style.transform = 'rotate(0deg)';
  setTimeout(() => { rev.style.transform = 'rotate(720deg)'; }, 50);
  setTimeout(() => { rev.style.transform = 'rotate(0deg)'; }, 600);
}

function rrAnimateShot(hit) {
  const rev = document.getElementById('rrRevolver');
  if (hit) {
    rev.style.transform = 'scale(1.3) rotate(-10deg)';
    setTimeout(() => { rev.style.transform = 'scale(1) rotate(0deg)'; }, 400);
  } else {
    rev.style.transform = 'rotate(15deg)';
    setTimeout(() => { rev.style.transform = 'rotate(0deg)'; }, 300);
  }
}

function rrShakeScreen() {
  const area = document.getElementById('rrGameArea');
  area.style.animation = 'none';
  area.offsetHeight;
  area.style.animation = 'bsr-shake .5s ease-out';
}

// ---- Player actions ----
function rrPullTrigger() {
  if (!rrState || rrState.gameOver || !rrState.playerTurn || rrState.paused) return;
  rrDisableActions();
  rrState.paused = true;
  
  playSound(200, 'triangle', 0.1, 0.3);
  
  setTimeout(() => {
    const hit = rrPullChamber(rrState.cylinder);
    rrAnimateShot(hit);
    
    if (hit) {
      // BANG!
      playSound(80, 'sawtooth', 0.4, 0.7);
      rrShakeScreen();
      rrState.playerAlive = false;
      rrState.playerTurn = false;
      rrLog('💥 BANG! The bullet fires — YOU\'RE HIT!', '#ff4444');
      rrUpdateUI();
      setTimeout(() => rrEndRound('dealer'), 1200);
    } else {
      // Click...
      playSound(600, 'sine', 0.08, 0.4);
      rrLog('🔘 *click* — Empty chamber. You survive!', 'var(--green)');
      rrState.playerTurn = false;
      rrUpdateUI();
      rrState.paused = false;
      // Dealer's turn
      setTimeout(() => rrBotTurn(), 1200);
    }
  }, 800);
}

function rrSpinCylinder() {
  if (!rrState || rrState.gameOver || !rrState.playerTurn || rrState.paused) return;
  rrDisableActions();
  rrState.paused = true;
  
  playSound(400, 'sine', 0.3, 0.3);
  rrAnimateNewRound();
  
  setTimeout(() => {
    rrSpinCylinderMech(rrState.cylinder);
    rrLog('🔄 You spin the cylinder — reset to 6 chambers!', 'var(--neon)');
    rrUpdateUI();
    rrState.playerTurn = false;
    rrState.paused = false;
    // Dealer's turn
    setTimeout(() => rrBotTurn(), 1200);
  }, 800);
}

// ---- Bot turn ----
function rrBotTurn() {
  if (!rrState || rrState.gameOver) return;
  rrDisableActions();
  rrState.paused = true;
  
  const decision = rrBotDecision(rrState.cylinder, rrState.currentRound, rrState.totalRounds);
  
  if (decision === 'spin') {
    rrLog('🤖 Dealer spins the cylinder...', 'var(--text2)');
    playSound(400, 'sine', 0.3, 0.3);
    rrAnimateNewRound();
    setTimeout(() => {
      rrSpinCylinderMech(rrState.cylinder);
      rrLog('🔄 Cylinder reset to 6 chambers!', 'var(--text2)');
      rrUpdateUI();
      rrState.playerTurn = true;
      rrState.paused = false;
      rrUpdateUI();
      rrEnableActions();
      rrLog('Your turn — pull the trigger or spin!', 'var(--gold)');
    }, 1000);
  } else {
    rrLog('🤖 Dealer grabs the gun... pulls the trigger...', 'var(--text2)');
    
    setTimeout(() => {
      const hit = rrPullChamber(rrState.cylinder);
      rrAnimateShot(hit);
      
      if (hit) {
        playSound(80, 'sawtooth', 0.4, 0.7);
        rrShakeScreen();
        rrState.dealerAlive = false;
        rrLog('💥 BANG! The dealer takes the bullet! 💀', '#ff4444');
        rrUpdateUI();
        setTimeout(() => rrEndRound('player'), 1200);
      } else {
        playSound(600, 'sine', 0.08, 0.4);
        rrLog('🔘 *click* — Dealer survives...', 'var(--text2)');
        rrState.playerTurn = true;
        rrUpdateUI();
        rrState.paused = false;
        rrEnableActions();
        rrLog('Your turn — pull the trigger or spin!', 'var(--gold)');
      }
    }, 1200);
  }
}

// ---- Round/game end ----
function rrEndRound(winner) {
  if (!rrState) return;
  const s = rrState;
  
  rrLog(`— Round ${s.currentRound} winner: ${winner === 'player' ? 'YOU' : 'DEALER'} —`, winner === 'player' ? 'var(--green)' : 'var(--red)');
  
  if (s.currentRound >= s.totalRounds) {
    rrEndGame(winner);
    return;
  }
  
  // If player died, game over
  if (!s.playerAlive) {
    rrEndGame('dealer');
    return;
  }
  
  // If dealer died, check if more rounds
  if (!s.dealerAlive) {
    // Continue to next round
    s.currentRound++;
    s.dealerAlive = true;
    s.playerAlive = true;
    s.cylinder = rrNewCylinder();
    s.playerTurn = Math.random() < 0.5;
    
    rrLog(`Round ${s.currentRound} — New cylinder loaded!`, 'var(--neon)');
    rrAnimateNewRound();
    rrUpdateUI();
    
    setTimeout(() => {
      rrState.paused = false;
      if (s.playerTurn) {
        rrLog('You go first!', 'var(--green)');
        rrEnableActions();
      } else {
        rrLog('Dealer goes first...', 'var(--text2)');
        rrBotTurn();
      }
    }, 1000);
    return;
  }
  
  // Player died
  rrEndGame('dealer');
}

function rrEndGame(winner) {
  if (!rrState) return;
  rrState.gameOver = true;
  rrDisableActions();
  
  const s = rrState;
  const diff = RR_DIFF[s.diff];
  const won = winner === 'player';
  const winAmount = won ? Math.floor(s.bet * s.mult) : 0;
  
  if (won) {
    balance += winAmount;
    updateBalDisplay();
    if (winAmount > gameStats.russianr.biggestWin) gameStats.russianr.biggestWin = winAmount;
    gameStats.russianr.won++;
  }
  gameStats.russianr.played++;
  recordGame('russianr', s.bet, winAmount);
  
  setTimeout(() => {
    const box = document.getElementById('rrGameOverContent');
    if (won) {
      playWinSound();
      box.innerHTML = `
        <div style="font-size:60px;margin-bottom:12px;">🏆</div>
        <div style="font-family:'Orbitron';font-size:22px;color:var(--green);margin-bottom:8px;">YOU SURVIVED!</div>
        <div style="font-size:14px;color:var(--text2);margin-bottom:8px;">The dealer takes the bullet. You walk away alive.</div>
        <div style="font-family:'Orbitron';font-size:28px;color:var(--gold);margin-bottom:6px;">+$${winAmount.toLocaleString()}</div>
        <div style="font-size:12px;color:var(--text2);margin-bottom:16px;">${diff.label} ${diff.icon} • ${diff.mult}× Multiplier</div>
        <button onclick="rrCloseGameOver()" class="action-btn primary" style="padding:14px 32px;font-size:15px;font-family:'Orbitron';">PLAY AGAIN</button>`;
      spawnParticles(window.innerWidth / 2, window.innerHeight / 2, 40);
      if (winAmount >= s.bet * 4) showBigWin(winAmount);
    } else {
      playLoseSound();
      box.innerHTML = `
        <div style="font-size:60px;margin-bottom:12px;">💀</div>
        <div style="font-family:'Orbitron';font-size:22px;color:var(--red);margin-bottom:8px;">YOU'RE DEAD</div>
        <div style="font-size:14px;color:var(--text2);margin-bottom:8px;">The bullet found you. Better luck next life.</div>
        <div style="font-family:'Orbitron';font-size:28px;color:var(--red);margin-bottom:6px;">-$${s.bet.toLocaleString()}</div>
        <div style="font-size:12px;color:var(--text2);margin-bottom:16px;">${diff.label} ${diff.icon} • Round ${s.currentRound}/${s.totalRounds}</div>
        <button onclick="rrCloseGameOver()" class="action-btn primary" style="padding:14px 32px;font-size:15px;font-family:'Orbitron';">TRY AGAIN</button>`;
    }
    document.getElementById('rrGameOver').style.display = 'flex';
  }, 800);
}

function rrCloseGameOver() {
  document.getElementById('rrGameOver').style.display = 'none';
  rrState = null;
  document.getElementById('rrBotLobby').style.display = rrMode === 'bot' ? 'block' : 'none';
  document.getElementById('rrPvpLobby').style.display = rrMode === 'pvp' ? 'block' : 'none';
  document.getElementById('rrGameArea').style.display = 'none';
}

// ============ RUSSIAN ROULETTE PVP ============
let rrPvpListener = null;
let rrPvpUnsubscribe = null;

async function rrStartPvP() {
  const bet = parseInt(document.getElementById('rrPvpBet').value);
  if (!bet || bet < 10) return showToast('Min bet is $10', false);
  if (!checkMaxBet(bet, 'russianr')) return;
  
  const opName = document.getElementById('rrPvpOpponent').value.trim().toLowerCase();
  if (!opName) return showToast('Enter opponent username', false);
  if (opName === (window._currentUsername || '').toLowerCase()) return showToast('Cannot challenge yourself', false);
  
  const statusEl = document.getElementById('rrPvpStatus');
  statusEl.textContent = 'Sending challenge...';
  
  try {
    const nameSnap = await window._fbGet('casino/usernames/' + opName);
    if (!nameSnap.exists()) { statusEl.textContent = 'Player not found!'; return; }
    const opUid = nameSnap.val();
    if (opUid === window._currentPlayerId) { statusEl.textContent = 'Cannot challenge yourself'; return; }
    
    const bSnap = await window._fbGet('casino/players/' + opUid + '/balance');
    const opBal = bSnap.val() || 0;
    if (opBal < bet) { statusEl.textContent = 'Opponent cannot afford that wager!'; return; }
    
    const gameId = Date.now().toString(36) + Math.random().toString(36).slice(2, 6);
    const gameData = {
      host: window._currentPlayerId,
      hostName: window._currentUsername,
      guest: opUid,
      guestName: opName,
      bet: bet,
      status: 'pending',
      cylinder: null,
      currentTurn: null,
      round: 1,
      totalRounds: 5,
      hostAlive: true,
      guestAlive: true,
      created: Date.now()
    };
    
    await window._fbSet('casino/rrGames/' + gameId, gameData);
    
    balance -= bet;
    updateBalDisplay();
    
    const notifKey = Date.now().toString(36) + Math.random().toString(36).slice(2, 4);
    await window._fbSet('casino/players/' + opUid + '/notifications/' + notifKey, {
      type: 'rr_challenge',
      from: window._currentUsername,
      fromUid: window._currentPlayerId,
      gameId: gameId,
      bet: bet,
      time: Date.now()
    });
    
    statusEl.innerHTML = `Challenge sent to <b>${opName}</b>! Waiting...<br><button class="action-btn" onclick="rrCancelPvP('${gameId}',${bet})" style="margin-top:8px;padding:6px 16px;font-size:11px;">Cancel</button>`;
    
    rrPvpUnsubscribe = window._fbOnValue('casino/rrGames/' + gameId, snap => {
      const g = snap.val();
      if (!g) return;
      if (g.status === 'active') rrJoinPvPGame(gameId);
      if (g.status === 'declined') {
        statusEl.textContent = 'Challenge declined.';
        balance += bet;
        updateBalDisplay();
        rrCleanupPvP();
      }
    });
  } catch(e) {
    statusEl.textContent = 'Error: ' + e.message;
  }
}

function rrCancelPvP(gameId, bet) {
  window._fbRemove('casino/rrGames/' + gameId);
  balance += bet || (rrState ? rrState.bet : parseInt(document.getElementById('rrPvpBet').value));
  updateBalDisplay();
  rrCleanupPvP();
  document.getElementById('rrPvpStatus').textContent = 'Challenge cancelled.';
}

async function rrAcceptPvPChallenge(gameId, bet) {
  if (!checkMaxBet(bet, 'russianr')) return;
  
  balance -= bet;
  updateBalDisplay();
  
  const chambers = [0, 0, 0, 0, 0, 0];
  chambers[Math.floor(Math.random() * 6)] = 1;
  const hostFirst = Math.random() < 0.5;
  
  await window._fbUpdate('casino/rrGames/' + gameId, {
    status: 'active',
    cylinder: chambers.join(','),
    cylinderPos: 0,
    currentTurn: hostFirst ? 'host' : 'guest',
    round: 1,
    hostAlive: true,
    guestAlive: true
  });
  
  switchGame('russianr');
  rrJoinPvPGame(gameId);
}

function rrJoinPvPGame(gameId) {
  document.getElementById('rrBotLobby').style.display = 'none';
  document.getElementById('rrPvpLobby').style.display = 'none';
  document.getElementById('rrGameArea').style.display = 'block';
  document.getElementById('rrGameOver').style.display = 'none';
  document.getElementById('rrLog').innerHTML = '';
  
  rrCleanupPvP();
  
  let endHandled = false;
  
  rrPvpUnsubscribe = window._fbOnValue('casino/rrGames/' + gameId, snap => {
    const g = snap.val();
    if (!g) return;
    
    const myId = window._currentPlayerId;
    const isHost = g.host === myId;
    const opName = isHost ? g.guestName : g.hostName;
    document.getElementById('rrOpponentLabel').textContent = '👤 ' + opName.toUpperCase();
    
    const myTurn = (g.currentTurn === 'host' && isHost) || (g.currentTurn === 'guest' && !isHost);
    const myAlive = isHost ? g.hostAlive : g.guestAlive;
    const opAlive = isHost ? g.guestAlive : g.hostAlive;
    
    rrState = {
      mode: 'pvp',
      bet: g.bet,
      diff: 'normal',
      totalRounds: g.totalRounds || 5,
      currentRound: g.round || 1,
      mult: 2,
      cylinder: { remaining: 6 - (g.cylinderPos || 0), pos: g.cylinderPos || 0 },
      playerTurn: myTurn,
      playerAlive: myAlive,
      dealerAlive: opAlive,
      gameOver: g.status === 'finished',
      pvpGameId: gameId,
      pvpIsHost: isHost
    };
    
    document.getElementById('rrRoundInfo').textContent = `ROUND ${g.round || 1} / ${g.totalRounds || 5}`;
    document.getElementById('rrMultInfo').textContent = `🏆 POT: $${(g.bet * 2).toLocaleString()}`;
    rrUpdateUI();
    
    if (myTurn && !rrState.gameOver && myAlive && opAlive) rrEnableActions();
    else rrDisableActions();
    
    if (g.lastAction) {
      const la = g.lastAction;
      if (la.type === 'pull') {
        if (la.hit) { rrAnimateShot(true); rrShakeScreen(); playSound(80, 'sawtooth', 0.4, 0.7); }
        else { rrAnimateShot(false); playSound(600, 'sine', 0.08, 0.4); }
      } else if (la.type === 'spin') { rrAnimateNewRound(); playSound(400, 'sine', 0.3, 0.3); }
    }
    
    if (g.log) {
      const logEl = document.getElementById('rrLog');
      logEl.innerHTML = '';
      Object.values(g.log).slice(-20).reverse().forEach(l => {
        const d = document.createElement('div');
        d.style.cssText = 'padding:4px 8px;border-bottom:1px solid rgba(255,255,255,0.05);font-size:12px;';
        if (l.color) d.style.color = l.color;
        d.textContent = l.msg;
        logEl.appendChild(d);
      });
    }
    
    if (g.status === 'finished' && g.winner && !endHandled) {
      endHandled = true;
      const iWon = (g.winner === 'host' && isHost) || (g.winner === 'guest' && !isHost);
      if (iWon) {
        balance += g.bet * 2;
        updateBalDisplay();
        gameStats.russianr.won++;
        if (g.bet * 2 > gameStats.russianr.biggestWin) gameStats.russianr.biggestWin = g.bet * 2;
      }
      gameStats.russianr.played++;
      recordGame('russianr', g.bet, iWon ? g.bet * 2 : 0);
      
      setTimeout(() => {
        const box = document.getElementById('rrGameOverContent');
        if (iWon) {
          playWinSound();
          box.innerHTML = `<div style="font-size:60px;margin-bottom:12px;">🏆</div>
            <div style="font-family:'Orbitron';font-size:22px;color:var(--green);margin-bottom:8px;">YOU WIN!</div>
            <div style="font-size:14px;color:var(--text2);margin-bottom:8px;">${opName} took the bullet!</div>
            <div style="font-family:'Orbitron';font-size:28px;color:var(--gold);margin-bottom:16px;">+$${g.bet.toLocaleString()}</div>
            <button onclick="rrCloseGameOver();rrCleanupPvP();" class="action-btn primary" style="padding:14px 32px;">BACK TO LOBBY</button>`;
          spawnParticles(window.innerWidth / 2, window.innerHeight / 2, 30);
        } else {
          playLoseSound();
          box.innerHTML = `<div style="font-size:60px;margin-bottom:12px;">💀</div>
            <div style="font-family:'Orbitron';font-size:22px;color:var(--red);margin-bottom:8px;">YOU LOSE</div>
            <div style="font-size:14px;color:var(--text2);margin-bottom:8px;">The bullet found you...</div>
            <div style="font-family:'Orbitron';font-size:28px;color:var(--red);margin-bottom:16px;">-$${g.bet.toLocaleString()}</div>
            <button onclick="rrCloseGameOver();rrCleanupPvP();" class="action-btn primary" style="padding:14px 32px;">BACK TO LOBBY</button>`;
        }
        document.getElementById('rrGameOver').style.display = 'flex';
      }, 1000);
    }
  });
}

async function rrPvPAction(actionType) {
  if (!rrState || rrState.mode !== 'pvp' || !rrState.pvpGameId) return;
  const gameId = rrState.pvpGameId;
  const isHost = rrState.pvpIsHost;
  
  const snap = await window._fbGet('casino/rrGames/' + gameId);
  const g = snap.val();
  if (!g || g.status !== 'active') return;
  
  const myTurn = (g.currentTurn === 'host' && isHost) || (g.currentTurn === 'guest' && !isHost);
  if (!myTurn) return;
  
  const chambers = g.cylinder.split(',').map(Number);
  const pos = g.cylinderPos || 0;
  const myName = isHost ? g.hostName : g.guestName;
  const logKey = Date.now().toString(36) + Math.random().toString(36).slice(2, 4);
  
  if (actionType === 'spin') {
    const nc = [0, 0, 0, 0, 0, 0];
    nc[Math.floor(Math.random() * 6)] = 1;
    await window._fbSet('casino/rrGames/' + gameId + '/log/' + logKey, { msg: `🔄 ${myName} spins the cylinder!`, color: 'var(--neon)' });
    await window._fbUpdate('casino/rrGames/' + gameId, {
      cylinder: nc.join(','), cylinderPos: 0,
      currentTurn: isHost ? 'guest' : 'host',
      lastAction: { type: 'spin', by: myName }
    });
  } else {
    const hit = chambers[pos] === 1;
    const updates = { cylinderPos: pos + 1, currentTurn: isHost ? 'guest' : 'host', lastAction: { type: 'pull', by: myName, hit } };
    if (hit) {
      if (isHost) updates.hostAlive = false; else updates.guestAlive = false;
      await window._fbSet('casino/rrGames/' + gameId + '/log/' + logKey, { msg: `💥 BANG! ${myName} takes the bullet! 💀`, color: '#ff4444' });
      updates.status = 'finished';
      updates.winner = isHost ? 'guest' : 'host';
    } else {
      await window._fbSet('casino/rrGames/' + gameId + '/log/' + logKey, { msg: `🔘 *click* — ${myName} survives!`, color: 'var(--green)' });
    }
    await window._fbUpdate('casino/rrGames/' + gameId, updates);
  }
}

// PvP overrides for buttons
document.getElementById('rrPullBtn').addEventListener('click', function(e) {
  if (rrState && rrState.mode === 'pvp') { e.stopImmediatePropagation(); rrPvPAction('pull'); }
});
document.getElementById('rrSpinBtn').addEventListener('click', function(e) {
  if (rrState && rrState.mode === 'pvp') { e.stopImmediatePropagation(); rrPvPAction('spin'); }
});

function rrCleanupPvP() {
  if (rrPvpUnsubscribe) {
    try { rrPvpUnsubscribe(); } catch(e) {}
  }
  rrPvpUnsubscribe = null;
}

// Listen for incoming RR challenges via polling
let rrChallengeInterval = null;
function rrListenForChallenges() {
  if (!window._currentPlayerId) return;
  if (rrChallengeInterval) clearInterval(rrChallengeInterval);
  rrChallengeInterval = setInterval(async () => {
    try {
      const snap = await window._fbGet('casino/players/' + window._currentPlayerId + '/notifications');
      if (!snap.exists()) return;
      const notifs = snap.val();
      for (const [key, n] of Object.entries(notifs)) {
        if (n.type === 'rr_challenge' && n.gameId) {
          window._fbRemove('casino/players/' + window._currentPlayerId + '/notifications/' + key);
          const toastDiv = document.createElement('div');
          toastDiv.style.cssText = 'position:fixed;top:20%;left:50%;transform:translateX(-50%);z-index:99999;background:var(--surface);border:2px solid var(--gold);border-radius:16px;padding:24px;text-align:center;min-width:280px;box-shadow:0 0 40px rgba(0,0,0,.5);';
          toastDiv.innerHTML = `
            <div style="font-size:30px;margin-bottom:8px;">🔫</div>
            <div style="font-family:'Orbitron';font-size:16px;color:var(--gold);margin-bottom:8px;">RUSSIAN ROULETTE CHALLENGE</div>
            <div style="font-size:14px;color:var(--text);margin-bottom:4px;"><b>${n.from}</b> challenges you!</div>
            <div style="font-size:13px;color:var(--text2);margin-bottom:14px;">Wager: <span style="color:var(--gold);">$${n.bet.toLocaleString()}</span></div>
            <div style="display:flex;gap:10px;justify-content:center;">
              <button class="action-btn primary" onclick="this.closest('div[style]').remove();rrAcceptPvPChallenge('${n.gameId}',${n.bet});" style="padding:10px 20px;">✅ ACCEPT</button>
              <button class="action-btn" onclick="this.closest('div[style]').remove();rrDeclinePvPChallenge('${n.gameId}');" style="padding:10px 20px;">❌ DECLINE</button>
            </div>`;
          document.body.appendChild(toastDiv);
          setTimeout(() => { if (toastDiv.parentNode) toastDiv.remove(); }, 30000);
        }
      }
    } catch(e) {}
  }, 5000);
}

function rrDeclinePvPChallenge(gameId) {
  window._fbUpdate('casino/rrGames/' + gameId, { status: 'declined' });
}

// ============ MULTIPLAYER BUCKSHOT ROULETTE ============
let mpbsrUnsub = null;
let mpbsrGameId = null;
let mpbsrIsHost = false;
let mpbsrChallengeInterval = null;

const MPBSR_ITEMS = [
  { id: 'saw', icon: '🪚', name: 'Saw', desc: 'Next LIVE deals 2× damage' },
  { id: 'mag', icon: '🔍', name: 'Magnifying Glass', desc: 'Peek at current shell' },
  { id: 'cig', icon: '🚬', name: 'Cigarette', desc: 'Heal +1 HP' },
  { id: 'cuff', icon: '🔗', name: 'Handcuffs', desc: 'Opponent skips next turn' },
  { id: 'phone', icon: '📱', name: 'Burner Phone', desc: 'Reveals a random shell' }
];

function initMPBSR() {
  document.getElementById('mpbsrLobby').style.display = 'block';
  document.getElementById('mpbsrGameArea').style.display = 'none';
  document.getElementById('mpbsrGameOver').style.display = 'none';
  mpbsrStartChallengeListener();
}

function mpbsrStartChallengeListener() {
  if (mpbsrChallengeInterval) clearInterval(mpbsrChallengeInterval);
  mpbsrChallengeInterval = setInterval(async () => {
    if (!window._currentPlayerId) return;
    try {
      const snap = await window._fbGet('casino/players/' + window._currentPlayerId + '/notifications');
      if (!snap.exists()) return;
      const notifs = snap.val();
      for (const [key, n] of Object.entries(notifs)) {
        if (n.type === 'mpbsr_challenge' && n.gameId) {
          window._fbRemove('casino/players/' + window._currentPlayerId + '/notifications/' + key);
          const toastDiv = document.createElement('div');
          toastDiv.style.cssText = 'position:fixed;top:20%;left:50%;transform:translateX(-50%);z-index:99999;background:var(--surface);border:2px solid var(--gold);border-radius:16px;padding:24px;text-align:center;min-width:280px;box-shadow:0 0 40px rgba(0,0,0,.5);';
          toastDiv.innerHTML = `
            <div style="font-size:30px;margin-bottom:8px;">💥</div>
            <div style="font-family:'Orbitron';font-size:16px;color:var(--gold);margin-bottom:8px;">BUCKSHOT ROULETTE CHALLENGE</div>
            <div style="font-size:14px;color:var(--text);margin-bottom:4px;"><b>${n.from}</b> challenges you!</div>
            <div style="font-size:13px;color:var(--text2);margin-bottom:14px;">Wager: <span style="color:var(--gold);">$${n.bet.toLocaleString()}</span></div>
            <div style="display:flex;gap:10px;justify-content:center;">
              <button class="action-btn primary" onclick="this.closest('div[style]').remove();mpbsrAccept('${n.gameId}',${n.bet});" style="padding:10px 20px;">✅ ACCEPT</button>
              <button class="action-btn" onclick="this.closest('div[style]').remove();mpbsrDecline('${n.gameId}');" style="padding:10px 20px;">❌ DECLINE</button>
            </div>`;
          document.body.appendChild(toastDiv);
          setTimeout(() => { if (toastDiv.parentNode) toastDiv.remove(); }, 30000);
        }
      }
    } catch(e) {}
  }, 5000);
}


function mpbsrGenerateRound(roundNum) {
  // Generate shells and items for a round
  const shellCount = 4 + roundNum;
  const liveCount = 1 + Math.floor(Math.random() * Math.min(shellCount - 1, roundNum + 2));
  const blankCount = shellCount - liveCount;
  const shells = [];
  for (let i = 0; i < liveCount; i++) shells.push('live');
  for (let i = 0; i < blankCount; i++) shells.push('blank');
  // Shuffle
  for (let i = shells.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [shells[i], shells[j]] = [shells[j], shells[i]];
  }
  // Items per player: 2-4
  const itemCount = Math.min(2 + roundNum, 4);
  function randItems(n) {
    const items = [];
    for (let i = 0; i < n; i++) items.push(MPBSR_ITEMS[Math.floor(Math.random() * MPBSR_ITEMS.length)].id);
    return items;
  }
  return { shells, hostItems: randItems(itemCount), guestItems: randItems(itemCount), liveCount, blankCount };
}

async function mpbsrChallenge() {
  const bet = parseInt(document.getElementById('mpbsrBet').value);
  if (!bet || bet < 10) return showToast('Min bet is $10', false);
  if (!checkMaxBet(bet, 'mpbsr')) return;
  
  const opName = document.getElementById('mpbsrOpponent').value.trim().toLowerCase();
  if (!opName) return showToast('Enter opponent username', false);
  if (opName === (window._currentUsername || '').toLowerCase()) return showToast('Cannot challenge yourself', false);
  
  const statusEl = document.getElementById('mpbsrStatus');
  statusEl.textContent = 'Sending challenge...';
  
  try {
    const nameSnap = await window._fbGet('casino/usernames/' + opName);
    if (!nameSnap.exists()) { statusEl.textContent = 'Player not found!'; return; }
    const opUid = nameSnap.val();
    if (opUid === window._currentPlayerId) { statusEl.textContent = 'Cannot challenge yourself'; return; }
    
    const bSnap = await window._fbGet('casino/players/' + opUid + '/balance');
    if ((bSnap.val() || 0) < bet) { statusEl.textContent = 'Opponent cannot afford that wager!'; return; }
    
    const gameId = Date.now().toString(36) + Math.random().toString(36).slice(2, 6);
    const round1 = mpbsrGenerateRound(1);
    
    await window._fbSet('casino/bsrGames/' + gameId, {
      host: window._currentPlayerId,
      hostName: window._currentUsername,
      guest: opUid,
      guestName: opName,
      bet,
      status: 'pending',
      round: 1,
      shells: round1.shells.join(','),
      shellIdx: 0,
      liveCount: round1.liveCount,
      blankCount: round1.blankCount,
      hostHP: 4,
      guestHP: 4,
      hostItems: round1.hostItems.join(','),
      guestItems: round1.guestItems.join(','),
      currentTurn: Math.random() < 0.5 ? 'host' : 'guest',
      sawActive: false,
      cuffActive: false,
      created: Date.now()
    });
    
    balance -= bet;
    updateBalDisplay();
    
    const nk = Date.now().toString(36) + Math.random().toString(36).slice(2, 4);
    await window._fbSet('casino/players/' + opUid + '/notifications/' + nk, {
      type: 'mpbsr_challenge',
      from: window._currentUsername,
      fromUid: window._currentPlayerId,
      gameId,
      bet,
      time: Date.now()
    });
    
    statusEl.innerHTML = `Challenge sent to <b>${opName}</b>! Waiting...<br><button class="action-btn" onclick="mpbsrCancelChallenge('${gameId}',${bet})" style="margin-top:8px;padding:6px 16px;font-size:11px;">Cancel</button>`;
    
    mpbsrCleanup();
    mpbsrUnsub = window._fbOnValue('casino/bsrGames/' + gameId, snap => {
      const g = snap.val();
      if (!g) return;
      if (g.status === 'active') {
        mpbsrGameId = gameId;
        mpbsrIsHost = true;
        mpbsrJoinGame(gameId);
      }
      if (g.status === 'declined') {
        statusEl.textContent = 'Challenge declined.';
        balance += bet;
        updateBalDisplay();
        mpbsrCleanup();
      }
    });
  } catch(e) {
    statusEl.textContent = 'Error: ' + e.message;
  }
}

function mpbsrCancelChallenge(gameId, bet) {
  window._fbRemove('casino/bsrGames/' + gameId);
  balance += bet;
  updateBalDisplay();
  mpbsrCleanup();
  document.getElementById('mpbsrStatus').textContent = 'Cancelled.';
}

async function mpbsrAccept(gameId, bet) {
  if (!checkMaxBet(bet, 'mpbsr')) return;
  balance -= bet;
  updateBalDisplay();
  
  await window._fbUpdate('casino/bsrGames/' + gameId, { status: 'active' });
  
  mpbsrGameId = gameId;
  mpbsrIsHost = false;
  switchGame('mpbsr');
  mpbsrJoinGame(gameId);
}

function mpbsrDecline(gameId) {
  window._fbUpdate('casino/bsrGames/' + gameId, { status: 'declined' });
}

function mpbsrJoinGame(gameId) {
  document.getElementById('mpbsrLobby').style.display = 'none';
  document.getElementById('mpbsrGameArea').style.display = 'block';
  document.getElementById('mpbsrGameOver').style.display = 'none';
  document.getElementById('mpbsrLog').innerHTML = '';
  
  mpbsrCleanup();
  let endHandled = false;
  
  mpbsrUnsub = window._fbOnValue('casino/bsrGames/' + gameId, snap => {
    const g = snap.val();
    if (!g) return;
    
    const isHost = g.host === window._currentPlayerId;
    const opName = isHost ? g.guestName : g.hostName;
    document.getElementById('mpbsrOpLabel').textContent = opName.toUpperCase();
    
    const myHP = isHost ? g.hostHP : g.guestHP;
    const opHP = isHost ? g.guestHP : g.hostHP;
    const myItems = (isHost ? g.hostItems : g.guestItems) || '';
    const opItems = (isHost ? g.guestItems : g.hostItems) || '';
    const myTurn = (g.currentTurn === 'host' && isHost) || (g.currentTurn === 'guest' && !isHost);
    const shells = g.shells ? g.shells.split(',') : [];
    const shellIdx = g.shellIdx || 0;
    
    // Update UI
    document.getElementById('mpbsrRoundInfo').textContent = 'ROUND ' + (g.round || 1);
    document.getElementById('mpbsrPotInfo').textContent = 'POT: $' + (g.bet * 2).toLocaleString();
    document.getElementById('mpbsrShellInfo').textContent = (shells.length - shellIdx) + ' shells left';
    
    // Shell rack
    const rack = document.getElementById('mpbsrShellRack');
    rack.innerHTML = '';
    const rLive = shells.slice(shellIdx).filter(s => s === 'live').length;
    const rBlank = shells.slice(shellIdx).filter(s => s === 'blank').length;
    for (let i = 0; i < rLive; i++) {
      const d = document.createElement('div');
      d.className = 'bsr-shell bsr-shell-live';
      d.textContent = '🔴';
      rack.appendChild(d);
    }
    for (let i = 0; i < rBlank; i++) {
      const d = document.createElement('div');
      d.className = 'bsr-shell bsr-shell-blank';
      d.textContent = '🔵';
      rack.appendChild(d);
    }
    
    // HP
    document.getElementById('mpbsrMyHP').innerHTML = '❤️'.repeat(Math.max(0, myHP)) + '🖤'.repeat(Math.max(0, 4 - myHP));
    document.getElementById('mpbsrOpHP').innerHTML = '❤️'.repeat(Math.max(0, opHP)) + '🖤'.repeat(Math.max(0, 4 - opHP));
    
    // Items
    function renderItems(itemStr, containerId, usable) {
      const el = document.getElementById(containerId);
      el.innerHTML = '';
      if (!itemStr) return;
      itemStr.split(',').filter(Boolean).forEach((id, i) => {
        const item = MPBSR_ITEMS.find(it => it.id === id);
        if (!item) return;
        const btn = document.createElement('button');
        btn.className = 'bsr-item';
        btn.title = item.name + ': ' + item.desc;
        btn.textContent = item.icon;
        btn.style.fontSize = '18px';
        btn.style.padding = '6px 8px';
        btn.style.margin = '2px';
        btn.style.cursor = usable ? 'pointer' : 'default';
        btn.style.opacity = usable ? '1' : '0.5';
        if (usable) btn.onclick = () => mpbsrUseItem(i);
        el.appendChild(btn);
      });
    }
    renderItems(myItems, 'mpbsrMyItems', myTurn && g.status === 'active');
    renderItems(opItems, 'mpbsrOpItems', false);
    
    // Status
    const statusEl = document.getElementById('mpbsrStatusMsg');
    if (g.status === 'active') {
      statusEl.textContent = myTurn ? '🎯 YOUR TURN — Shoot or use an item!' : '⏳ Waiting for opponent...';
      statusEl.style.color = myTurn ? 'var(--gold)' : 'var(--text2)';
    }
    
    // Actions
    const canAct = myTurn && g.status === 'active' && myHP > 0 && opHP > 0;
    document.getElementById('mpbsrShootOp').disabled = !canAct;
    document.getElementById('mpbsrShootSelf').disabled = !canAct;
    document.getElementById('mpbsrShootOp').style.opacity = canAct ? '1' : '0.4';
    document.getElementById('mpbsrShootSelf').style.opacity = canAct ? '1' : '0.4';
    
    // Log
    if (g.log) {
      const logEl = document.getElementById('mpbsrLog');
      logEl.innerHTML = '';
      Object.values(g.log).slice(-20).reverse().forEach(l => {
        const d = document.createElement('div');
        d.className = 'bsr-log-line';
        d.style.fontSize = '12px';
        if (l.color) d.style.color = l.color;
        d.textContent = l.msg;
        logEl.appendChild(d);
      });
    }
    
    // Game over
    if (g.status === 'finished' && g.winner && !endHandled) {
      endHandled = true;
      const iWon = (g.winner === 'host' && isHost) || (g.winner === 'guest' && !isHost);
      if (iWon) {
        balance += g.bet * 2;
        updateBalDisplay();
        gameStats.mpbsr.won++;
        if (g.bet * 2 > gameStats.mpbsr.biggestWin) gameStats.mpbsr.biggestWin = g.bet * 2;
      }
      gameStats.mpbsr.played++;
      recordGame('mpbsr', g.bet, iWon ? g.bet * 2 : 0);
      
      setTimeout(() => {
        const box = document.getElementById('mpbsrGameOverContent');
        if (iWon) {
          playWinSound();
          box.innerHTML = `<div style="font-size:60px;margin-bottom:12px;">🏆</div>
            <div style="font-family:'Orbitron';font-size:22px;color:var(--green);margin-bottom:8px;">YOU WIN!</div>
            <div style="font-size:14px;color:var(--text2);margin-bottom:8px;">${opName} is eliminated!</div>
            <div style="font-family:'Orbitron';font-size:28px;color:var(--gold);margin-bottom:16px;">+$${g.bet.toLocaleString()}</div>
            <button onclick="mpbsrBackToLobby()" class="action-btn primary" style="padding:14px 32px;">BACK TO LOBBY</button>`;
          spawnParticles(window.innerWidth / 2, window.innerHeight / 2, 30);
        } else {
          playLoseSound();
          box.innerHTML = `<div style="font-size:60px;margin-bottom:12px;">💀</div>
            <div style="font-family:'Orbitron';font-size:22px;color:var(--red);margin-bottom:8px;">YOU LOSE</div>
            <div style="font-size:14px;color:var(--text2);margin-bottom:8px;">You've been eliminated...</div>
            <div style="font-family:'Orbitron';font-size:28px;color:var(--red);margin-bottom:16px;">-$${g.bet.toLocaleString()}</div>
            <button onclick="mpbsrBackToLobby()" class="action-btn primary" style="padding:14px 32px;">BACK TO LOBBY</button>`;
        }
        document.getElementById('mpbsrGameOver').style.display = 'flex';
      }, 1000);
    }
  });
}

async function mpbsrShoot(target) {
  if (!mpbsrGameId) return;
  const gid = mpbsrGameId;
  const snap = await window._fbGet('casino/bsrGames/' + gid);
  const g = snap.val();
  if (!g || g.status !== 'active') return;
  
  const isHost = g.host === window._currentPlayerId;
  const myTurn = (g.currentTurn === 'host' && isHost) || (g.currentTurn === 'guest' && !isHost);
  if (!myTurn) return;
  
  const shells = g.shells.split(',');
  const idx = g.shellIdx || 0;
  if (idx >= shells.length) return; // No shells left (shouldn't happen)
  
  const shell = shells[idx];
  const isLive = shell === 'live';
  const myName = isHost ? g.hostName : g.guestName;
  const opName = isHost ? g.guestName : g.hostName;
  const lk = Date.now().toString(36) + Math.random().toString(36).slice(2, 4);
  
  const updates = { shellIdx: idx + 1 };
  let dmg = isLive ? (g.sawActive ? 2 : 1) : 0;
  
  if (g.sawActive) updates.sawActive = false;
  
  if (target === 'opponent') {
    if (isLive) {
      const hpKey = isHost ? 'guestHP' : 'hostHP';
      const newHP = Math.max(0, (isHost ? g.guestHP : g.hostHP) - dmg);
      updates[hpKey] = newHP;
      await window._fbSet('casino/bsrGames/' + gid + '/log/' + lk, {
        msg: `🔫 ${myName} shoots ${opName} — 💥 LIVE! -${dmg} HP`, color: '#ff4444'
      });
      if (newHP <= 0) {
        updates.status = 'finished';
        updates.winner = isHost ? 'host' : 'guest';
        const lk2 = lk + 'w';
        await window._fbSet('casino/bsrGames/' + gid + '/log/' + lk2, {
          msg: `☠️ ${opName} has been eliminated!`, color: '#ff4444'
        });
      } else {
        // Turn passes (or cuff skip)
        if (g.cuffActive) {
          updates.cuffActive = false;
          updates.currentTurn = g.currentTurn; // Same person goes again
          const lk3 = lk + 'c';
          await window._fbSet('casino/bsrGames/' + gid + '/log/' + lk3, {
            msg: `🔗 ${opName} is handcuffed — skips their turn!`, color: 'var(--neon)'
          });
        } else {
          updates.currentTurn = isHost ? 'guest' : 'host';
        }
      }
    } else {
      await window._fbSet('casino/bsrGames/' + gid + '/log/' + lk, {
        msg: `🔫 ${myName} shoots ${opName} — 🔵 BLANK! Turn passes.`, color: 'var(--text2)'
      });
      if (g.cuffActive) {
        updates.cuffActive = false;
        updates.currentTurn = g.currentTurn;
      } else {
        updates.currentTurn = isHost ? 'guest' : 'host';
      }
    }
  } else {
    // Shoot self
    if (isLive) {
      const hpKey = isHost ? 'hostHP' : 'guestHP';
      const newHP = Math.max(0, (isHost ? g.hostHP : g.guestHP) - dmg);
      updates[hpKey] = newHP;
      await window._fbSet('casino/bsrGames/' + gid + '/log/' + lk, {
        msg: `🤕 ${myName} shoots self — 💥 LIVE! -${dmg} HP`, color: '#ff8800'
      });
      if (newHP <= 0) {
        updates.status = 'finished';
        updates.winner = isHost ? 'guest' : 'host';
      } else {
        if (g.cuffActive) {
          updates.cuffActive = false;
          updates.currentTurn = g.currentTurn;
        } else {
          updates.currentTurn = isHost ? 'guest' : 'host';
        }
      }
    } else {
      await window._fbSet('casino/bsrGames/' + gid + '/log/' + lk, {
        msg: `🤕 ${myName} shoots self — 🔵 BLANK! Bonus turn!`, color: 'var(--green)'
      });
      // Keep same turn
      updates.currentTurn = g.currentTurn;
    }
  }
  
  // Check if shells exhausted → new round
  if (!updates.status && updates.shellIdx >= shells.length) {
    const newRound = (g.round || 1) + 1;
    const rd = mpbsrGenerateRound(newRound);
    updates.round = newRound;
    updates.shells = rd.shells.join(',');
    updates.shellIdx = 0;
    updates.liveCount = rd.liveCount;
    updates.blankCount = rd.blankCount;
    updates.hostItems = rd.hostItems.join(',');
    updates.guestItems = rd.guestItems.join(',');
    updates.sawActive = false;
    updates.cuffActive = false;
    const lkr = lk + 'r';
    await window._fbSet('casino/bsrGames/' + gid + '/log/' + lkr, {
      msg: `📦 Round ${newRound} — New shells loaded!`, color: 'var(--neon)'
    });
  }
  
  await window._fbUpdate('casino/bsrGames/' + gid, updates);
}

async function mpbsrUseItem(itemIndex) {
  if (!mpbsrGameId) return;
  const gid = mpbsrGameId;
  const snap = await window._fbGet('casino/bsrGames/' + gid);
  const g = snap.val();
  if (!g || g.status !== 'active') return;
  
  const isHost = g.host === window._currentPlayerId;
  const myTurn = (g.currentTurn === 'host' && isHost) || (g.currentTurn === 'guest' && !isHost);
  if (!myTurn) return;
  
  const itemsKey = isHost ? 'hostItems' : 'guestItems';
  const items = (g[itemsKey] || '').split(',').filter(Boolean);
  if (itemIndex >= items.length) return;
  
  const itemId = items[itemIndex];
  const itemInfo = MPBSR_ITEMS.find(it => it.id === itemId);
  if (!itemInfo) return;
  
  const myName = isHost ? g.hostName : g.guestName;
  const opName = isHost ? g.guestName : g.hostName;
  const lk = Date.now().toString(36) + Math.random().toString(36).slice(2, 4);
  
  // Remove item
  items.splice(itemIndex, 1);
  const updates = { [itemsKey]: items.join(',') };
  
  switch (itemId) {
    case 'saw':
      updates.sawActive = true;
      await window._fbSet('casino/bsrGames/' + gid + '/log/' + lk, {
        msg: `🪚 ${myName} uses Saw — next LIVE deals 2× damage!`, color: 'var(--gold)'
      });
      break;
    case 'mag': {
      const shells = g.shells.split(',');
      const cur = shells[g.shellIdx || 0] || '?';
      await window._fbSet('casino/bsrGames/' + gid + '/log/' + lk, {
        msg: `🔍 ${myName} uses Magnifying Glass...`, color: 'var(--neon)'
      });
      // Only show the result to the user (via toast)
      showToast(`Current shell: ${cur === 'live' ? '🔴 LIVE' : '🔵 BLANK'}`, cur === 'live' ? false : true);
      break;
    }
    case 'cig': {
      const hpKey = isHost ? 'hostHP' : 'guestHP';
      const curHP = isHost ? g.hostHP : g.guestHP;
      updates[hpKey] = Math.min(curHP + 1, 4);
      await window._fbSet('casino/bsrGames/' + gid + '/log/' + lk, {
        msg: `🚬 ${myName} uses Cigarette — +1 HP!`, color: 'var(--green)'
      });
      break;
    }
    case 'cuff':
      updates.cuffActive = true;
      await window._fbSet('casino/bsrGames/' + gid + '/log/' + lk, {
        msg: `🔗 ${myName} uses Handcuffs on ${opName}!`, color: 'var(--neon)'
      });
      break;
    case 'phone': {
      const shells = g.shells.split(',');
      const remaining = shells.slice(g.shellIdx || 0);
      if (remaining.length > 0) {
        const ri = Math.floor(Math.random() * remaining.length);
        const revealPos = (g.shellIdx || 0) + ri + 1;
        showToast(`Shell #${revealPos}: ${remaining[ri] === 'live' ? '🔴 LIVE' : '🔵 BLANK'}`, true);
      }
      const lk2 = Date.now().toString(36) + Math.random().toString(36).slice(2, 4);
      await window._fbSet('casino/bsrGames/' + gid + '/log/' + lk2, {
        msg: `📱 ${myName} uses Burner Phone...`, color: 'var(--neon)'
      });
      break;
    }
  }
  
  await window._fbUpdate('casino/bsrGames/' + gid, updates);
}


// ============ SETTINGS ============
let casinoSettings = JSON.parse(localStorage.getItem('casino_settings')) || {
  sound: true,
  particles: true,
  reducedAnim: false,
  theme: 'dark'
};

function openSettingsPanel() {
  document.getElementById('settingsOverlay').style.display = 'block';
  // Sync toggles
  const snd = document.getElementById('settingSound');
  const part = document.getElementById('settingParticles');
  const ra = document.getElementById('settingReducedAnim');
  if (snd) { snd.checked = casinoSettings.sound; updateToggleVisual('settingSound', casinoSettings.sound); }
  if (part) { part.checked = casinoSettings.particles; updateToggleVisual('settingParticles', casinoSettings.particles); }
  if (ra) { ra.checked = casinoSettings.reducedAnim; updateToggleVisual('settingReducedAnim', casinoSettings.reducedAnim); }
  // Highlight active theme
  document.querySelectorAll('.theme-btn').forEach(b => {
    b.style.borderColor = b.dataset.theme === casinoSettings.theme ? 'var(--neon)' : 'var(--border)';
  });
}

function closeSettingsPanel() {
  document.getElementById('settingsOverlay').style.display = 'none';
}

function updateToggleVisual(id, on) {
  const knob = document.getElementById(id + 'Knob');
  if (!knob) return;
  knob.style.left = on ? '25px' : '3px';
  knob.style.background = on ? 'var(--neon)' : 'var(--text2)';
  knob.parentElement.querySelector('span').style.background = on ? 'rgba(0,240,255,.3)' : 'var(--surface2)';
}

function settingToggle(key, val) {
  casinoSettings[key] = val;
  localStorage.setItem('casino_settings', JSON.stringify(casinoSettings));
  updateToggleVisual('setting' + key.charAt(0).toUpperCase() + key.slice(1), val);

  // Apply settings
  if (key === 'sound') {
    soundMuted = !val;
    const mb = document.getElementById('muteBtn');
    if (mb) mb.textContent = val ? '🔊' : '🔇';
  }
  if (key === 'particles') {
    const c = document.getElementById('particles');
    if (c) c.style.display = val ? 'block' : 'none';
  }
  if (key === 'reducedAnim') {
    document.body.style.setProperty('--anim-speed', val ? '0.1s' : '');
    if (val) document.body.classList.add('reduced-motion'); else document.body.classList.remove('reduced-motion');
  }
}

const THEMES = {
  dark: { bg:'#040814', surface1:'#0a0f2e', surface:'rgba(255,255,255,0.03)', surface2:'rgba(255,255,255,0.06)', border:'rgba(255,255,255,0.08)', text:'#e8eaed', text2:'rgba(255,255,255,0.5)', neon:'#00f0ff', gold:'#ffd700', green:'#00e676', red:'#ff4444' },
  midnight: { bg:'#0d0221', surface1:'#150330', surface:'rgba(211,44,230,0.04)', surface2:'rgba(211,44,230,0.08)', border:'rgba(211,44,230,0.15)', text:'#e8d5f5', text2:'rgba(255,255,255,0.5)', neon:'#d32ce6', gold:'#ffd700', green:'#00e676', red:'#ff4444' },
  ocean: { bg:'#001a33', surface1:'#002244', surface:'rgba(0,191,255,0.04)', surface2:'rgba(0,191,255,0.08)', border:'rgba(0,191,255,0.15)', text:'#d4efff', text2:'rgba(255,255,255,0.5)', neon:'#00bfff', gold:'#ffd700', green:'#00e676', red:'#ff4444' },
  forest: { bg:'#0a1f0a', surface1:'#122812', surface:'rgba(0,230,118,0.04)', surface2:'rgba(0,230,118,0.08)', border:'rgba(0,230,118,0.15)', text:'#d4f5d4', text2:'rgba(255,255,255,0.5)', neon:'#00e676', gold:'#ffd700', green:'#00e676', red:'#ff4444' },
  crimson: { bg:'#1a0505', surface1:'#260808', surface:'rgba(255,68,68,0.04)', surface2:'rgba(255,68,68,0.08)', border:'rgba(255,68,68,0.15)', text:'#f5d4d4', text2:'rgba(255,255,255,0.5)', neon:'#ff4444', gold:'#ffd700', green:'#00e676', red:'#ff4444' },
  gold: { bg:'#1a1500', surface1:'#262000', surface:'rgba(255,215,0,0.04)', surface2:'rgba(255,215,0,0.08)', border:'rgba(255,215,0,0.15)', text:'#f5eed4', text2:'rgba(255,255,255,0.5)', neon:'#ffd700', gold:'#ffd700', green:'#00e676', red:'#ff4444' },
};

function setTheme(name) {
  const t = THEMES[name];
  if (!t) return;
  casinoSettings.theme = name;
  localStorage.setItem('casino_settings', JSON.stringify(casinoSettings));
  const root = document.documentElement;
  Object.entries(t).forEach(([k, v]) => {
    root.style.setProperty('--' + k.replace(/([A-Z])/g, m => '-' + m.toLowerCase()), v);
  });
  // Highlight active
  document.querySelectorAll('.theme-btn').forEach(b => {
    b.style.borderColor = b.dataset.theme === name ? 'var(--neon)' : 'var(--border)';
  });
}

// Apply saved settings on load
(function applySavedSettings() {
  if (!casinoSettings.sound) {
    soundMuted = true;
    setTimeout(() => {
      const mb = document.getElementById('muteBtn');
      if (mb) mb.textContent = '🔇';
    }, 100);
  }
  if (!casinoSettings.particles) {
    const c = document.getElementById('particles');
    if (c) c.style.display = 'none';
  }
  if (casinoSettings.reducedAnim) {
    document.body.classList.add('reduced-motion');
  }
  if (casinoSettings.theme && casinoSettings.theme !== 'dark') {
    setTheme(casinoSettings.theme);
  }
})();

// ============ SHOP / POTIONS ============
let activePotions = JSON.parse(localStorage.getItem('casino_potions')) || {};
// { luck: { stacks: 0, expires: 0 }, speed: { active: false, expires: 0 }, shield: {...}, xp: {...} }

function openShopOverlay() {
  document.getElementById('shopOverlay').style.display = 'block';
  shopRefresh();
}

function closeShopOverlay() {
  document.getElementById('shopOverlay').style.display = 'none';
}

function shopRefresh() {
  document.getElementById('shopBalText').textContent = (typeof balance !== 'undefined' ? balance : 0).toLocaleString();
  // Luck
  const lp = activePotions.luck || { stacks: 0, expires: 0 };
  const luckActive = lp.stacks > 0 && lp.expires > Date.now();
  document.getElementById('shopLuckCount').textContent = luckActive ? lp.stacks : '0';
  // Speed
  const sp = activePotions.speed || { active: false, expires: 0 };
  document.getElementById('shopSpeedActive').textContent = sp.active && sp.expires > Date.now() ? 'ON' : 'OFF';
  document.getElementById('shopSpeedActive').style.color = sp.active && sp.expires > Date.now() ? 'var(--green)' : 'var(--text2)';
  // Shield
  const sh = activePotions.shield || { active: false, expires: 0 };
  document.getElementById('shopShieldActive').textContent = sh.active && sh.expires > Date.now() ? 'ON' : 'OFF';
  document.getElementById('shopShieldActive').style.color = sh.active && sh.expires > Date.now() ? 'var(--green)' : 'var(--text2)';
  // XP
  const xp = activePotions.xp || { active: false, expires: 0 };
  document.getElementById('shopXPActive').textContent = xp.active && xp.expires > Date.now() ? 'ON' : 'OFF';
  document.getElementById('shopXPActive').style.color = xp.active && xp.expires > Date.now() ? 'var(--green)' : 'var(--text2)';

  // Active effects panel
  const eff = [];
  if (luckActive) { const rem = Math.ceil((lp.expires - Date.now()) / 60000); eff.push(`<div style="padding:6px;border-radius:6px;background:rgba(255,215,0,.1);border:1px solid rgba(255,215,0,.2);"><span style="font-size:14px;">🍀</span> Luck ×${lp.stacks} — ${rem}m left</div>`); }
  if (sp.active && sp.expires > Date.now()) { const rem = Math.ceil((sp.expires - Date.now()) / 60000); eff.push(`<div style="padding:6px;border-radius:6px;background:rgba(0,240,255,.1);border:1px solid rgba(0,240,255,.2);"><span style="font-size:14px;">⚡</span> Speed 2× — ${rem}m left</div>`); }
  if (sh.active && sh.expires > Date.now()) { const rem = Math.ceil((sh.expires - Date.now()) / 60000); eff.push(`<div style="padding:6px;border-radius:6px;background:rgba(0,230,118,.1);border:1px solid rgba(0,230,118,.2);"><span style="font-size:14px;">🛡️</span> Shield — ${rem}m left</div>`); }
  if (xp.active && xp.expires > Date.now()) { const rem = Math.ceil((xp.expires - Date.now()) / 60000); eff.push(`<div style="padding:6px;border-radius:6px;background:rgba(138,43,226,.1);border:1px solid rgba(138,43,226,.2);"><span style="font-size:14px;">📈</span> XP 2× — ${rem}m left</div>`); }
  document.getElementById('shopActiveEffects').innerHTML = eff.length ? eff.join('') : '<div style="color:var(--text2);font-size:12px;text-align:center;">No active effects</div>';
}

function shopBuyPotion(type) {
  const prices = { luck: 2000, speed: 3000, shield: 5000, xp: 4000 };
  const price = prices[type];
  if (!price) return;
  if (balance < price) { showToast('Not enough balance! Need $' + price.toLocaleString(), false); return; }

  balance -= price;
  updateBalDisplay();
  playClickSound();

  if (type === 'luck') {
    if (!activePotions.luck) activePotions.luck = { stacks: 0, expires: 0 };
    if (activePotions.luck.stacks >= 5 && activePotions.luck.expires > Date.now()) {
      showToast('Max 5 luck stacks!', false);
      balance += price; updateBalDisplay(); return;
    }
    activePotions.luck.stacks = Math.min(5, (activePotions.luck.stacks || 0) + 1);
    activePotions.luck.expires = Date.now() + 10 * 60 * 1000; // 10 min
    showToast('🍀 Luck Potion active! Stack: ' + activePotions.luck.stacks + '/5', true);
  } else if (type === 'speed') {
    activePotions.speed = { active: true, expires: Date.now() + 15 * 60 * 1000 };
    showToast('⚡ Speed Potion active! 2× speed for 15 min', true);
  } else if (type === 'shield') {
    activePotions.shield = { active: true, expires: Date.now() + 5 * 60 * 1000 };
    showToast('🛡️ Shield active! Loss protection for 5 min', true);
  } else if (type === 'xp') {
    activePotions.xp = { active: true, expires: Date.now() + 20 * 60 * 1000 };
    showToast('📈 XP Boost active! 2× stats for 20 min', true);
  }

  localStorage.setItem('casino_potions', JSON.stringify(activePotions));
  window._firebaseSave && firebaseSave();
  shopRefresh();
}

// Helper: get current luck bonus multiplier
function getLuckBonus() {
  const lp = activePotions.luck || { stacks: 0, expires: 0 };
  if (lp.stacks > 0 && lp.expires > Date.now()) return 1 + (lp.stacks * 0.05);
  return 1;
}

// Helper: check speed potion
function isSpeedActive() {
  const sp = activePotions.speed || { active: false, expires: 0 };
  return sp.active && sp.expires > Date.now();
}

// Helper: check shield
function isShieldActive() {
  const sh = activePotions.shield || { active: false, expires: 0 };
  return sh.active && sh.expires > Date.now();
}

// ============ SERIAL NUMBERED ITEMS ============
let serialCounter = parseInt(localStorage.getItem('casino_serial_counter')) || 100000;

function generateSerial() {
  serialCounter++;
  localStorage.setItem('casino_serial_counter', serialCounter);
  // Format: SN-XXXXX-XXXX
  const hex = serialCounter.toString(16).toUpperCase().padStart(9, '0');
  return 'SN-' + hex.slice(0, 5) + '-' + hex.slice(5);
}

// Patch addToInventory to include serial numbers
const _origAddToInventory = addToInventory;
addToInventory = function(itemId) {
  _origAddToInventory(itemId);
  // Attach serial number to the most recently added item
  if (inventory.length > 0) {
    const lastItem = inventory[inventory.length - 1];
    if (!lastItem.serial) lastItem.serial = generateSerial();
  }
};

// ============ SPECIAL LIMITED CASES ============
let limitedCases = [];
let limitedCaseTimer = null;

function initLimitedCases() {
  // Generate a new limited case every 30 minutes if none exists
  const saved = JSON.parse(localStorage.getItem('casino_limited_cases')) || [];
  limitedCases = saved.filter(c => c.expires > Date.now());
  if (limitedCases.length === 0) {
    spawnLimitedCase();
  }
  renderLimitedCases();
  // Check every minute
  if (limitedCaseTimer) clearInterval(limitedCaseTimer);
  limitedCaseTimer = setInterval(() => {
    limitedCases = limitedCases.filter(c => c.expires > Date.now());
    if (limitedCases.length === 0) spawnLimitedCase();
    renderLimitedCases();
    localStorage.setItem('casino_limited_cases', JSON.stringify(limitedCases));
  }, 60000);
}

function spawnLimitedCase() {
  const names = ['Neon Surge', 'Void Eclipse', 'Golden Rush', 'Crimson Tide', 'Frost Bite', 'Shadow Drop', 'Star Burst'];
  const icons = ['⚡', '🌑', '🌟', '🔥', '❄️', '🖤', '💫'];
  const idx = Math.floor(Math.random() * names.length);
  const multiplier = 1.5 + Math.random() * 2; // 1.5x - 3.5x value multiplier
  const price = Math.floor((Math.random() * 9000 + 1000) / 100) * 100;
  const qty = Math.floor(Math.random() * 20) + 5; // 5-24 available
  const duration = (Math.random() * 20 + 10) * 60 * 1000; // 10-30 min

  // Pick items with boosted rare odds
  const possibleItems = Object.keys(ITEM_CATALOG);
  const items = [];
  for (let i = 0; i < 10; i++) {
    const itId = possibleItems[Math.floor(Math.random() * possibleItems.length)];
    const cat = ITEM_CATALOG[itId];
    const rar = RARITY[cat.rarity];
    items.push({ id: itId, w: Math.max(1, 15 - rar.tier * 2) });
  }

  const lc = {
    id: 'ltd_' + Date.now(),
    name: names[idx] + ' Edition',
    icon: icons[idx],
    price: price,
    items: items,
    remaining: qty,
    total: qty,
    expires: Date.now() + duration,
    valueMult: multiplier
  };
  limitedCases.push(lc);
  localStorage.setItem('casino_limited_cases', JSON.stringify(limitedCases));
  showToast('🌟 NEW LIMITED CASE: ' + lc.name + '!', true);
}

function renderLimitedCases() {
  const container = document.getElementById('limitedCasesContainer');
  if (!container) return;
  if (limitedCases.length === 0) {
    container.innerHTML = '<div style="text-align:center;color:var(--text2);font-size:12px;padding:20px;">No limited cases available right now. Check back soon!</div>';
    return;
  }
  container.innerHTML = limitedCases.map(lc => {
    const remainMin = Math.max(0, Math.ceil((lc.expires - Date.now()) / 60000));
    return `<div style="background:linear-gradient(135deg,rgba(255,215,0,.08),rgba(255,68,68,.05));border:1px solid rgba(255,215,0,.3);border-radius:12px;padding:14px;text-align:center;">
      <div style="font-size:32px;margin-bottom:4px;">${lc.icon}</div>
      <div style="font-weight:700;color:var(--gold);font-size:13px;">${lc.name}</div>
      <div style="font-size:10px;color:var(--text2);margin:4px 0;">Boosted: ${lc.valueMult.toFixed(1)}× value</div>
      <div style="font-size:10px;color:var(--red);margin-bottom:6px;">⏱️ ${remainMin}m left · ${lc.remaining}/${lc.total} remaining</div>
      <button onclick="openLimitedCase('${lc.id}')" class="action-btn primary" style="padding:6px 14px;font-size:12px;${lc.remaining <= 0 ? 'opacity:0.4;pointer-events:none;' : ''}" ${lc.remaining <= 0 ? 'disabled' : ''}>$${lc.price.toLocaleString()}</button>
    </div>`;
  }).join('');
}

function openLimitedCase(lcId) {
  const lc = limitedCases.find(c => c.id === lcId);
  if (!lc || lc.remaining <= 0 || lc.expires < Date.now()) { showToast('Case no longer available!', false); return; }
  if (balance < lc.price) { showToast('Not enough balance!', false); return; }
  balance -= lc.price;
  updateBalDisplay();
  lc.remaining--;
  localStorage.setItem('casino_limited_cases', JSON.stringify(limitedCases));

  // Pick a random item with luck bonus
  const lucky = getLuckBonus();
  let totalW = lc.items.reduce((s, it) => {
    const cat = ITEM_CATALOG[it.id];
    const rar = RARITY[cat.rarity];
    // Luck bonus slightly increases rare item weights
    return s + it.w * (rar.tier >= 3 ? lucky : 1);
  }, 0);
  let rng = Math.random() * totalW;
  let wonItem = lc.items[0];
  for (const it of lc.items) {
    const cat = ITEM_CATALOG[it.id];
    const rar = RARITY[cat.rarity];
    rng -= it.w * (rar.tier >= 3 ? lucky : 1);
    if (rng <= 0) { wonItem = it; break; }
  }

  const cat = ITEM_CATALOG[wonItem.id];
  const rar = RARITY[cat.rarity];
  addToInventory(wonItem.id);
  const val = Math.floor(cat.baseValue * lc.valueMult);

  showToast(`${lc.icon} ${cat.icon} ${cat.name} (${rar.label}) — Worth ~$${val.toLocaleString()}!`, true);
  playClickSound();
  renderLimitedCases();
  window._firebaseSave && firebaseSave();
}

// ============ CRYPTO / BITCOIN TRADING ============
let cryptoPortfolio = JSON.parse(localStorage.getItem('casino_crypto')) || {};
// { BTC: { amount: 0, avgBuy: 0 }, ETH: {...}, ... }
let cryptoPrices = {};
let cryptoHistory = {};
let cryptoInterval = null;

const CRYPTO_COINS = [
  { id: 'BTC', name: 'Bitcoin', icon: '₿', basePrice: 45000, volatility: 0.03 },
  { id: 'ETH', name: 'Ethereum', icon: 'Ξ', basePrice: 2800, volatility: 0.04 },
  { id: 'DOGE', name: 'Dogecoin', icon: '🐕', basePrice: 0.15, volatility: 0.08 },
  { id: 'SOL', name: 'Solana', icon: '◎', basePrice: 120, volatility: 0.05 },
  { id: 'PEPE', name: 'PepeCoin', icon: '🐸', basePrice: 0.001, volatility: 0.12 },
  { id: 'ISLAND', name: 'IslandCoin', icon: '🏝️', basePrice: 5.50, volatility: 0.10 },
];

function initCrypto() {
  if (!cryptoInterval) {
    // Initialize prices
    CRYPTO_COINS.forEach(c => {
      if (!cryptoPrices[c.id]) {
        cryptoPrices[c.id] = c.basePrice * (0.8 + Math.random() * 0.4);
      }
      if (!cryptoHistory[c.id]) {
        cryptoHistory[c.id] = [];
        // Generate some history
        let p = cryptoPrices[c.id];
        for (let i = 0; i < 30; i++) {
          p *= (1 + (Math.random() - 0.5) * c.volatility);
          cryptoHistory[c.id].push(p);
        }
      }
      if (!cryptoPortfolio[c.id]) {
        cryptoPortfolio[c.id] = { amount: 0, avgBuy: 0, totalInvested: 0 };
      }
    });

    // Tick every 3 seconds
    cryptoInterval = setInterval(cryptoTick, 3000);
  }
  renderCrypto();
}

function cryptoTick() {
  CRYPTO_COINS.forEach(c => {
    const change = (Math.random() - 0.48) * c.volatility; // slight upward bias
    cryptoPrices[c.id] *= (1 + change);
    cryptoPrices[c.id] = Math.max(c.basePrice * 0.01, cryptoPrices[c.id]); // floor
    cryptoHistory[c.id].push(cryptoPrices[c.id]);
    if (cryptoHistory[c.id].length > 60) cryptoHistory[c.id].shift();
  });
  // Re-render if crypto panel is active
  if (document.querySelector('#cryptoPanel.active')) renderCrypto();
}

function renderCrypto() {
  const panel = document.getElementById('cryptoContent');
  if (!panel) return;

  panel.innerHTML = CRYPTO_COINS.map(c => {
    const price = cryptoPrices[c.id] || c.basePrice;
    const hist = cryptoHistory[c.id] || [];
    const prev = hist.length > 1 ? hist[hist.length - 2] : price;
    const change = prev ? ((price - prev) / prev * 100) : 0;
    const isUp = change >= 0;
    const port = cryptoPortfolio[c.id] || { amount: 0, avgBuy: 0, totalInvested: 0 };
    const holdings = port.amount * price;
    const pnl = port.amount > 0 ? holdings - port.totalInvested : 0;

    // Mini sparkline
    const sparkline = cryptoSparkline(hist);

    return `<div style="background:var(--surface);border:1px solid var(--border);border-radius:12px;padding:14px;margin-bottom:10px;">
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px;">
        <div style="display:flex;align-items:center;gap:8px;">
          <span style="font-size:20px;">${c.icon}</span>
          <div>
            <div style="font-weight:700;color:var(--text);font-size:14px;">${c.name}</div>
            <div style="font-size:10px;color:var(--text2);">${c.id}</div>
          </div>
        </div>
        <div style="text-align:right;">
          <div style="font-family:'Orbitron';font-size:14px;color:var(--text);font-weight:700;">$${cryptoFormatPrice(price)}</div>
          <div style="font-size:11px;color:${isUp ? 'var(--green)' : 'var(--red)'};">${isUp ? '▲' : '▼'} ${Math.abs(change).toFixed(2)}%</div>
        </div>
      </div>

      ${sparkline}

      <div style="display:flex;justify-content:space-between;align-items:center;margin-top:8px;padding-top:8px;border-top:1px solid var(--border);">
        <div style="font-size:11px;color:var(--text2);">Holdings: ${port.amount.toFixed(6)} ${c.id} ($${cryptoFormatPrice(holdings)}) <span style="color:${pnl >= 0 ? 'var(--green)' : 'var(--red)'};">${pnl >= 0 ? '+' : ''}$${cryptoFormatPrice(pnl)}</span></div>
      </div>
      <div style="display:flex;gap:6px;margin-top:8px;">
        <input type="number" id="cryptoAmt_${c.id}" placeholder="$ amount" min="1" value="100" style="flex:1;padding:6px;background:var(--bg);border:1px solid var(--border);border-radius:6px;color:var(--text);font-size:12px;">
        <button onclick="cryptoBuy('${c.id}')" class="action-btn primary" style="padding:6px 14px;font-size:11px;">BUY</button>
        <button onclick="cryptoSell('${c.id}')" class="action-btn danger" style="padding:6px 14px;font-size:11px;">SELL</button>
        <button onclick="cryptoSellAll('${c.id}')" class="action-btn secondary" style="padding:6px 10px;font-size:10px;">SELL ALL</button>
      </div>
    </div>`;
  }).join('');
}

function cryptoSparkline(hist) {
  if (hist.length < 2) return '';
  const w = 200, h = 40;
  const min = Math.min(...hist);
  const max = Math.max(...hist);
  const range = max - min || 1;
  const points = hist.map((v, i) => {
    const x = (i / (hist.length - 1)) * w;
    const y = h - ((v - min) / range) * h;
    return `${x},${y}`;
  }).join(' ');
  const isUp = hist[hist.length - 1] >= hist[0];
  const color = isUp ? '#00e676' : '#ff4444';
  return `<svg width="100%" viewBox="0 0 ${w} ${h}" style="display:block;max-height:40px;"><polyline points="${points}" fill="none" stroke="${color}" stroke-width="1.5" /></svg>`;
}

function cryptoFormatPrice(p) {
  if (Math.abs(p) >= 1) return p.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 2 });
  if (Math.abs(p) >= 0.01) return p.toFixed(4);
  return p.toFixed(8);
}

function cryptoBuy(coinId) {
  const coin = CRYPTO_COINS.find(c => c.id === coinId);
  if (!coin) return;
  const amtInput = document.getElementById('cryptoAmt_' + coinId);
  const dollars = parseFloat(amtInput.value) || 0;
  if (dollars <= 0 || dollars > balance) { showToast('Invalid amount!', false); return; }

  const price = cryptoPrices[coinId];
  const coinAmount = dollars / price;

  balance -= dollars;
  updateBalDisplay();

  const port = cryptoPortfolio[coinId];
  port.totalInvested += dollars;
  port.amount += coinAmount;
  port.avgBuy = port.totalInvested / port.amount;

  localStorage.setItem('casino_crypto', JSON.stringify(cryptoPortfolio));
  playClickSound();
  showToast(`Bought ${coinAmount.toFixed(6)} ${coinId} for $${dollars.toLocaleString()}`, true);
  renderCrypto();
  window._firebaseSave && firebaseSave();
}

function cryptoSell(coinId) {
  const coin = CRYPTO_COINS.find(c => c.id === coinId);
  if (!coin) return;
  const amtInput = document.getElementById('cryptoAmt_' + coinId);
  const dollars = parseFloat(amtInput.value) || 0;
  if (dollars <= 0) { showToast('Enter a valid amount!', false); return; }
  const price = cryptoPrices[coinId];
  const coinAmount = dollars / price;

  const port = cryptoPortfolio[coinId];
  if (!port || port.amount <= 0) { showToast('No ' + coinId + ' to sell!', false); return; }
  if (coinAmount > port.amount) { showToast('Not enough ' + coinId + '!', false); return; }

  const originalAmount = port.amount;
  port.amount -= coinAmount;
  const sellPortion = coinAmount / originalAmount;
  port.totalInvested = Math.max(0, port.totalInvested * (1 - sellPortion));

  balance += dollars;
  updateBalDisplay();

  localStorage.setItem('casino_crypto', JSON.stringify(cryptoPortfolio));
  playClickSound();
  showToast(`Sold ${coinAmount.toFixed(6)} ${coinId} for $${dollars.toLocaleString()}`, true);
  renderCrypto();
  window._firebaseSave && firebaseSave();
}

function cryptoSellAll(coinId) {
  const port = cryptoPortfolio[coinId];
  if (!port || port.amount <= 0) { showToast('No ' + coinId + ' to sell!', false); return; }
  const price = cryptoPrices[coinId];
  const dollars = port.amount * price;

  balance += dollars;
  updateBalDisplay();
  port.amount = 0;
  port.totalInvested = 0;
  port.avgBuy = 0;

  localStorage.setItem('casino_crypto', JSON.stringify(cryptoPortfolio));
  playClickSound();
  showToast(`Sold all ${coinId} for $${Math.floor(dollars).toLocaleString()}`, true);
  renderCrypto();
  window._firebaseSave && firebaseSave();
}

// Init limited cases on load
setTimeout(initLimitedCases, 1000);
</script>

</body>
</html>
